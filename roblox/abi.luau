-- Generated by roblox-rs
local abi = { ffi = {} };
local getPointer, createPointer, memory, storeU8, storeU32, loadU8, loadU32, loadString, allocString, allocVec, functions, invokeFunction, dropFunctionRef;
local connections = {};
local function createConnection(stack, vtable, connection)
	local id = createPointer(connection);
	connections[id] = { stack, vtable };
	return id;
end
function abi.load(wasm, rt, util)
	getPointer, createPointer, memory, storeU8, storeU32, loadU8, loadU32, loadString, allocString, allocVec, functions, invokeFunction, dropFunctionRef = util.getPointer, util.createPointer, wasm.memory_list.memory, rt.store.i32_n8, rt.store.i32, rt.load.i32_u8, rt.load.i32, rt.load.string, wasm.func_list.__heap_alloc_string, wasm.func_list.__heap_alloc_vec, wasm.table_list.__indirect_function_table, util.invokeFunction, util.dropFunctionRef;
end
function abi.ffi.disconnect_connection(connection)
	local func = connections[connection];
	if not func then return end

	getPointer(connection):Disconnect();
	dropFunctionRef(func[1], func[2]);
	connections[connection] = nil;
end
function abi.ffi.prop_get_instance_archivable(instance)
	return getPointer(instance).Archivable and 1 or 0;
end
function abi.ffi.prop_set_instance_archivable(instance, p_Archivable0)
	getPointer(instance).Archivable = p_Archivable0 == 1;
end
function abi.ffi.prop_get_instance_class_name(output, instance)
	local value0 = getPointer(instance).ClassName;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_instance_name(output, instance)
	local value0 = getPointer(instance).Name;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_instance_name(instance, p_Name0, p_Name1)
	getPointer(instance).Name = loadString(memory, p_Name0, p_Name1);
end
function abi.ffi.prop_get_instance_parent(output, instance)
	local value0 = getPointer(instance).Parent;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_instance_parent(instance, p_Parent0, p_Parent1)
	local value0;
	if p_Parent0 == 1 then
		value0 = getPointer(p_Parent1);
	end
	getPointer(instance).Parent = value0;
end
function abi.ffi.dyn_fn_instance_clear_all_children(instance)
	return getPointer(instance):ClearAllChildren();
end
function abi.ffi.dyn_fn_instance_fn_clone(output, instance)
	local value0 = getPointer(instance):FnClone();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_instance_destroy(instance)
	return getPointer(instance):Destroy();
end
function abi.ffi.dyn_fn_instance_find_first_ancestor(output, instance, p_name0, p_name1)
	local value0 = getPointer(instance):FindFirstAncestor(loadString(memory, p_name0, p_name1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_instance_find_first_ancestor_of_class(output, instance, p_className0, p_className1)
	local value0 = getPointer(instance):FindFirstAncestorOfClass(loadString(memory, p_className0, p_className1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_instance_find_first_ancestor_which_is_a(output, instance, p_className0, p_className1)
	local value0 = getPointer(instance):FindFirstAncestorWhichIsA(loadString(memory, p_className0, p_className1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_instance_find_first_child(output, instance, p_name0, p_name1, p_recursive0)
	local value0 = getPointer(instance):FindFirstChild(loadString(memory, p_name0, p_name1), p_recursive0 == 1);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_instance_find_first_child_of_class(output, instance, p_className0, p_className1)
	local value0 = getPointer(instance):FindFirstChildOfClass(loadString(memory, p_className0, p_className1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_instance_find_first_child_which_is_a(output, instance, p_className0, p_className1, p_recursive0)
	local value0 = getPointer(instance):FindFirstChildWhichIsA(loadString(memory, p_className0, p_className1), p_recursive0 == 1);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_instance_find_first_descendant(output, instance, p_name0, p_name1)
	local value0 = getPointer(instance):FindFirstDescendant(loadString(memory, p_name0, p_name1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_instance_get_actor(output, instance)
	local value0 = getPointer(instance):GetActor();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_instance_get_attribute(instance, p_attribute0, p_attribute1)
	return createPointer(getPointer(instance):GetAttribute(loadString(memory, p_attribute0, p_attribute1)));
end
function abi.ffi.dyn_fn_instance_get_attributes(instance)
	return createPointer(getPointer(instance):GetAttributes());
end
function abi.ffi.dyn_fn_instance_get_children(output, instance)
	local result0 = getPointer(instance):GetChildren();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_instance_get_full_name(output, instance)
	local value0 = getPointer(instance):GetFullName();
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_instance_is_a(instance, p_className0, p_className1)
	return getPointer(instance):IsA(loadString(memory, p_className0, p_className1)) and 1 or 0;
end
function abi.ffi.dyn_fn_instance_is_ancestor_of(instance, p_descendant0)
	return getPointer(instance):IsAncestorOf(getPointer(p_descendant0)) and 1 or 0;
end
function abi.ffi.dyn_fn_instance_is_descendant_of(instance, p_ancestor0)
	return getPointer(instance):IsDescendantOf(getPointer(p_ancestor0)) and 1 or 0;
end
function abi.ffi.dyn_fn_instance_set_attribute(instance, p_attribute0, p_attribute1, p_value0)
	return getPointer(instance):SetAttribute(loadString(memory, p_attribute0, p_attribute1), getPointer(p_value0));
end
function abi.ffi.dyn_fn_instance_wait_for_child(output, instance, p_childName0, p_childName1, p_timeOut0)
	local value0 = getPointer(instance):WaitForChild(loadString(memory, p_childName0, p_childName1), p_timeOut0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.connect_instance_ancestry_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).AncestryChanged:Connect(function(p_child, p_parent)
		local value0 = p_child;
		local value1 = p_parent;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, value1 and 1 or 0, value1 and createPointer(value1) or 0);
	end))
end
function abi.ffi.connect_instance_attribute_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).AttributeChanged:Connect(function(p_attribute)
		local value0 = p_attribute;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.connect_instance_instance_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Changed:Connect(function(p_property)
		local value0 = p_property;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.connect_instance_child_added(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).ChildAdded:Connect(function(p_child)
		local value0 = p_child;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_instance_child_removed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).ChildRemoved:Connect(function(p_child)
		local value0 = p_child;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_instance_descendant_added(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).DescendantAdded:Connect(function(p_descendant)
		local value0 = p_descendant;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_instance_descendant_removing(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).DescendantRemoving:Connect(function(p_descendant)
		local value0 = p_descendant;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_instance_destroying(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Destroying:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.prop_get_accoutrement_attachment_forward(instance)
	return createPointer(getPointer(instance).AttachmentForward);
end
function abi.ffi.prop_set_accoutrement_attachment_forward(instance, p_AttachmentForward0)
	getPointer(instance).AttachmentForward = getPointer(p_AttachmentForward0);
end
function abi.ffi.prop_get_accoutrement_attachment_point(instance)
	return createPointer(getPointer(instance).AttachmentPoint);
end
function abi.ffi.prop_set_accoutrement_attachment_point(instance, p_AttachmentPoint0)
	getPointer(instance).AttachmentPoint = getPointer(p_AttachmentPoint0);
end
function abi.ffi.prop_get_accoutrement_attachment_pos(instance)
	return createPointer(getPointer(instance).AttachmentPos);
end
function abi.ffi.prop_set_accoutrement_attachment_pos(instance, p_AttachmentPos0)
	getPointer(instance).AttachmentPos = getPointer(p_AttachmentPos0);
end
function abi.ffi.prop_get_accoutrement_attachment_right(instance)
	return createPointer(getPointer(instance).AttachmentRight);
end
function abi.ffi.prop_set_accoutrement_attachment_right(instance, p_AttachmentRight0)
	getPointer(instance).AttachmentRight = getPointer(p_AttachmentRight0);
end
function abi.ffi.prop_get_accoutrement_attachment_up(instance)
	return createPointer(getPointer(instance).AttachmentUp);
end
function abi.ffi.prop_set_accoutrement_attachment_up(instance, p_AttachmentUp0)
	getPointer(instance).AttachmentUp = getPointer(p_AttachmentUp0);
end
function abi.ffi.prop_get_accessory_accessory_type(instance)
	return (getPointer(instance).AccessoryType).Value;
end
function abi.ffi.prop_set_accessory_accessory_type(instance, p_AccessoryType0)
	getPointer(instance).AccessoryType = p_AccessoryType0;
end
function abi.ffi.prop_get_ad_portal_portal_status(instance)
	return (getPointer(instance).PortalStatus).Value;
end
function abi.ffi.prop_get_ad_portal_portal_type(instance)
	return (getPointer(instance).PortalType).Value;
end
function abi.ffi.prop_set_ad_portal_portal_type(instance, p_PortalType0)
	getPointer(instance).PortalType = p_PortalType0;
end
function abi.ffi.dyn_fn_analytics_service_fire_custom_event(instance, p_player0, p_eventCategory0, p_eventCategory1, p_customData0)
	return getPointer(instance):FireCustomEvent(getPointer(p_player0), loadString(memory, p_eventCategory0, p_eventCategory1), getPointer(p_customData0));
end
function abi.ffi.dyn_fn_analytics_service_fire_in_game_economy_event(instance, p_player0, p_itemName0, p_itemName1, p_economyAction0, p_itemCategory0, p_itemCategory1, p_amount0, p_currency0, p_currency1, p_location0, p_customData0)
	return getPointer(instance):FireInGameEconomyEvent(getPointer(p_player0), loadString(memory, p_itemName0, p_itemName1), p_economyAction0, loadString(memory, p_itemCategory0, p_itemCategory1), p_amount0, loadString(memory, p_currency0, p_currency1), getPointer(p_location0), getPointer(p_customData0));
end
function abi.ffi.dyn_fn_analytics_service_fire_log_event(instance, p_player0, p_logLevel0, p_message0, p_message1, p_debugInfo0, p_customData0)
	return getPointer(instance):FireLogEvent(getPointer(p_player0), p_logLevel0, loadString(memory, p_message0, p_message1), getPointer(p_debugInfo0), getPointer(p_customData0));
end
function abi.ffi.dyn_fn_analytics_service_fire_player_progression_event(instance, p_player0, p_category0, p_category1, p_progressionStatus0, p_location0, p_statistics0, p_customData0)
	return getPointer(instance):FirePlayerProgressionEvent(getPointer(p_player0), loadString(memory, p_category0, p_category1), p_progressionStatus0, getPointer(p_location0), getPointer(p_statistics0), getPointer(p_customData0));
end
function abi.ffi.prop_get_animation_animation_id(instance)
	return createPointer(getPointer(instance).AnimationId);
end
function abi.ffi.prop_set_animation_animation_id(instance, p_AnimationId0)
	getPointer(instance).AnimationId = getPointer(p_AnimationId0);
end
function abi.ffi.prop_get_animation_clip_loop(instance)
	return getPointer(instance).Loop and 1 or 0;
end
function abi.ffi.prop_set_animation_clip_loop(instance, p_Loop0)
	getPointer(instance).Loop = p_Loop0 == 1;
end
function abi.ffi.prop_get_animation_clip_priority(instance)
	return (getPointer(instance).Priority).Value;
end
function abi.ffi.prop_set_animation_clip_priority(instance, p_Priority0)
	getPointer(instance).Priority = p_Priority0;
end
function abi.ffi.dyn_fn_keyframe_sequence_add_keyframe(instance, p_keyframe0)
	return getPointer(instance):AddKeyframe(getPointer(p_keyframe0));
end
function abi.ffi.dyn_fn_keyframe_sequence_get_keyframes(output, instance)
	local result0 = getPointer(instance):GetKeyframes();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_keyframe_sequence_remove_keyframe(instance, p_keyframe0)
	return getPointer(instance):RemoveKeyframe(getPointer(p_keyframe0));
end
function abi.ffi.dyn_fn_animation_clip_provider_register_active_animation_clip(instance, p_animationClip0)
	return createPointer(getPointer(instance):RegisterActiveAnimationClip(getPointer(p_animationClip0)));
end
function abi.ffi.dyn_fn_animation_clip_provider_register_animation_clip(instance, p_animationClip0)
	return createPointer(getPointer(instance):RegisterAnimationClip(getPointer(p_animationClip0)));
end
function abi.ffi.dyn_fn_animation_clip_provider_get_animation_clip_async(output, instance, p_assetId0)
	local value0 = getPointer(instance):GetAnimationClipAsync(getPointer(p_assetId0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_animation_clip_provider_get_animations(output, instance, p_userId0)
	local value0 = getPointer(instance):GetAnimations(p_userId0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_animation_stream_track_is_playing(instance)
	return getPointer(instance).IsPlaying and 1 or 0;
end
function abi.ffi.prop_get_animation_stream_track_priority(instance)
	return (getPointer(instance).Priority).Value;
end
function abi.ffi.prop_set_animation_stream_track_priority(instance, p_Priority0)
	getPointer(instance).Priority = p_Priority0;
end
function abi.ffi.prop_get_animation_stream_track_weight_current(instance)
	return getPointer(instance).WeightCurrent;
end
function abi.ffi.prop_get_animation_stream_track_weight_target(instance)
	return getPointer(instance).WeightTarget;
end
function abi.ffi.prop_get_animation_track_animation(output, instance)
	local value0 = getPointer(instance).Animation;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_animation_track_is_playing(instance)
	return getPointer(instance).IsPlaying and 1 or 0;
end
function abi.ffi.prop_get_animation_track_length(instance)
	return getPointer(instance).Length;
end
function abi.ffi.prop_get_animation_track_looped(instance)
	return getPointer(instance).Looped and 1 or 0;
end
function abi.ffi.prop_set_animation_track_looped(instance, p_Looped0)
	getPointer(instance).Looped = p_Looped0 == 1;
end
function abi.ffi.prop_get_animation_track_priority(instance)
	return (getPointer(instance).Priority).Value;
end
function abi.ffi.prop_set_animation_track_priority(instance, p_Priority0)
	getPointer(instance).Priority = p_Priority0;
end
function abi.ffi.prop_get_animation_track_speed(instance)
	return getPointer(instance).Speed;
end
function abi.ffi.prop_get_animation_track_time_position(instance)
	return getPointer(instance).TimePosition;
end
function abi.ffi.prop_set_animation_track_time_position(instance, p_TimePosition0)
	getPointer(instance).TimePosition = p_TimePosition0;
end
function abi.ffi.prop_get_animation_track_weight_current(instance)
	return getPointer(instance).WeightCurrent;
end
function abi.ffi.prop_get_animation_track_weight_target(instance)
	return getPointer(instance).WeightTarget;
end
function abi.ffi.dyn_fn_animation_track_adjust_speed(instance, p_speed0)
	return getPointer(instance):AdjustSpeed(p_speed0);
end
function abi.ffi.dyn_fn_animation_track_adjust_weight(instance, p_weight0, p_fadeTime0)
	return getPointer(instance):AdjustWeight(p_weight0, p_fadeTime0);
end
function abi.ffi.dyn_fn_animation_track_get_time_of_keyframe(instance, p_keyframeName0, p_keyframeName1)
	return getPointer(instance):GetTimeOfKeyframe(loadString(memory, p_keyframeName0, p_keyframeName1));
end
function abi.ffi.dyn_fn_animation_track_play(instance, p_fadeTime0, p_weight0, p_speed0)
	return getPointer(instance):Play(p_fadeTime0, p_weight0, p_speed0);
end
function abi.ffi.dyn_fn_animation_track_stop(instance, p_fadeTime0)
	return getPointer(instance):Stop(p_fadeTime0);
end
function abi.ffi.connect_animation_track_did_loop(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).DidLoop:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_animation_track_keyframe_reached(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).KeyframeReached:Connect(function(p_keyframeName)
		local value0 = p_keyframeName;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.connect_animation_track_stopped(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Stopped:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.prop_get_animator_prefer_lod_enabled(instance)
	return getPointer(instance).PreferLodEnabled and 1 or 0;
end
function abi.ffi.prop_set_animator_prefer_lod_enabled(instance, p_PreferLodEnabled0)
	getPointer(instance).PreferLodEnabled = p_PreferLodEnabled0 == 1;
end
function abi.ffi.dyn_fn_animator_apply_joint_velocities(instance, p_motors0)
	return getPointer(instance):ApplyJointVelocities(getPointer(p_motors0));
end
function abi.ffi.dyn_fn_animator_load_animation(output, instance, p_animation0)
	local value0 = getPointer(instance):LoadAnimation(getPointer(p_animation0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.connect_animator_animation_played(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).AnimationPlayed:Connect(function(p_animationTrack)
		local value0 = p_animationTrack;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_asset_import_session_upload_complete(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).UploadComplete:Connect(function(p_succeeded, p_errorMap)
		invokeFunction(data, vtable, p_succeeded and 1 or 0, createPointer(p_errorMap));
	end))
end
function abi.ffi.connect_asset_import_session_upload_progress(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).UploadProgress:Connect(function(p_progressRatio)
		invokeFunction(data, vtable, p_progressRatio);
	end))
end
function abi.ffi.prop_get_asset_patch_settings_content_id(output, instance)
	local value0 = getPointer(instance).ContentId;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_asset_patch_settings_content_id(instance, p_ContentId0, p_ContentId1)
	getPointer(instance).ContentId = loadString(memory, p_ContentId0, p_ContentId1);
end
function abi.ffi.prop_get_asset_patch_settings_output_path(output, instance)
	local value0 = getPointer(instance).OutputPath;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_asset_patch_settings_output_path(instance, p_OutputPath0, p_OutputPath1)
	getPointer(instance).OutputPath = loadString(memory, p_OutputPath0, p_OutputPath1);
end
function abi.ffi.prop_get_asset_patch_settings_patch_id(output, instance)
	local value0 = getPointer(instance).PatchId;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_asset_patch_settings_patch_id(instance, p_PatchId0, p_PatchId1)
	getPointer(instance).PatchId = loadString(memory, p_PatchId0, p_PatchId1);
end
function abi.ffi.dyn_fn_asset_service_create_place_async(instance, p_placeName0, p_placeName1, p_templatePlaceID0, p_description0, p_description1)
	return getPointer(instance):CreatePlaceAsync(loadString(memory, p_placeName0, p_placeName1), p_templatePlaceID0, loadString(memory, p_description0, p_description1));
end
function abi.ffi.dyn_fn_asset_service_create_place_in_player_inventory_async(instance, p_player0, p_placeName0, p_placeName1, p_templatePlaceID0, p_description0, p_description1)
	return getPointer(instance):CreatePlaceInPlayerInventoryAsync(getPointer(p_player0), loadString(memory, p_placeName0, p_placeName1), p_templatePlaceID0, loadString(memory, p_description0, p_description1));
end
function abi.ffi.dyn_fn_asset_service_get_bundle_details_async(instance, p_bundleId0)
	return createPointer(getPointer(instance):GetBundleDetailsAsync(p_bundleId0));
end
function abi.ffi.dyn_fn_asset_service_get_game_places_async(output, instance)
	local value0 = getPointer(instance):GetGamePlacesAsync();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_asset_service_save_place_async(instance)
	return getPointer(instance):SavePlaceAsync();
end
function abi.ffi.prop_get_atmosphere_color(instance)
	return createPointer(getPointer(instance).Color);
end
function abi.ffi.prop_set_atmosphere_color(instance, p_Color0)
	getPointer(instance).Color = getPointer(p_Color0);
end
function abi.ffi.prop_get_atmosphere_decay(instance)
	return createPointer(getPointer(instance).Decay);
end
function abi.ffi.prop_set_atmosphere_decay(instance, p_Decay0)
	getPointer(instance).Decay = getPointer(p_Decay0);
end
function abi.ffi.prop_get_atmosphere_density(instance)
	return getPointer(instance).Density;
end
function abi.ffi.prop_set_atmosphere_density(instance, p_Density0)
	getPointer(instance).Density = p_Density0;
end
function abi.ffi.prop_get_atmosphere_glare(instance)
	return getPointer(instance).Glare;
end
function abi.ffi.prop_set_atmosphere_glare(instance, p_Glare0)
	getPointer(instance).Glare = p_Glare0;
end
function abi.ffi.prop_get_atmosphere_haze(instance)
	return getPointer(instance).Haze;
end
function abi.ffi.prop_set_atmosphere_haze(instance, p_Haze0)
	getPointer(instance).Haze = p_Haze0;
end
function abi.ffi.prop_get_atmosphere_offset(instance)
	return getPointer(instance).Offset;
end
function abi.ffi.prop_set_atmosphere_offset(instance, p_Offset0)
	getPointer(instance).Offset = p_Offset0;
end
function abi.ffi.prop_get_attachment_axis(instance)
	return createPointer(getPointer(instance).Axis);
end
function abi.ffi.prop_set_attachment_axis(instance, p_Axis0)
	getPointer(instance).Axis = getPointer(p_Axis0);
end
function abi.ffi.prop_get_attachment_c_frame(instance)
	return createPointer(getPointer(instance).CFrame);
end
function abi.ffi.prop_set_attachment_c_frame(instance, p_CFrame0)
	getPointer(instance).CFrame = getPointer(p_CFrame0);
end
function abi.ffi.prop_get_attachment_orientation(instance)
	return createPointer(getPointer(instance).Orientation);
end
function abi.ffi.prop_set_attachment_orientation(instance, p_Orientation0)
	getPointer(instance).Orientation = getPointer(p_Orientation0);
end
function abi.ffi.prop_get_attachment_position(instance)
	return createPointer(getPointer(instance).Position);
end
function abi.ffi.prop_set_attachment_position(instance, p_Position0)
	getPointer(instance).Position = getPointer(p_Position0);
end
function abi.ffi.prop_get_attachment_secondary_axis(instance)
	return createPointer(getPointer(instance).SecondaryAxis);
end
function abi.ffi.prop_set_attachment_secondary_axis(instance, p_SecondaryAxis0)
	getPointer(instance).SecondaryAxis = getPointer(p_SecondaryAxis0);
end
function abi.ffi.prop_get_attachment_visible(instance)
	return getPointer(instance).Visible and 1 or 0;
end
function abi.ffi.prop_set_attachment_visible(instance, p_Visible0)
	getPointer(instance).Visible = p_Visible0 == 1;
end
function abi.ffi.prop_get_attachment_world_axis(instance)
	return createPointer(getPointer(instance).WorldAxis);
end
function abi.ffi.prop_set_attachment_world_axis(instance, p_WorldAxis0)
	getPointer(instance).WorldAxis = getPointer(p_WorldAxis0);
end
function abi.ffi.prop_get_attachment_world_c_frame(instance)
	return createPointer(getPointer(instance).WorldCFrame);
end
function abi.ffi.prop_set_attachment_world_c_frame(instance, p_WorldCFrame0)
	getPointer(instance).WorldCFrame = getPointer(p_WorldCFrame0);
end
function abi.ffi.prop_get_attachment_world_orientation(instance)
	return createPointer(getPointer(instance).WorldOrientation);
end
function abi.ffi.prop_set_attachment_world_orientation(instance, p_WorldOrientation0)
	getPointer(instance).WorldOrientation = getPointer(p_WorldOrientation0);
end
function abi.ffi.prop_get_attachment_world_position(instance)
	return createPointer(getPointer(instance).WorldPosition);
end
function abi.ffi.prop_set_attachment_world_position(instance, p_WorldPosition0)
	getPointer(instance).WorldPosition = getPointer(p_WorldPosition0);
end
function abi.ffi.prop_get_attachment_world_secondary_axis(instance)
	return createPointer(getPointer(instance).WorldSecondaryAxis);
end
function abi.ffi.prop_set_attachment_world_secondary_axis(instance, p_WorldSecondaryAxis0)
	getPointer(instance).WorldSecondaryAxis = getPointer(p_WorldSecondaryAxis0);
end
function abi.ffi.prop_get_bone_transform(instance)
	return createPointer(getPointer(instance).Transform);
end
function abi.ffi.prop_set_bone_transform(instance, p_Transform0)
	getPointer(instance).Transform = getPointer(p_Transform0);
end
function abi.ffi.prop_get_bone_transformed_c_frame(instance)
	return createPointer(getPointer(instance).TransformedCFrame);
end
function abi.ffi.prop_get_bone_transformed_world_c_frame(instance)
	return createPointer(getPointer(instance).TransformedWorldCFrame);
end
function abi.ffi.dyn_fn_avatar_editor_service_get_accessory_type(instance, p_avatarAssetType0)
	return (getPointer(instance):GetAccessoryType(p_avatarAssetType0)).Value;
end
function abi.ffi.dyn_fn_avatar_editor_service_prompt_allow_inventory_read_access(instance)
	return getPointer(instance):PromptAllowInventoryReadAccess();
end
function abi.ffi.dyn_fn_avatar_editor_service_prompt_create_outfit(instance, p_outfit0, p_rigType0)
	return getPointer(instance):PromptCreateOutfit(getPointer(p_outfit0), p_rigType0);
end
function abi.ffi.dyn_fn_avatar_editor_service_prompt_delete_outfit(instance, p_outfitId0)
	return getPointer(instance):PromptDeleteOutfit(p_outfitId0);
end
function abi.ffi.dyn_fn_avatar_editor_service_prompt_rename_outfit(instance, p_outfitId0)
	return getPointer(instance):PromptRenameOutfit(p_outfitId0);
end
function abi.ffi.dyn_fn_avatar_editor_service_prompt_save_avatar(instance, p_humanoidDescription0, p_rigType0)
	return getPointer(instance):PromptSaveAvatar(getPointer(p_humanoidDescription0), p_rigType0);
end
function abi.ffi.dyn_fn_avatar_editor_service_prompt_set_favorite(instance, p_itemId0, p_itemType0, p_shouldFavorite0)
	return getPointer(instance):PromptSetFavorite(p_itemId0, p_itemType0, p_shouldFavorite0 == 1);
end
function abi.ffi.dyn_fn_avatar_editor_service_prompt_update_outfit(instance, p_outfitId0, p_updatedOutfit0, p_rigType0)
	return getPointer(instance):PromptUpdateOutfit(p_outfitId0, getPointer(p_updatedOutfit0), p_rigType0);
end
function abi.ffi.dyn_fn_avatar_editor_service_check_apply_default_clothing(output, instance, p_humanoidDescription0)
	local value0 = getPointer(instance):CheckApplyDefaultClothing(getPointer(p_humanoidDescription0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_avatar_editor_service_conform_to_avatar_rules(output, instance, p_humanoidDescription0)
	local value0 = getPointer(instance):ConformToAvatarRules(getPointer(p_humanoidDescription0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_avatar_editor_service_get_avatar_rules(instance)
	return createPointer(getPointer(instance):GetAvatarRules());
end
function abi.ffi.dyn_fn_avatar_editor_service_get_favorite(instance, p_itemId0, p_itemType0)
	return getPointer(instance):GetFavorite(p_itemId0, p_itemType0) and 1 or 0;
end
function abi.ffi.dyn_fn_avatar_editor_service_get_item_details(instance, p_itemId0, p_itemType0)
	return createPointer(getPointer(instance):GetItemDetails(p_itemId0, p_itemType0));
end
function abi.ffi.dyn_fn_avatar_editor_service_get_outfits(output, instance, p_outfitSource0, p_outfitType0)
	local value0 = getPointer(instance):GetOutfits(p_outfitSource0, p_outfitType0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_avatar_editor_service_search_catalog(output, instance, p_searchParameters0)
	local value0 = getPointer(instance):SearchCatalog(getPointer(p_searchParameters0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.connect_avatar_editor_service_prompt_allow_inventory_read_access_completed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptAllowInventoryReadAccessCompleted:Connect(function(p_result)
		invokeFunction(data, vtable, (p_result).Value);
	end))
end
function abi.ffi.connect_avatar_editor_service_prompt_create_outfit_completed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptCreateOutfitCompleted:Connect(function(p_result, p_failureType)
		invokeFunction(data, vtable, (p_result).Value, createPointer(p_failureType));
	end))
end
function abi.ffi.connect_avatar_editor_service_prompt_delete_outfit_completed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptDeleteOutfitCompleted:Connect(function(p_result)
		invokeFunction(data, vtable, (p_result).Value);
	end))
end
function abi.ffi.connect_avatar_editor_service_prompt_rename_outfit_completed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptRenameOutfitCompleted:Connect(function(p_result)
		invokeFunction(data, vtable, (p_result).Value);
	end))
end
function abi.ffi.connect_avatar_editor_service_prompt_save_avatar_completed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptSaveAvatarCompleted:Connect(function(p_result, p_humanoidDescription)
		local value0 = p_humanoidDescription;
		invokeFunction(data, vtable, (p_result).Value, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_avatar_editor_service_prompt_set_favorite_completed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptSetFavoriteCompleted:Connect(function(p_result)
		invokeFunction(data, vtable, (p_result).Value);
	end))
end
function abi.ffi.connect_avatar_editor_service_prompt_update_outfit_completed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptUpdateOutfitCompleted:Connect(function(p_result)
		invokeFunction(data, vtable, (p_result).Value);
	end))
end
function abi.ffi.prop_get_backpack_item_texture_id(instance)
	return createPointer(getPointer(instance).TextureId);
end
function abi.ffi.prop_set_backpack_item_texture_id(instance, p_TextureId0)
	getPointer(instance).TextureId = getPointer(p_TextureId0);
end
function abi.ffi.prop_get_tool_can_be_dropped(instance)
	return getPointer(instance).CanBeDropped and 1 or 0;
end
function abi.ffi.prop_set_tool_can_be_dropped(instance, p_CanBeDropped0)
	getPointer(instance).CanBeDropped = p_CanBeDropped0 == 1;
end
function abi.ffi.prop_get_tool_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_tool_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_tool_grip(instance)
	return createPointer(getPointer(instance).Grip);
end
function abi.ffi.prop_set_tool_grip(instance, p_Grip0)
	getPointer(instance).Grip = getPointer(p_Grip0);
end
function abi.ffi.prop_get_tool_grip_forward(instance)
	return createPointer(getPointer(instance).GripForward);
end
function abi.ffi.prop_set_tool_grip_forward(instance, p_GripForward0)
	getPointer(instance).GripForward = getPointer(p_GripForward0);
end
function abi.ffi.prop_get_tool_grip_pos(instance)
	return createPointer(getPointer(instance).GripPos);
end
function abi.ffi.prop_set_tool_grip_pos(instance, p_GripPos0)
	getPointer(instance).GripPos = getPointer(p_GripPos0);
end
function abi.ffi.prop_get_tool_grip_right(instance)
	return createPointer(getPointer(instance).GripRight);
end
function abi.ffi.prop_set_tool_grip_right(instance, p_GripRight0)
	getPointer(instance).GripRight = getPointer(p_GripRight0);
end
function abi.ffi.prop_get_tool_grip_up(instance)
	return createPointer(getPointer(instance).GripUp);
end
function abi.ffi.prop_set_tool_grip_up(instance, p_GripUp0)
	getPointer(instance).GripUp = getPointer(p_GripUp0);
end
function abi.ffi.prop_get_tool_manual_activation_only(instance)
	return getPointer(instance).ManualActivationOnly and 1 or 0;
end
function abi.ffi.prop_set_tool_manual_activation_only(instance, p_ManualActivationOnly0)
	getPointer(instance).ManualActivationOnly = p_ManualActivationOnly0 == 1;
end
function abi.ffi.prop_get_tool_requires_handle(instance)
	return getPointer(instance).RequiresHandle and 1 or 0;
end
function abi.ffi.prop_set_tool_requires_handle(instance, p_RequiresHandle0)
	getPointer(instance).RequiresHandle = p_RequiresHandle0 == 1;
end
function abi.ffi.prop_get_tool_tool_tip(output, instance)
	local value0 = getPointer(instance).ToolTip;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_tool_tool_tip(instance, p_ToolTip0, p_ToolTip1)
	getPointer(instance).ToolTip = loadString(memory, p_ToolTip0, p_ToolTip1);
end
function abi.ffi.dyn_fn_tool_activate(instance)
	return getPointer(instance):Activate();
end
function abi.ffi.dyn_fn_tool_deactivate(instance)
	return getPointer(instance):Deactivate();
end
function abi.ffi.connect_tool_activated(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Activated:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_tool_deactivated(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Deactivated:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_tool_equipped(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Equipped:Connect(function(p_mouse)
		local value0 = p_mouse;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_tool_unequipped(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Unequipped:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.dyn_fn_badge_service_award_badge(instance, p_userId0, p_badgeId0)
	return getPointer(instance):AwardBadge(p_userId0, p_badgeId0) and 1 or 0;
end
function abi.ffi.dyn_fn_badge_service_get_badge_info_async(instance, p_badgeId0)
	return createPointer(getPointer(instance):GetBadgeInfoAsync(p_badgeId0));
end
function abi.ffi.dyn_fn_badge_service_user_has_badge_async(instance, p_userId0, p_badgeId0)
	return getPointer(instance):UserHasBadgeAsync(p_userId0, p_badgeId0) and 1 or 0;
end
function abi.ffi.dyn_fn_base_player_gui_get_gui_objects_at_position(output, instance, p_x0, p_y0)
	local result0 = getPointer(instance):GetGuiObjectsAtPosition(p_x0, p_y0);
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.prop_get_player_gui_current_screen_orientation(instance)
	return (getPointer(instance).CurrentScreenOrientation).Value;
end
function abi.ffi.prop_get_player_gui_screen_orientation(instance)
	return (getPointer(instance).ScreenOrientation).Value;
end
function abi.ffi.prop_set_player_gui_screen_orientation(instance, p_ScreenOrientation0)
	getPointer(instance).ScreenOrientation = p_ScreenOrientation0;
end
function abi.ffi.prop_get_player_gui_selection_image_object(output, instance)
	local value0 = getPointer(instance).SelectionImageObject;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_player_gui_selection_image_object(instance, p_SelectionImageObject0, p_SelectionImageObject1)
	local value0;
	if p_SelectionImageObject0 == 1 then
		value0 = getPointer(p_SelectionImageObject1);
	end
	getPointer(instance).SelectionImageObject = value0;
end
function abi.ffi.prop_get_starter_gui_screen_orientation(instance)
	return (getPointer(instance).ScreenOrientation).Value;
end
function abi.ffi.prop_set_starter_gui_screen_orientation(instance, p_ScreenOrientation0)
	getPointer(instance).ScreenOrientation = p_ScreenOrientation0;
end
function abi.ffi.prop_get_starter_gui_show_development_gui(instance)
	return getPointer(instance).ShowDevelopmentGui and 1 or 0;
end
function abi.ffi.prop_set_starter_gui_show_development_gui(instance, p_ShowDevelopmentGui0)
	getPointer(instance).ShowDevelopmentGui = p_ShowDevelopmentGui0 == 1;
end
function abi.ffi.dyn_fn_starter_gui_get_core_gui_enabled(instance, p_coreGuiType0)
	return getPointer(instance):GetCoreGuiEnabled(p_coreGuiType0) and 1 or 0;
end
function abi.ffi.dyn_fn_starter_gui_set_core(instance, p_parameterName0, p_parameterName1, p_value0)
	return getPointer(instance):SetCore(loadString(memory, p_parameterName0, p_parameterName1), getPointer(p_value0));
end
function abi.ffi.dyn_fn_starter_gui_set_core_gui_enabled(instance, p_coreGuiType0, p_enabled0)
	return getPointer(instance):SetCoreGuiEnabled(p_coreGuiType0, p_enabled0 == 1);
end
function abi.ffi.dyn_fn_starter_gui_get_core(instance, p_parameterName0, p_parameterName1)
	return createPointer(getPointer(instance):GetCore(loadString(memory, p_parameterName0, p_parameterName1)));
end
function abi.ffi.prop_get_base_wrap_cage_mesh_id(instance)
	return createPointer(getPointer(instance).CageMeshId);
end
function abi.ffi.prop_set_base_wrap_cage_mesh_id(instance, p_CageMeshId0)
	getPointer(instance).CageMeshId = getPointer(p_CageMeshId0);
end
function abi.ffi.prop_get_base_wrap_cage_origin(instance)
	return createPointer(getPointer(instance).CageOrigin);
end
function abi.ffi.prop_set_base_wrap_cage_origin(instance, p_CageOrigin0)
	getPointer(instance).CageOrigin = getPointer(p_CageOrigin0);
end
function abi.ffi.prop_get_base_wrap_cage_origin_world(instance)
	return createPointer(getPointer(instance).CageOriginWorld);
end
function abi.ffi.prop_get_base_wrap_import_origin(instance)
	return createPointer(getPointer(instance).ImportOrigin);
end
function abi.ffi.prop_set_base_wrap_import_origin(instance, p_ImportOrigin0)
	getPointer(instance).ImportOrigin = getPointer(p_ImportOrigin0);
end
function abi.ffi.prop_get_base_wrap_import_origin_world(instance)
	return createPointer(getPointer(instance).ImportOriginWorld);
end
function abi.ffi.prop_get_wrap_layer_auto_skin(instance)
	return (getPointer(instance).AutoSkin).Value;
end
function abi.ffi.prop_set_wrap_layer_auto_skin(instance, p_AutoSkin0)
	getPointer(instance).AutoSkin = p_AutoSkin0;
end
function abi.ffi.prop_get_wrap_layer_bind_offset(instance)
	return createPointer(getPointer(instance).BindOffset);
end
function abi.ffi.prop_set_wrap_layer_bind_offset(instance, p_BindOffset0)
	getPointer(instance).BindOffset = getPointer(p_BindOffset0);
end
function abi.ffi.prop_get_wrap_layer_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_wrap_layer_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_wrap_layer_order(instance)
	return getPointer(instance).Order;
end
function abi.ffi.prop_set_wrap_layer_order(instance, p_Order0)
	getPointer(instance).Order = p_Order0;
end
function abi.ffi.prop_get_wrap_layer_puffiness(instance)
	return getPointer(instance).Puffiness;
end
function abi.ffi.prop_set_wrap_layer_puffiness(instance, p_Puffiness0)
	getPointer(instance).Puffiness = p_Puffiness0;
end
function abi.ffi.prop_get_wrap_layer_reference_mesh_id(instance)
	return createPointer(getPointer(instance).ReferenceMeshId);
end
function abi.ffi.prop_set_wrap_layer_reference_mesh_id(instance, p_ReferenceMeshId0)
	getPointer(instance).ReferenceMeshId = getPointer(p_ReferenceMeshId0);
end
function abi.ffi.prop_get_wrap_layer_reference_origin(instance)
	return createPointer(getPointer(instance).ReferenceOrigin);
end
function abi.ffi.prop_set_wrap_layer_reference_origin(instance, p_ReferenceOrigin0)
	getPointer(instance).ReferenceOrigin = getPointer(p_ReferenceOrigin0);
end
function abi.ffi.prop_get_wrap_layer_reference_origin_world(instance)
	return createPointer(getPointer(instance).ReferenceOriginWorld);
end
function abi.ffi.prop_get_wrap_layer_shrink_factor(instance)
	return getPointer(instance).ShrinkFactor;
end
function abi.ffi.prop_set_wrap_layer_shrink_factor(instance, p_ShrinkFactor0)
	getPointer(instance).ShrinkFactor = p_ShrinkFactor0;
end
function abi.ffi.prop_get_wrap_target_stiffness(instance)
	return getPointer(instance).Stiffness;
end
function abi.ffi.prop_set_wrap_target_stiffness(instance, p_Stiffness0)
	getPointer(instance).Stiffness = p_Stiffness0;
end
function abi.ffi.prop_get_beam_attachment_0(output, instance)
	local value0 = getPointer(instance).Attachment0;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_beam_attachment_0(instance, p_Attachment00, p_Attachment01)
	local value0;
	if p_Attachment00 == 1 then
		value0 = getPointer(p_Attachment01);
	end
	getPointer(instance).Attachment0 = value0;
end
function abi.ffi.prop_get_beam_attachment_1(output, instance)
	local value0 = getPointer(instance).Attachment1;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_beam_attachment_1(instance, p_Attachment10, p_Attachment11)
	local value0;
	if p_Attachment10 == 1 then
		value0 = getPointer(p_Attachment11);
	end
	getPointer(instance).Attachment1 = value0;
end
function abi.ffi.prop_get_beam_brightness(instance)
	return getPointer(instance).Brightness;
end
function abi.ffi.prop_set_beam_brightness(instance, p_Brightness0)
	getPointer(instance).Brightness = p_Brightness0;
end
function abi.ffi.prop_get_beam_color(instance)
	return createPointer(getPointer(instance).Color);
end
function abi.ffi.prop_set_beam_color(instance, p_Color0)
	getPointer(instance).Color = getPointer(p_Color0);
end
function abi.ffi.prop_get_beam_curve_size_0(instance)
	return getPointer(instance).CurveSize0;
end
function abi.ffi.prop_set_beam_curve_size_0(instance, p_CurveSize00)
	getPointer(instance).CurveSize0 = p_CurveSize00;
end
function abi.ffi.prop_get_beam_curve_size_1(instance)
	return getPointer(instance).CurveSize1;
end
function abi.ffi.prop_set_beam_curve_size_1(instance, p_CurveSize10)
	getPointer(instance).CurveSize1 = p_CurveSize10;
end
function abi.ffi.prop_get_beam_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_beam_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_beam_face_camera(instance)
	return getPointer(instance).FaceCamera and 1 or 0;
end
function abi.ffi.prop_set_beam_face_camera(instance, p_FaceCamera0)
	getPointer(instance).FaceCamera = p_FaceCamera0 == 1;
end
function abi.ffi.prop_get_beam_light_emission(instance)
	return getPointer(instance).LightEmission;
end
function abi.ffi.prop_set_beam_light_emission(instance, p_LightEmission0)
	getPointer(instance).LightEmission = p_LightEmission0;
end
function abi.ffi.prop_get_beam_light_influence(instance)
	return getPointer(instance).LightInfluence;
end
function abi.ffi.prop_set_beam_light_influence(instance, p_LightInfluence0)
	getPointer(instance).LightInfluence = p_LightInfluence0;
end
function abi.ffi.prop_get_beam_segments(instance)
	return getPointer(instance).Segments;
end
function abi.ffi.prop_set_beam_segments(instance, p_Segments0)
	getPointer(instance).Segments = p_Segments0;
end
function abi.ffi.prop_get_beam_texture(instance)
	return createPointer(getPointer(instance).Texture);
end
function abi.ffi.prop_set_beam_texture(instance, p_Texture0)
	getPointer(instance).Texture = getPointer(p_Texture0);
end
function abi.ffi.prop_get_beam_texture_length(instance)
	return getPointer(instance).TextureLength;
end
function abi.ffi.prop_set_beam_texture_length(instance, p_TextureLength0)
	getPointer(instance).TextureLength = p_TextureLength0;
end
function abi.ffi.prop_get_beam_texture_mode(instance)
	return (getPointer(instance).TextureMode).Value;
end
function abi.ffi.prop_set_beam_texture_mode(instance, p_TextureMode0)
	getPointer(instance).TextureMode = p_TextureMode0;
end
function abi.ffi.prop_get_beam_texture_speed(instance)
	return getPointer(instance).TextureSpeed;
end
function abi.ffi.prop_set_beam_texture_speed(instance, p_TextureSpeed0)
	getPointer(instance).TextureSpeed = p_TextureSpeed0;
end
function abi.ffi.prop_get_beam_transparency(instance)
	return createPointer(getPointer(instance).Transparency);
end
function abi.ffi.prop_set_beam_transparency(instance, p_Transparency0)
	getPointer(instance).Transparency = getPointer(p_Transparency0);
end
function abi.ffi.prop_get_beam_width_0(instance)
	return getPointer(instance).Width0;
end
function abi.ffi.prop_set_beam_width_0(instance, p_Width00)
	getPointer(instance).Width0 = p_Width00;
end
function abi.ffi.prop_get_beam_width_1(instance)
	return getPointer(instance).Width1;
end
function abi.ffi.prop_set_beam_width_1(instance, p_Width10)
	getPointer(instance).Width1 = p_Width10;
end
function abi.ffi.prop_get_beam_z_offset(instance)
	return getPointer(instance).ZOffset;
end
function abi.ffi.prop_set_beam_z_offset(instance, p_ZOffset0)
	getPointer(instance).ZOffset = p_ZOffset0;
end
function abi.ffi.dyn_fn_beam_set_texture_offset(instance, p_offset0)
	return getPointer(instance):SetTextureOffset(p_offset0);
end
function abi.ffi.connect_bindable_event_event(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Event:Connect(function(...)
		local length0 = select('#', ...);
		local vec0 = allocVec(length0 * 1);
		for i = 1, length0 do
			storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(select(i, ...)))
		end
		invokeFunction(data, vtable, vec0, length0);
	end))
end
function abi.ffi.dyn_fn_bindable_function_invoke(output, instance, p_arguments0, p_arguments1)
	local result0 = table.create(p_arguments1)
	for i = 1, p_arguments1 do
		local value0_0 = loadU32(memory, p_arguments0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	local value0 = { getPointer(instance):Invoke(unpack(result0, 1, p_arguments1)) };
	local length0 = #value0;
	local vec0 = allocVec(length0 * 1);
	for i = 1, length0 do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(value0[i]))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, length0)
end
function abi.ffi.prop_get_body_angular_velocity_angular_velocity(instance)
	return createPointer(getPointer(instance).AngularVelocity);
end
function abi.ffi.prop_set_body_angular_velocity_angular_velocity(instance, p_AngularVelocity0)
	getPointer(instance).AngularVelocity = getPointer(p_AngularVelocity0);
end
function abi.ffi.prop_get_body_angular_velocity_max_torque(instance)
	return createPointer(getPointer(instance).MaxTorque);
end
function abi.ffi.prop_set_body_angular_velocity_max_torque(instance, p_MaxTorque0)
	getPointer(instance).MaxTorque = getPointer(p_MaxTorque0);
end
function abi.ffi.prop_get_body_angular_velocity_p(instance)
	return getPointer(instance).P;
end
function abi.ffi.prop_set_body_angular_velocity_p(instance, p_P0)
	getPointer(instance).P = p_P0;
end
function abi.ffi.prop_get_body_force_force(instance)
	return createPointer(getPointer(instance).Force);
end
function abi.ffi.prop_set_body_force_force(instance, p_Force0)
	getPointer(instance).Force = getPointer(p_Force0);
end
function abi.ffi.prop_get_body_gyro_c_frame(instance)
	return createPointer(getPointer(instance).CFrame);
end
function abi.ffi.prop_set_body_gyro_c_frame(instance, p_CFrame0)
	getPointer(instance).CFrame = getPointer(p_CFrame0);
end
function abi.ffi.prop_get_body_gyro_d(instance)
	return getPointer(instance).D;
end
function abi.ffi.prop_set_body_gyro_d(instance, p_D0)
	getPointer(instance).D = p_D0;
end
function abi.ffi.prop_get_body_gyro_max_torque(instance)
	return createPointer(getPointer(instance).MaxTorque);
end
function abi.ffi.prop_set_body_gyro_max_torque(instance, p_MaxTorque0)
	getPointer(instance).MaxTorque = getPointer(p_MaxTorque0);
end
function abi.ffi.prop_get_body_gyro_p(instance)
	return getPointer(instance).P;
end
function abi.ffi.prop_set_body_gyro_p(instance, p_P0)
	getPointer(instance).P = p_P0;
end
function abi.ffi.prop_get_body_position_d(instance)
	return getPointer(instance).D;
end
function abi.ffi.prop_set_body_position_d(instance, p_D0)
	getPointer(instance).D = p_D0;
end
function abi.ffi.prop_get_body_position_max_force(instance)
	return createPointer(getPointer(instance).MaxForce);
end
function abi.ffi.prop_set_body_position_max_force(instance, p_MaxForce0)
	getPointer(instance).MaxForce = getPointer(p_MaxForce0);
end
function abi.ffi.prop_get_body_position_p(instance)
	return getPointer(instance).P;
end
function abi.ffi.prop_set_body_position_p(instance, p_P0)
	getPointer(instance).P = p_P0;
end
function abi.ffi.prop_get_body_position_position(instance)
	return createPointer(getPointer(instance).Position);
end
function abi.ffi.prop_set_body_position_position(instance, p_Position0)
	getPointer(instance).Position = getPointer(p_Position0);
end
function abi.ffi.dyn_fn_body_position_get_last_force(instance)
	return createPointer(getPointer(instance):GetLastForce());
end
function abi.ffi.connect_body_position_reached_target(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).ReachedTarget:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.prop_get_body_thrust_force(instance)
	return createPointer(getPointer(instance).Force);
end
function abi.ffi.prop_set_body_thrust_force(instance, p_Force0)
	getPointer(instance).Force = getPointer(p_Force0);
end
function abi.ffi.prop_get_body_thrust_location(instance)
	return createPointer(getPointer(instance).Location);
end
function abi.ffi.prop_set_body_thrust_location(instance, p_Location0)
	getPointer(instance).Location = getPointer(p_Location0);
end
function abi.ffi.prop_get_body_velocity_max_force(instance)
	return createPointer(getPointer(instance).MaxForce);
end
function abi.ffi.prop_set_body_velocity_max_force(instance, p_MaxForce0)
	getPointer(instance).MaxForce = getPointer(p_MaxForce0);
end
function abi.ffi.prop_get_body_velocity_p(instance)
	return getPointer(instance).P;
end
function abi.ffi.prop_set_body_velocity_p(instance, p_P0)
	getPointer(instance).P = p_P0;
end
function abi.ffi.prop_get_body_velocity_velocity(instance)
	return createPointer(getPointer(instance).Velocity);
end
function abi.ffi.prop_set_body_velocity_velocity(instance, p_Velocity0)
	getPointer(instance).Velocity = getPointer(p_Velocity0);
end
function abi.ffi.dyn_fn_body_velocity_get_last_force(instance)
	return createPointer(getPointer(instance):GetLastForce());
end
function abi.ffi.prop_get_rocket_propulsion_cartoon_factor(instance)
	return getPointer(instance).CartoonFactor;
end
function abi.ffi.prop_set_rocket_propulsion_cartoon_factor(instance, p_CartoonFactor0)
	getPointer(instance).CartoonFactor = p_CartoonFactor0;
end
function abi.ffi.prop_get_rocket_propulsion_max_speed(instance)
	return getPointer(instance).MaxSpeed;
end
function abi.ffi.prop_set_rocket_propulsion_max_speed(instance, p_MaxSpeed0)
	getPointer(instance).MaxSpeed = p_MaxSpeed0;
end
function abi.ffi.prop_get_rocket_propulsion_max_thrust(instance)
	return getPointer(instance).MaxThrust;
end
function abi.ffi.prop_set_rocket_propulsion_max_thrust(instance, p_MaxThrust0)
	getPointer(instance).MaxThrust = p_MaxThrust0;
end
function abi.ffi.prop_get_rocket_propulsion_max_torque(instance)
	return createPointer(getPointer(instance).MaxTorque);
end
function abi.ffi.prop_set_rocket_propulsion_max_torque(instance, p_MaxTorque0)
	getPointer(instance).MaxTorque = getPointer(p_MaxTorque0);
end
function abi.ffi.prop_get_rocket_propulsion_target(output, instance)
	local value0 = getPointer(instance).Target;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_rocket_propulsion_target(instance, p_Target0, p_Target1)
	local value0;
	if p_Target0 == 1 then
		value0 = getPointer(p_Target1);
	end
	getPointer(instance).Target = value0;
end
function abi.ffi.prop_get_rocket_propulsion_target_offset(instance)
	return createPointer(getPointer(instance).TargetOffset);
end
function abi.ffi.prop_set_rocket_propulsion_target_offset(instance, p_TargetOffset0)
	getPointer(instance).TargetOffset = getPointer(p_TargetOffset0);
end
function abi.ffi.prop_get_rocket_propulsion_target_radius(instance)
	return getPointer(instance).TargetRadius;
end
function abi.ffi.prop_set_rocket_propulsion_target_radius(instance, p_TargetRadius0)
	getPointer(instance).TargetRadius = p_TargetRadius0;
end
function abi.ffi.prop_get_rocket_propulsion_thrust_d(instance)
	return getPointer(instance).ThrustD;
end
function abi.ffi.prop_set_rocket_propulsion_thrust_d(instance, p_ThrustD0)
	getPointer(instance).ThrustD = p_ThrustD0;
end
function abi.ffi.prop_get_rocket_propulsion_thrust_p(instance)
	return getPointer(instance).ThrustP;
end
function abi.ffi.prop_set_rocket_propulsion_thrust_p(instance, p_ThrustP0)
	getPointer(instance).ThrustP = p_ThrustP0;
end
function abi.ffi.prop_get_rocket_propulsion_turn_d(instance)
	return getPointer(instance).TurnD;
end
function abi.ffi.prop_set_rocket_propulsion_turn_d(instance, p_TurnD0)
	getPointer(instance).TurnD = p_TurnD0;
end
function abi.ffi.prop_get_rocket_propulsion_turn_p(instance)
	return getPointer(instance).TurnP;
end
function abi.ffi.prop_set_rocket_propulsion_turn_p(instance, p_TurnP0)
	getPointer(instance).TurnP = p_TurnP0;
end
function abi.ffi.dyn_fn_rocket_propulsion_abort(instance)
	return getPointer(instance):Abort();
end
function abi.ffi.dyn_fn_rocket_propulsion_fire(instance)
	return getPointer(instance):Fire();
end
function abi.ffi.connect_rocket_propulsion_reached_target(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).ReachedTarget:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.prop_get_camera_c_frame(instance)
	return createPointer(getPointer(instance).CFrame);
end
function abi.ffi.prop_set_camera_c_frame(instance, p_CFrame0)
	getPointer(instance).CFrame = getPointer(p_CFrame0);
end
function abi.ffi.prop_get_camera_camera_subject(output, instance)
	local value0 = getPointer(instance).CameraSubject;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_camera_camera_subject(instance, p_CameraSubject0, p_CameraSubject1)
	local value0;
	if p_CameraSubject0 == 1 then
		value0 = getPointer(p_CameraSubject1);
	end
	getPointer(instance).CameraSubject = value0;
end
function abi.ffi.prop_get_camera_camera_type(instance)
	return (getPointer(instance).CameraType).Value;
end
function abi.ffi.prop_set_camera_camera_type(instance, p_CameraType0)
	getPointer(instance).CameraType = p_CameraType0;
end
function abi.ffi.prop_get_camera_diagonal_field_of_view(instance)
	return getPointer(instance).DiagonalFieldOfView;
end
function abi.ffi.prop_set_camera_diagonal_field_of_view(instance, p_DiagonalFieldOfView0)
	getPointer(instance).DiagonalFieldOfView = p_DiagonalFieldOfView0;
end
function abi.ffi.prop_get_camera_field_of_view(instance)
	return getPointer(instance).FieldOfView;
end
function abi.ffi.prop_set_camera_field_of_view(instance, p_FieldOfView0)
	getPointer(instance).FieldOfView = p_FieldOfView0;
end
function abi.ffi.prop_get_camera_field_of_view_mode(instance)
	return (getPointer(instance).FieldOfViewMode).Value;
end
function abi.ffi.prop_set_camera_field_of_view_mode(instance, p_FieldOfViewMode0)
	getPointer(instance).FieldOfViewMode = p_FieldOfViewMode0;
end
function abi.ffi.prop_get_camera_focus(instance)
	return createPointer(getPointer(instance).Focus);
end
function abi.ffi.prop_set_camera_focus(instance, p_Focus0)
	getPointer(instance).Focus = getPointer(p_Focus0);
end
function abi.ffi.prop_get_camera_head_locked(instance)
	return getPointer(instance).HeadLocked and 1 or 0;
end
function abi.ffi.prop_set_camera_head_locked(instance, p_HeadLocked0)
	getPointer(instance).HeadLocked = p_HeadLocked0 == 1;
end
function abi.ffi.prop_get_camera_head_scale(instance)
	return getPointer(instance).HeadScale;
end
function abi.ffi.prop_set_camera_head_scale(instance, p_HeadScale0)
	getPointer(instance).HeadScale = p_HeadScale0;
end
function abi.ffi.prop_get_camera_max_axis_field_of_view(instance)
	return getPointer(instance).MaxAxisFieldOfView;
end
function abi.ffi.prop_set_camera_max_axis_field_of_view(instance, p_MaxAxisFieldOfView0)
	getPointer(instance).MaxAxisFieldOfView = p_MaxAxisFieldOfView0;
end
function abi.ffi.prop_get_camera_near_plane_z(instance)
	return getPointer(instance).NearPlaneZ;
end
function abi.ffi.prop_get_camera_viewport_size(instance)
	return createPointer(getPointer(instance).ViewportSize);
end
function abi.ffi.dyn_fn_camera_get_pan_speed(instance)
	return getPointer(instance):GetPanSpeed();
end
function abi.ffi.dyn_fn_camera_get_render_c_frame(instance)
	return createPointer(getPointer(instance):GetRenderCFrame());
end
function abi.ffi.dyn_fn_camera_get_roll(instance)
	return getPointer(instance):GetRoll();
end
function abi.ffi.dyn_fn_camera_get_tilt_speed(instance)
	return getPointer(instance):GetTiltSpeed();
end
function abi.ffi.dyn_fn_camera_screen_point_to_ray(instance, p_x0, p_y0, p_depth0)
	return createPointer(getPointer(instance):ScreenPointToRay(p_x0, p_y0, p_depth0));
end
function abi.ffi.dyn_fn_camera_set_camera_pan_mode(instance, p_mode0)
	return getPointer(instance):SetCameraPanMode(p_mode0);
end
function abi.ffi.dyn_fn_camera_set_roll(instance, p_rollAngle0)
	return getPointer(instance):SetRoll(p_rollAngle0);
end
function abi.ffi.dyn_fn_camera_viewport_point_to_ray(instance, p_x0, p_y0, p_depth0)
	return createPointer(getPointer(instance):ViewportPointToRay(p_x0, p_y0, p_depth0));
end
function abi.ffi.connect_camera_interpolation_finished(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).InterpolationFinished:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.prop_get_body_colors_head_color(instance)
	return createPointer(getPointer(instance).HeadColor);
end
function abi.ffi.prop_set_body_colors_head_color(instance, p_HeadColor0)
	getPointer(instance).HeadColor = getPointer(p_HeadColor0);
end
function abi.ffi.prop_get_body_colors_head_color_3(instance)
	return createPointer(getPointer(instance).HeadColor3);
end
function abi.ffi.prop_set_body_colors_head_color_3(instance, p_HeadColor30)
	getPointer(instance).HeadColor3 = getPointer(p_HeadColor30);
end
function abi.ffi.prop_get_body_colors_left_arm_color(instance)
	return createPointer(getPointer(instance).LeftArmColor);
end
function abi.ffi.prop_set_body_colors_left_arm_color(instance, p_LeftArmColor0)
	getPointer(instance).LeftArmColor = getPointer(p_LeftArmColor0);
end
function abi.ffi.prop_get_body_colors_left_arm_color_3(instance)
	return createPointer(getPointer(instance).LeftArmColor3);
end
function abi.ffi.prop_set_body_colors_left_arm_color_3(instance, p_LeftArmColor30)
	getPointer(instance).LeftArmColor3 = getPointer(p_LeftArmColor30);
end
function abi.ffi.prop_get_body_colors_left_leg_color(instance)
	return createPointer(getPointer(instance).LeftLegColor);
end
function abi.ffi.prop_set_body_colors_left_leg_color(instance, p_LeftLegColor0)
	getPointer(instance).LeftLegColor = getPointer(p_LeftLegColor0);
end
function abi.ffi.prop_get_body_colors_left_leg_color_3(instance)
	return createPointer(getPointer(instance).LeftLegColor3);
end
function abi.ffi.prop_set_body_colors_left_leg_color_3(instance, p_LeftLegColor30)
	getPointer(instance).LeftLegColor3 = getPointer(p_LeftLegColor30);
end
function abi.ffi.prop_get_body_colors_right_arm_color(instance)
	return createPointer(getPointer(instance).RightArmColor);
end
function abi.ffi.prop_set_body_colors_right_arm_color(instance, p_RightArmColor0)
	getPointer(instance).RightArmColor = getPointer(p_RightArmColor0);
end
function abi.ffi.prop_get_body_colors_right_arm_color_3(instance)
	return createPointer(getPointer(instance).RightArmColor3);
end
function abi.ffi.prop_set_body_colors_right_arm_color_3(instance, p_RightArmColor30)
	getPointer(instance).RightArmColor3 = getPointer(p_RightArmColor30);
end
function abi.ffi.prop_get_body_colors_right_leg_color(instance)
	return createPointer(getPointer(instance).RightLegColor);
end
function abi.ffi.prop_set_body_colors_right_leg_color(instance, p_RightLegColor0)
	getPointer(instance).RightLegColor = getPointer(p_RightLegColor0);
end
function abi.ffi.prop_get_body_colors_right_leg_color_3(instance)
	return createPointer(getPointer(instance).RightLegColor3);
end
function abi.ffi.prop_set_body_colors_right_leg_color_3(instance, p_RightLegColor30)
	getPointer(instance).RightLegColor3 = getPointer(p_RightLegColor30);
end
function abi.ffi.prop_get_body_colors_torso_color(instance)
	return createPointer(getPointer(instance).TorsoColor);
end
function abi.ffi.prop_set_body_colors_torso_color(instance, p_TorsoColor0)
	getPointer(instance).TorsoColor = getPointer(p_TorsoColor0);
end
function abi.ffi.prop_get_body_colors_torso_color_3(instance)
	return createPointer(getPointer(instance).TorsoColor3);
end
function abi.ffi.prop_set_body_colors_torso_color_3(instance, p_TorsoColor30)
	getPointer(instance).TorsoColor3 = getPointer(p_TorsoColor30);
end
function abi.ffi.prop_get_character_mesh_base_texture_id(instance)
	return getPointer(instance).BaseTextureId;
end
function abi.ffi.prop_set_character_mesh_base_texture_id(instance, p_BaseTextureId0)
	getPointer(instance).BaseTextureId = p_BaseTextureId0;
end
function abi.ffi.prop_get_character_mesh_body_part(instance)
	return (getPointer(instance).BodyPart).Value;
end
function abi.ffi.prop_set_character_mesh_body_part(instance, p_BodyPart0)
	getPointer(instance).BodyPart = p_BodyPart0;
end
function abi.ffi.prop_get_character_mesh_mesh_id(instance)
	return getPointer(instance).MeshId;
end
function abi.ffi.prop_set_character_mesh_mesh_id(instance, p_MeshId0)
	getPointer(instance).MeshId = p_MeshId0;
end
function abi.ffi.prop_get_character_mesh_overlay_texture_id(instance)
	return getPointer(instance).OverlayTextureId;
end
function abi.ffi.prop_set_character_mesh_overlay_texture_id(instance, p_OverlayTextureId0)
	getPointer(instance).OverlayTextureId = p_OverlayTextureId0;
end
function abi.ffi.prop_get_clothing_color_3(instance)
	return createPointer(getPointer(instance).Color3);
end
function abi.ffi.prop_set_clothing_color_3(instance, p_Color30)
	getPointer(instance).Color3 = getPointer(p_Color30);
end
function abi.ffi.prop_get_pants_pants_template(instance)
	return createPointer(getPointer(instance).PantsTemplate);
end
function abi.ffi.prop_set_pants_pants_template(instance, p_PantsTemplate0)
	getPointer(instance).PantsTemplate = getPointer(p_PantsTemplate0);
end
function abi.ffi.prop_get_shirt_shirt_template(instance)
	return createPointer(getPointer(instance).ShirtTemplate);
end
function abi.ffi.prop_set_shirt_shirt_template(instance, p_ShirtTemplate0)
	getPointer(instance).ShirtTemplate = getPointer(p_ShirtTemplate0);
end
function abi.ffi.prop_get_shirt_graphic_color_3(instance)
	return createPointer(getPointer(instance).Color3);
end
function abi.ffi.prop_set_shirt_graphic_color_3(instance, p_Color30)
	getPointer(instance).Color3 = getPointer(p_Color30);
end
function abi.ffi.prop_get_shirt_graphic_graphic(instance)
	return createPointer(getPointer(instance).Graphic);
end
function abi.ffi.prop_set_shirt_graphic_graphic(instance, p_Graphic0)
	getPointer(instance).Graphic = getPointer(p_Graphic0);
end
function abi.ffi.prop_get_chat_bubble_chat_enabled(instance)
	return getPointer(instance).BubbleChatEnabled and 1 or 0;
end
function abi.ffi.prop_set_chat_bubble_chat_enabled(instance, p_BubbleChatEnabled0)
	getPointer(instance).BubbleChatEnabled = p_BubbleChatEnabled0 == 1;
end
function abi.ffi.prop_get_chat_load_default_chat(instance)
	return getPointer(instance).LoadDefaultChat and 1 or 0;
end
function abi.ffi.prop_set_chat_load_default_chat(instance, p_LoadDefaultChat0)
	getPointer(instance).LoadDefaultChat = p_LoadDefaultChat0 == 1;
end
function abi.ffi.dyn_fn_chat_chat(instance, p_partOrCharacter0, p_message0, p_message1, p_color0)
	return getPointer(instance):Chat(getPointer(p_partOrCharacter0), loadString(memory, p_message0, p_message1), p_color0);
end
function abi.ffi.dyn_fn_chat_set_bubble_chat_settings(instance, p_settings0)
	return getPointer(instance):SetBubbleChatSettings(getPointer(p_settings0));
end
function abi.ffi.dyn_fn_chat_can_user_chat_async(instance, p_userId0)
	return getPointer(instance):CanUserChatAsync(p_userId0) and 1 or 0;
end
function abi.ffi.dyn_fn_chat_can_users_chat_async(instance, p_userIdFrom0, p_userIdTo0)
	return getPointer(instance):CanUsersChatAsync(p_userIdFrom0, p_userIdTo0) and 1 or 0;
end
function abi.ffi.dyn_fn_chat_filter_string_async(output, instance, p_stringToFilter0, p_stringToFilter1, p_playerFrom0, p_playerTo0)
	local value0 = getPointer(instance):FilterStringAsync(loadString(memory, p_stringToFilter0, p_stringToFilter1), getPointer(p_playerFrom0), getPointer(p_playerTo0));
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_chat_filter_string_for_broadcast(output, instance, p_stringToFilter0, p_stringToFilter1, p_playerFrom0)
	local value0 = getPointer(instance):FilterStringForBroadcast(loadString(memory, p_stringToFilter0, p_stringToFilter1), getPointer(p_playerFrom0));
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.connect_chat_chatted(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Chatted:Connect(function(p_part, p_message, p_color)
		local value0 = p_part;
		local value1 = p_message;
		local stringContent1, stringLength1 = allocString(#value1), #value1;
		for i = 1, stringLength1 do
			storeU8(memory, stringContent1 + (i - 1), string.byte(value1:sub(i, i)));
		end
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, stringContent1, stringLength1, (p_color).Value);
	end))
end
function abi.ffi.prop_get_click_detector_cursor_icon(instance)
	return createPointer(getPointer(instance).CursorIcon);
end
function abi.ffi.prop_set_click_detector_cursor_icon(instance, p_CursorIcon0)
	getPointer(instance).CursorIcon = getPointer(p_CursorIcon0);
end
function abi.ffi.prop_get_click_detector_max_activation_distance(instance)
	return getPointer(instance).MaxActivationDistance;
end
function abi.ffi.prop_set_click_detector_max_activation_distance(instance, p_MaxActivationDistance0)
	getPointer(instance).MaxActivationDistance = p_MaxActivationDistance0;
end
function abi.ffi.connect_click_detector_mouse_click(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseClick:Connect(function(p_playerWhoClicked)
		local value0 = p_playerWhoClicked;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_click_detector_mouse_hover_enter(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseHoverEnter:Connect(function(p_playerWhoHovered)
		local value0 = p_playerWhoHovered;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_click_detector_mouse_hover_leave(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseHoverLeave:Connect(function(p_playerWhoHovered)
		local value0 = p_playerWhoHovered;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_click_detector_right_mouse_click(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).RightMouseClick:Connect(function(p_playerWhoClicked)
		local value0 = p_playerWhoClicked;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.prop_get_clouds_color(instance)
	return createPointer(getPointer(instance).Color);
end
function abi.ffi.prop_set_clouds_color(instance, p_Color0)
	getPointer(instance).Color = getPointer(p_Color0);
end
function abi.ffi.prop_get_clouds_cover(instance)
	return getPointer(instance).Cover;
end
function abi.ffi.prop_set_clouds_cover(instance, p_Cover0)
	getPointer(instance).Cover = p_Cover0;
end
function abi.ffi.prop_get_clouds_density(instance)
	return getPointer(instance).Density;
end
function abi.ffi.prop_set_clouds_density(instance, p_Density0)
	getPointer(instance).Density = p_Density0;
end
function abi.ffi.prop_get_clouds_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_clouds_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.dyn_fn_collection_service_add_tag(instance, p_instance0, p_tag0, p_tag1)
	return getPointer(instance):AddTag(getPointer(p_instance0), loadString(memory, p_tag0, p_tag1));
end
function abi.ffi.dyn_fn_collection_service_get_tagged(output, instance, p_tag0, p_tag1)
	local result0 = getPointer(instance):GetTagged(loadString(memory, p_tag0, p_tag1));
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_collection_service_get_tags(output, instance, p_instance0)
	local result0 = getPointer(instance):GetTags(getPointer(p_instance0));
	local vec0 = allocVec(#result0 * 8);
	for i, v in ipairs(result0) do
		local value1 = v;
		local stringContent1, stringLength1 = allocString(#value1), #value1;
		for i = 1, stringLength1 do
			storeU8(memory, stringContent1 + (i - 1), string.byte(value1:sub(i, i)));
		end
		storeU32(memory, vec0 + (i - 1) * 8 + 0, stringContent1)
		storeU32(memory, vec0 + (i - 1) * 8 + 4, stringLength1)
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_collection_service_has_tag(instance, p_instance0, p_tag0, p_tag1)
	return getPointer(instance):HasTag(getPointer(p_instance0), loadString(memory, p_tag0, p_tag1)) and 1 or 0;
end
function abi.ffi.dyn_fn_collection_service_remove_tag(instance, p_instance0, p_tag0, p_tag1)
	return getPointer(instance):RemoveTag(getPointer(p_instance0), loadString(memory, p_tag0, p_tag1));
end
function abi.ffi.connect_collection_service_tag_added(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TagAdded:Connect(function(p_tag)
		local value0 = p_tag;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.connect_collection_service_tag_removed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TagRemoved:Connect(function(p_tag)
		local value0 = p_tag;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.prop_get_command_instance_allow_gui_access_points(instance)
	return getPointer(instance).AllowGUIAccessPoints and 1 or 0;
end
function abi.ffi.prop_get_command_instance_display_name(output, instance)
	local value0 = getPointer(instance).DisplayName;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_command_instance_display_name(instance, p_DisplayName0, p_DisplayName1)
	getPointer(instance).DisplayName = loadString(memory, p_DisplayName0, p_DisplayName1);
end
function abi.ffi.prop_get_constraint_active(instance)
	return getPointer(instance).Active and 1 or 0;
end
function abi.ffi.prop_get_constraint_attachment_0(output, instance)
	local value0 = getPointer(instance).Attachment0;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_constraint_attachment_0(instance, p_Attachment00, p_Attachment01)
	local value0;
	if p_Attachment00 == 1 then
		value0 = getPointer(p_Attachment01);
	end
	getPointer(instance).Attachment0 = value0;
end
function abi.ffi.prop_get_constraint_attachment_1(output, instance)
	local value0 = getPointer(instance).Attachment1;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_constraint_attachment_1(instance, p_Attachment10, p_Attachment11)
	local value0;
	if p_Attachment10 == 1 then
		value0 = getPointer(p_Attachment11);
	end
	getPointer(instance).Attachment1 = value0;
end
function abi.ffi.prop_get_constraint_color(instance)
	return createPointer(getPointer(instance).Color);
end
function abi.ffi.prop_set_constraint_color(instance, p_Color0)
	getPointer(instance).Color = getPointer(p_Color0);
end
function abi.ffi.prop_get_constraint_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_constraint_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_constraint_visible(instance)
	return getPointer(instance).Visible and 1 or 0;
end
function abi.ffi.prop_set_constraint_visible(instance, p_Visible0)
	getPointer(instance).Visible = p_Visible0 == 1;
end
function abi.ffi.prop_get_align_orientation_align_type(instance)
	return (getPointer(instance).AlignType).Value;
end
function abi.ffi.prop_set_align_orientation_align_type(instance, p_AlignType0)
	getPointer(instance).AlignType = p_AlignType0;
end
function abi.ffi.prop_get_align_orientation_c_frame(instance)
	return createPointer(getPointer(instance).CFrame);
end
function abi.ffi.prop_set_align_orientation_c_frame(instance, p_CFrame0)
	getPointer(instance).CFrame = getPointer(p_CFrame0);
end
function abi.ffi.prop_get_align_orientation_max_angular_velocity(instance)
	return getPointer(instance).MaxAngularVelocity;
end
function abi.ffi.prop_set_align_orientation_max_angular_velocity(instance, p_MaxAngularVelocity0)
	getPointer(instance).MaxAngularVelocity = p_MaxAngularVelocity0;
end
function abi.ffi.prop_get_align_orientation_max_torque(instance)
	return getPointer(instance).MaxTorque;
end
function abi.ffi.prop_set_align_orientation_max_torque(instance, p_MaxTorque0)
	getPointer(instance).MaxTorque = p_MaxTorque0;
end
function abi.ffi.prop_get_align_orientation_mode(instance)
	return (getPointer(instance).Mode).Value;
end
function abi.ffi.prop_set_align_orientation_mode(instance, p_Mode0)
	getPointer(instance).Mode = p_Mode0;
end
function abi.ffi.prop_get_align_orientation_primary_axis(instance)
	return createPointer(getPointer(instance).PrimaryAxis);
end
function abi.ffi.prop_set_align_orientation_primary_axis(instance, p_PrimaryAxis0)
	getPointer(instance).PrimaryAxis = getPointer(p_PrimaryAxis0);
end
function abi.ffi.prop_get_align_orientation_primary_axis_only(instance)
	return getPointer(instance).PrimaryAxisOnly and 1 or 0;
end
function abi.ffi.prop_set_align_orientation_primary_axis_only(instance, p_PrimaryAxisOnly0)
	getPointer(instance).PrimaryAxisOnly = p_PrimaryAxisOnly0 == 1;
end
function abi.ffi.prop_get_align_orientation_reaction_torque_enabled(instance)
	return getPointer(instance).ReactionTorqueEnabled and 1 or 0;
end
function abi.ffi.prop_set_align_orientation_reaction_torque_enabled(instance, p_ReactionTorqueEnabled0)
	getPointer(instance).ReactionTorqueEnabled = p_ReactionTorqueEnabled0 == 1;
end
function abi.ffi.prop_get_align_orientation_responsiveness(instance)
	return getPointer(instance).Responsiveness;
end
function abi.ffi.prop_set_align_orientation_responsiveness(instance, p_Responsiveness0)
	getPointer(instance).Responsiveness = p_Responsiveness0;
end
function abi.ffi.prop_get_align_orientation_rigidity_enabled(instance)
	return getPointer(instance).RigidityEnabled and 1 or 0;
end
function abi.ffi.prop_set_align_orientation_rigidity_enabled(instance, p_RigidityEnabled0)
	getPointer(instance).RigidityEnabled = p_RigidityEnabled0 == 1;
end
function abi.ffi.prop_get_align_orientation_secondary_axis(instance)
	return createPointer(getPointer(instance).SecondaryAxis);
end
function abi.ffi.prop_set_align_orientation_secondary_axis(instance, p_SecondaryAxis0)
	getPointer(instance).SecondaryAxis = getPointer(p_SecondaryAxis0);
end
function abi.ffi.prop_get_align_position_apply_at_center_of_mass(instance)
	return getPointer(instance).ApplyAtCenterOfMass and 1 or 0;
end
function abi.ffi.prop_set_align_position_apply_at_center_of_mass(instance, p_ApplyAtCenterOfMass0)
	getPointer(instance).ApplyAtCenterOfMass = p_ApplyAtCenterOfMass0 == 1;
end
function abi.ffi.prop_get_align_position_max_force(instance)
	return getPointer(instance).MaxForce;
end
function abi.ffi.prop_set_align_position_max_force(instance, p_MaxForce0)
	getPointer(instance).MaxForce = p_MaxForce0;
end
function abi.ffi.prop_get_align_position_max_velocity(instance)
	return getPointer(instance).MaxVelocity;
end
function abi.ffi.prop_set_align_position_max_velocity(instance, p_MaxVelocity0)
	getPointer(instance).MaxVelocity = p_MaxVelocity0;
end
function abi.ffi.prop_get_align_position_mode(instance)
	return (getPointer(instance).Mode).Value;
end
function abi.ffi.prop_set_align_position_mode(instance, p_Mode0)
	getPointer(instance).Mode = p_Mode0;
end
function abi.ffi.prop_get_align_position_position(instance)
	return createPointer(getPointer(instance).Position);
end
function abi.ffi.prop_set_align_position_position(instance, p_Position0)
	getPointer(instance).Position = getPointer(p_Position0);
end
function abi.ffi.prop_get_align_position_reaction_force_enabled(instance)
	return getPointer(instance).ReactionForceEnabled and 1 or 0;
end
function abi.ffi.prop_set_align_position_reaction_force_enabled(instance, p_ReactionForceEnabled0)
	getPointer(instance).ReactionForceEnabled = p_ReactionForceEnabled0 == 1;
end
function abi.ffi.prop_get_align_position_responsiveness(instance)
	return getPointer(instance).Responsiveness;
end
function abi.ffi.prop_set_align_position_responsiveness(instance, p_Responsiveness0)
	getPointer(instance).Responsiveness = p_Responsiveness0;
end
function abi.ffi.prop_get_align_position_rigidity_enabled(instance)
	return getPointer(instance).RigidityEnabled and 1 or 0;
end
function abi.ffi.prop_set_align_position_rigidity_enabled(instance, p_RigidityEnabled0)
	getPointer(instance).RigidityEnabled = p_RigidityEnabled0 == 1;
end
function abi.ffi.prop_get_angular_velocity_angular_velocity(instance)
	return createPointer(getPointer(instance).AngularVelocity);
end
function abi.ffi.prop_set_angular_velocity_angular_velocity(instance, p_AngularVelocity0)
	getPointer(instance).AngularVelocity = getPointer(p_AngularVelocity0);
end
function abi.ffi.prop_get_angular_velocity_max_torque(instance)
	return getPointer(instance).MaxTorque;
end
function abi.ffi.prop_set_angular_velocity_max_torque(instance, p_MaxTorque0)
	getPointer(instance).MaxTorque = p_MaxTorque0;
end
function abi.ffi.prop_get_angular_velocity_reaction_torque_enabled(instance)
	return getPointer(instance).ReactionTorqueEnabled and 1 or 0;
end
function abi.ffi.prop_set_angular_velocity_reaction_torque_enabled(instance, p_ReactionTorqueEnabled0)
	getPointer(instance).ReactionTorqueEnabled = p_ReactionTorqueEnabled0 == 1;
end
function abi.ffi.prop_get_angular_velocity_relative_to(instance)
	return (getPointer(instance).RelativeTo).Value;
end
function abi.ffi.prop_set_angular_velocity_relative_to(instance, p_RelativeTo0)
	getPointer(instance).RelativeTo = p_RelativeTo0;
end
function abi.ffi.prop_get_animation_constraint_max_force(instance)
	return getPointer(instance).MaxForce;
end
function abi.ffi.prop_set_animation_constraint_max_force(instance, p_MaxForce0)
	getPointer(instance).MaxForce = p_MaxForce0;
end
function abi.ffi.prop_get_animation_constraint_max_torque(instance)
	return getPointer(instance).MaxTorque;
end
function abi.ffi.prop_set_animation_constraint_max_torque(instance, p_MaxTorque0)
	getPointer(instance).MaxTorque = p_MaxTorque0;
end
function abi.ffi.prop_get_animation_constraint_transform(instance)
	return createPointer(getPointer(instance).Transform);
end
function abi.ffi.prop_set_animation_constraint_transform(instance, p_Transform0)
	getPointer(instance).Transform = getPointer(p_Transform0);
end
function abi.ffi.prop_get_ball_socket_constraint_limits_enabled(instance)
	return getPointer(instance).LimitsEnabled and 1 or 0;
end
function abi.ffi.prop_set_ball_socket_constraint_limits_enabled(instance, p_LimitsEnabled0)
	getPointer(instance).LimitsEnabled = p_LimitsEnabled0 == 1;
end
function abi.ffi.prop_get_ball_socket_constraint_max_friction_torque(instance)
	return getPointer(instance).MaxFrictionTorque;
end
function abi.ffi.prop_set_ball_socket_constraint_max_friction_torque(instance, p_MaxFrictionTorque0)
	getPointer(instance).MaxFrictionTorque = p_MaxFrictionTorque0;
end
function abi.ffi.prop_get_ball_socket_constraint_radius(instance)
	return getPointer(instance).Radius;
end
function abi.ffi.prop_set_ball_socket_constraint_radius(instance, p_Radius0)
	getPointer(instance).Radius = p_Radius0;
end
function abi.ffi.prop_get_ball_socket_constraint_restitution(instance)
	return getPointer(instance).Restitution;
end
function abi.ffi.prop_set_ball_socket_constraint_restitution(instance, p_Restitution0)
	getPointer(instance).Restitution = p_Restitution0;
end
function abi.ffi.prop_get_ball_socket_constraint_twist_limits_enabled(instance)
	return getPointer(instance).TwistLimitsEnabled and 1 or 0;
end
function abi.ffi.prop_set_ball_socket_constraint_twist_limits_enabled(instance, p_TwistLimitsEnabled0)
	getPointer(instance).TwistLimitsEnabled = p_TwistLimitsEnabled0 == 1;
end
function abi.ffi.prop_get_ball_socket_constraint_twist_lower_angle(instance)
	return getPointer(instance).TwistLowerAngle;
end
function abi.ffi.prop_set_ball_socket_constraint_twist_lower_angle(instance, p_TwistLowerAngle0)
	getPointer(instance).TwistLowerAngle = p_TwistLowerAngle0;
end
function abi.ffi.prop_get_ball_socket_constraint_twist_upper_angle(instance)
	return getPointer(instance).TwistUpperAngle;
end
function abi.ffi.prop_set_ball_socket_constraint_twist_upper_angle(instance, p_TwistUpperAngle0)
	getPointer(instance).TwistUpperAngle = p_TwistUpperAngle0;
end
function abi.ffi.prop_get_ball_socket_constraint_upper_angle(instance)
	return getPointer(instance).UpperAngle;
end
function abi.ffi.prop_set_ball_socket_constraint_upper_angle(instance, p_UpperAngle0)
	getPointer(instance).UpperAngle = p_UpperAngle0;
end
function abi.ffi.prop_get_hinge_constraint_actuator_type(instance)
	return (getPointer(instance).ActuatorType).Value;
end
function abi.ffi.prop_set_hinge_constraint_actuator_type(instance, p_ActuatorType0)
	getPointer(instance).ActuatorType = p_ActuatorType0;
end
function abi.ffi.prop_get_hinge_constraint_angular_responsiveness(instance)
	return getPointer(instance).AngularResponsiveness;
end
function abi.ffi.prop_set_hinge_constraint_angular_responsiveness(instance, p_AngularResponsiveness0)
	getPointer(instance).AngularResponsiveness = p_AngularResponsiveness0;
end
function abi.ffi.prop_get_hinge_constraint_angular_speed(instance)
	return getPointer(instance).AngularSpeed;
end
function abi.ffi.prop_set_hinge_constraint_angular_speed(instance, p_AngularSpeed0)
	getPointer(instance).AngularSpeed = p_AngularSpeed0;
end
function abi.ffi.prop_get_hinge_constraint_angular_velocity(instance)
	return getPointer(instance).AngularVelocity;
end
function abi.ffi.prop_set_hinge_constraint_angular_velocity(instance, p_AngularVelocity0)
	getPointer(instance).AngularVelocity = p_AngularVelocity0;
end
function abi.ffi.prop_get_hinge_constraint_current_angle(instance)
	return getPointer(instance).CurrentAngle;
end
function abi.ffi.prop_get_hinge_constraint_limits_enabled(instance)
	return getPointer(instance).LimitsEnabled and 1 or 0;
end
function abi.ffi.prop_set_hinge_constraint_limits_enabled(instance, p_LimitsEnabled0)
	getPointer(instance).LimitsEnabled = p_LimitsEnabled0 == 1;
end
function abi.ffi.prop_get_hinge_constraint_lower_angle(instance)
	return getPointer(instance).LowerAngle;
end
function abi.ffi.prop_set_hinge_constraint_lower_angle(instance, p_LowerAngle0)
	getPointer(instance).LowerAngle = p_LowerAngle0;
end
function abi.ffi.prop_get_hinge_constraint_motor_max_acceleration(instance)
	return getPointer(instance).MotorMaxAcceleration;
end
function abi.ffi.prop_set_hinge_constraint_motor_max_acceleration(instance, p_MotorMaxAcceleration0)
	getPointer(instance).MotorMaxAcceleration = p_MotorMaxAcceleration0;
end
function abi.ffi.prop_get_hinge_constraint_motor_max_torque(instance)
	return getPointer(instance).MotorMaxTorque;
end
function abi.ffi.prop_set_hinge_constraint_motor_max_torque(instance, p_MotorMaxTorque0)
	getPointer(instance).MotorMaxTorque = p_MotorMaxTorque0;
end
function abi.ffi.prop_get_hinge_constraint_radius(instance)
	return getPointer(instance).Radius;
end
function abi.ffi.prop_set_hinge_constraint_radius(instance, p_Radius0)
	getPointer(instance).Radius = p_Radius0;
end
function abi.ffi.prop_get_hinge_constraint_restitution(instance)
	return getPointer(instance).Restitution;
end
function abi.ffi.prop_set_hinge_constraint_restitution(instance, p_Restitution0)
	getPointer(instance).Restitution = p_Restitution0;
end
function abi.ffi.prop_get_hinge_constraint_servo_max_torque(instance)
	return getPointer(instance).ServoMaxTorque;
end
function abi.ffi.prop_set_hinge_constraint_servo_max_torque(instance, p_ServoMaxTorque0)
	getPointer(instance).ServoMaxTorque = p_ServoMaxTorque0;
end
function abi.ffi.prop_get_hinge_constraint_target_angle(instance)
	return getPointer(instance).TargetAngle;
end
function abi.ffi.prop_set_hinge_constraint_target_angle(instance, p_TargetAngle0)
	getPointer(instance).TargetAngle = p_TargetAngle0;
end
function abi.ffi.prop_get_hinge_constraint_upper_angle(instance)
	return getPointer(instance).UpperAngle;
end
function abi.ffi.prop_set_hinge_constraint_upper_angle(instance, p_UpperAngle0)
	getPointer(instance).UpperAngle = p_UpperAngle0;
end
function abi.ffi.prop_get_line_force_apply_at_center_of_mass(instance)
	return getPointer(instance).ApplyAtCenterOfMass and 1 or 0;
end
function abi.ffi.prop_set_line_force_apply_at_center_of_mass(instance, p_ApplyAtCenterOfMass0)
	getPointer(instance).ApplyAtCenterOfMass = p_ApplyAtCenterOfMass0 == 1;
end
function abi.ffi.prop_get_line_force_inverse_square_law(instance)
	return getPointer(instance).InverseSquareLaw and 1 or 0;
end
function abi.ffi.prop_set_line_force_inverse_square_law(instance, p_InverseSquareLaw0)
	getPointer(instance).InverseSquareLaw = p_InverseSquareLaw0 == 1;
end
function abi.ffi.prop_get_line_force_magnitude(instance)
	return getPointer(instance).Magnitude;
end
function abi.ffi.prop_set_line_force_magnitude(instance, p_Magnitude0)
	getPointer(instance).Magnitude = p_Magnitude0;
end
function abi.ffi.prop_get_line_force_max_force(instance)
	return getPointer(instance).MaxForce;
end
function abi.ffi.prop_set_line_force_max_force(instance, p_MaxForce0)
	getPointer(instance).MaxForce = p_MaxForce0;
end
function abi.ffi.prop_get_line_force_reaction_force_enabled(instance)
	return getPointer(instance).ReactionForceEnabled and 1 or 0;
end
function abi.ffi.prop_set_line_force_reaction_force_enabled(instance, p_ReactionForceEnabled0)
	getPointer(instance).ReactionForceEnabled = p_ReactionForceEnabled0 == 1;
end
function abi.ffi.prop_get_linear_velocity_line_direction(instance)
	return createPointer(getPointer(instance).LineDirection);
end
function abi.ffi.prop_set_linear_velocity_line_direction(instance, p_LineDirection0)
	getPointer(instance).LineDirection = getPointer(p_LineDirection0);
end
function abi.ffi.prop_get_linear_velocity_line_velocity(instance)
	return getPointer(instance).LineVelocity;
end
function abi.ffi.prop_set_linear_velocity_line_velocity(instance, p_LineVelocity0)
	getPointer(instance).LineVelocity = p_LineVelocity0;
end
function abi.ffi.prop_get_linear_velocity_max_force(instance)
	return getPointer(instance).MaxForce;
end
function abi.ffi.prop_set_linear_velocity_max_force(instance, p_MaxForce0)
	getPointer(instance).MaxForce = p_MaxForce0;
end
function abi.ffi.prop_get_linear_velocity_plane_velocity(instance)
	return createPointer(getPointer(instance).PlaneVelocity);
end
function abi.ffi.prop_set_linear_velocity_plane_velocity(instance, p_PlaneVelocity0)
	getPointer(instance).PlaneVelocity = getPointer(p_PlaneVelocity0);
end
function abi.ffi.prop_get_linear_velocity_primary_tangent_axis(instance)
	return createPointer(getPointer(instance).PrimaryTangentAxis);
end
function abi.ffi.prop_set_linear_velocity_primary_tangent_axis(instance, p_PrimaryTangentAxis0)
	getPointer(instance).PrimaryTangentAxis = getPointer(p_PrimaryTangentAxis0);
end
function abi.ffi.prop_get_linear_velocity_relative_to(instance)
	return (getPointer(instance).RelativeTo).Value;
end
function abi.ffi.prop_set_linear_velocity_relative_to(instance, p_RelativeTo0)
	getPointer(instance).RelativeTo = p_RelativeTo0;
end
function abi.ffi.prop_get_linear_velocity_secondary_tangent_axis(instance)
	return createPointer(getPointer(instance).SecondaryTangentAxis);
end
function abi.ffi.prop_set_linear_velocity_secondary_tangent_axis(instance, p_SecondaryTangentAxis0)
	getPointer(instance).SecondaryTangentAxis = getPointer(p_SecondaryTangentAxis0);
end
function abi.ffi.prop_get_linear_velocity_vector_velocity(instance)
	return createPointer(getPointer(instance).VectorVelocity);
end
function abi.ffi.prop_set_linear_velocity_vector_velocity(instance, p_VectorVelocity0)
	getPointer(instance).VectorVelocity = getPointer(p_VectorVelocity0);
end
function abi.ffi.prop_get_linear_velocity_velocity_constraint_mode(instance)
	return (getPointer(instance).VelocityConstraintMode).Value;
end
function abi.ffi.prop_set_linear_velocity_velocity_constraint_mode(instance, p_VelocityConstraintMode0)
	getPointer(instance).VelocityConstraintMode = p_VelocityConstraintMode0;
end
function abi.ffi.prop_get_rod_constraint_current_distance(instance)
	return getPointer(instance).CurrentDistance;
end
function abi.ffi.prop_get_rod_constraint_length(instance)
	return getPointer(instance).Length;
end
function abi.ffi.prop_set_rod_constraint_length(instance, p_Length0)
	getPointer(instance).Length = p_Length0;
end
function abi.ffi.prop_get_rod_constraint_limit_angle_0(instance)
	return getPointer(instance).LimitAngle0;
end
function abi.ffi.prop_set_rod_constraint_limit_angle_0(instance, p_LimitAngle00)
	getPointer(instance).LimitAngle0 = p_LimitAngle00;
end
function abi.ffi.prop_get_rod_constraint_limit_angle_1(instance)
	return getPointer(instance).LimitAngle1;
end
function abi.ffi.prop_set_rod_constraint_limit_angle_1(instance, p_LimitAngle10)
	getPointer(instance).LimitAngle1 = p_LimitAngle10;
end
function abi.ffi.prop_get_rod_constraint_limits_enabled(instance)
	return getPointer(instance).LimitsEnabled and 1 or 0;
end
function abi.ffi.prop_set_rod_constraint_limits_enabled(instance, p_LimitsEnabled0)
	getPointer(instance).LimitsEnabled = p_LimitsEnabled0 == 1;
end
function abi.ffi.prop_get_rod_constraint_thickness(instance)
	return getPointer(instance).Thickness;
end
function abi.ffi.prop_set_rod_constraint_thickness(instance, p_Thickness0)
	getPointer(instance).Thickness = p_Thickness0;
end
function abi.ffi.prop_get_rope_constraint_current_distance(instance)
	return getPointer(instance).CurrentDistance;
end
function abi.ffi.prop_get_rope_constraint_length(instance)
	return getPointer(instance).Length;
end
function abi.ffi.prop_set_rope_constraint_length(instance, p_Length0)
	getPointer(instance).Length = p_Length0;
end
function abi.ffi.prop_get_rope_constraint_restitution(instance)
	return getPointer(instance).Restitution;
end
function abi.ffi.prop_set_rope_constraint_restitution(instance, p_Restitution0)
	getPointer(instance).Restitution = p_Restitution0;
end
function abi.ffi.prop_get_rope_constraint_thickness(instance)
	return getPointer(instance).Thickness;
end
function abi.ffi.prop_set_rope_constraint_thickness(instance, p_Thickness0)
	getPointer(instance).Thickness = p_Thickness0;
end
function abi.ffi.prop_get_rope_constraint_winch_enabled(instance)
	return getPointer(instance).WinchEnabled and 1 or 0;
end
function abi.ffi.prop_set_rope_constraint_winch_enabled(instance, p_WinchEnabled0)
	getPointer(instance).WinchEnabled = p_WinchEnabled0 == 1;
end
function abi.ffi.prop_get_rope_constraint_winch_force(instance)
	return getPointer(instance).WinchForce;
end
function abi.ffi.prop_set_rope_constraint_winch_force(instance, p_WinchForce0)
	getPointer(instance).WinchForce = p_WinchForce0;
end
function abi.ffi.prop_get_rope_constraint_winch_responsiveness(instance)
	return getPointer(instance).WinchResponsiveness;
end
function abi.ffi.prop_set_rope_constraint_winch_responsiveness(instance, p_WinchResponsiveness0)
	getPointer(instance).WinchResponsiveness = p_WinchResponsiveness0;
end
function abi.ffi.prop_get_rope_constraint_winch_speed(instance)
	return getPointer(instance).WinchSpeed;
end
function abi.ffi.prop_set_rope_constraint_winch_speed(instance, p_WinchSpeed0)
	getPointer(instance).WinchSpeed = p_WinchSpeed0;
end
function abi.ffi.prop_get_rope_constraint_winch_target(instance)
	return getPointer(instance).WinchTarget;
end
function abi.ffi.prop_set_rope_constraint_winch_target(instance, p_WinchTarget0)
	getPointer(instance).WinchTarget = p_WinchTarget0;
end
function abi.ffi.prop_get_sliding_ball_constraint_actuator_type(instance)
	return (getPointer(instance).ActuatorType).Value;
end
function abi.ffi.prop_set_sliding_ball_constraint_actuator_type(instance, p_ActuatorType0)
	getPointer(instance).ActuatorType = p_ActuatorType0;
end
function abi.ffi.prop_get_sliding_ball_constraint_current_position(instance)
	return getPointer(instance).CurrentPosition;
end
function abi.ffi.prop_get_sliding_ball_constraint_limits_enabled(instance)
	return getPointer(instance).LimitsEnabled and 1 or 0;
end
function abi.ffi.prop_set_sliding_ball_constraint_limits_enabled(instance, p_LimitsEnabled0)
	getPointer(instance).LimitsEnabled = p_LimitsEnabled0 == 1;
end
function abi.ffi.prop_get_sliding_ball_constraint_linear_responsiveness(instance)
	return getPointer(instance).LinearResponsiveness;
end
function abi.ffi.prop_set_sliding_ball_constraint_linear_responsiveness(instance, p_LinearResponsiveness0)
	getPointer(instance).LinearResponsiveness = p_LinearResponsiveness0;
end
function abi.ffi.prop_get_sliding_ball_constraint_lower_limit(instance)
	return getPointer(instance).LowerLimit;
end
function abi.ffi.prop_set_sliding_ball_constraint_lower_limit(instance, p_LowerLimit0)
	getPointer(instance).LowerLimit = p_LowerLimit0;
end
function abi.ffi.prop_get_sliding_ball_constraint_motor_max_acceleration(instance)
	return getPointer(instance).MotorMaxAcceleration;
end
function abi.ffi.prop_set_sliding_ball_constraint_motor_max_acceleration(instance, p_MotorMaxAcceleration0)
	getPointer(instance).MotorMaxAcceleration = p_MotorMaxAcceleration0;
end
function abi.ffi.prop_get_sliding_ball_constraint_motor_max_force(instance)
	return getPointer(instance).MotorMaxForce;
end
function abi.ffi.prop_set_sliding_ball_constraint_motor_max_force(instance, p_MotorMaxForce0)
	getPointer(instance).MotorMaxForce = p_MotorMaxForce0;
end
function abi.ffi.prop_get_sliding_ball_constraint_restitution(instance)
	return getPointer(instance).Restitution;
end
function abi.ffi.prop_set_sliding_ball_constraint_restitution(instance, p_Restitution0)
	getPointer(instance).Restitution = p_Restitution0;
end
function abi.ffi.prop_get_sliding_ball_constraint_servo_max_force(instance)
	return getPointer(instance).ServoMaxForce;
end
function abi.ffi.prop_set_sliding_ball_constraint_servo_max_force(instance, p_ServoMaxForce0)
	getPointer(instance).ServoMaxForce = p_ServoMaxForce0;
end
function abi.ffi.prop_get_sliding_ball_constraint_size(instance)
	return getPointer(instance).Size;
end
function abi.ffi.prop_set_sliding_ball_constraint_size(instance, p_Size0)
	getPointer(instance).Size = p_Size0;
end
function abi.ffi.prop_get_sliding_ball_constraint_speed(instance)
	return getPointer(instance).Speed;
end
function abi.ffi.prop_set_sliding_ball_constraint_speed(instance, p_Speed0)
	getPointer(instance).Speed = p_Speed0;
end
function abi.ffi.prop_get_sliding_ball_constraint_target_position(instance)
	return getPointer(instance).TargetPosition;
end
function abi.ffi.prop_set_sliding_ball_constraint_target_position(instance, p_TargetPosition0)
	getPointer(instance).TargetPosition = p_TargetPosition0;
end
function abi.ffi.prop_get_sliding_ball_constraint_upper_limit(instance)
	return getPointer(instance).UpperLimit;
end
function abi.ffi.prop_set_sliding_ball_constraint_upper_limit(instance, p_UpperLimit0)
	getPointer(instance).UpperLimit = p_UpperLimit0;
end
function abi.ffi.prop_get_sliding_ball_constraint_velocity(instance)
	return getPointer(instance).Velocity;
end
function abi.ffi.prop_set_sliding_ball_constraint_velocity(instance, p_Velocity0)
	getPointer(instance).Velocity = p_Velocity0;
end
function abi.ffi.prop_get_cylindrical_constraint_angular_actuator_type(instance)
	return (getPointer(instance).AngularActuatorType).Value;
end
function abi.ffi.prop_set_cylindrical_constraint_angular_actuator_type(instance, p_AngularActuatorType0)
	getPointer(instance).AngularActuatorType = p_AngularActuatorType0;
end
function abi.ffi.prop_get_cylindrical_constraint_angular_limits_enabled(instance)
	return getPointer(instance).AngularLimitsEnabled and 1 or 0;
end
function abi.ffi.prop_set_cylindrical_constraint_angular_limits_enabled(instance, p_AngularLimitsEnabled0)
	getPointer(instance).AngularLimitsEnabled = p_AngularLimitsEnabled0 == 1;
end
function abi.ffi.prop_get_cylindrical_constraint_angular_responsiveness(instance)
	return getPointer(instance).AngularResponsiveness;
end
function abi.ffi.prop_set_cylindrical_constraint_angular_responsiveness(instance, p_AngularResponsiveness0)
	getPointer(instance).AngularResponsiveness = p_AngularResponsiveness0;
end
function abi.ffi.prop_get_cylindrical_constraint_angular_restitution(instance)
	return getPointer(instance).AngularRestitution;
end
function abi.ffi.prop_set_cylindrical_constraint_angular_restitution(instance, p_AngularRestitution0)
	getPointer(instance).AngularRestitution = p_AngularRestitution0;
end
function abi.ffi.prop_get_cylindrical_constraint_angular_speed(instance)
	return getPointer(instance).AngularSpeed;
end
function abi.ffi.prop_set_cylindrical_constraint_angular_speed(instance, p_AngularSpeed0)
	getPointer(instance).AngularSpeed = p_AngularSpeed0;
end
function abi.ffi.prop_get_cylindrical_constraint_angular_velocity(instance)
	return getPointer(instance).AngularVelocity;
end
function abi.ffi.prop_set_cylindrical_constraint_angular_velocity(instance, p_AngularVelocity0)
	getPointer(instance).AngularVelocity = p_AngularVelocity0;
end
function abi.ffi.prop_get_cylindrical_constraint_current_angle(instance)
	return getPointer(instance).CurrentAngle;
end
function abi.ffi.prop_get_cylindrical_constraint_inclination_angle(instance)
	return getPointer(instance).InclinationAngle;
end
function abi.ffi.prop_set_cylindrical_constraint_inclination_angle(instance, p_InclinationAngle0)
	getPointer(instance).InclinationAngle = p_InclinationAngle0;
end
function abi.ffi.prop_get_cylindrical_constraint_lower_angle(instance)
	return getPointer(instance).LowerAngle;
end
function abi.ffi.prop_set_cylindrical_constraint_lower_angle(instance, p_LowerAngle0)
	getPointer(instance).LowerAngle = p_LowerAngle0;
end
function abi.ffi.prop_get_cylindrical_constraint_motor_max_angular_acceleration(instance)
	return getPointer(instance).MotorMaxAngularAcceleration;
end
function abi.ffi.prop_set_cylindrical_constraint_motor_max_angular_acceleration(instance, p_MotorMaxAngularAcceleration0)
	getPointer(instance).MotorMaxAngularAcceleration = p_MotorMaxAngularAcceleration0;
end
function abi.ffi.prop_get_cylindrical_constraint_motor_max_torque(instance)
	return getPointer(instance).MotorMaxTorque;
end
function abi.ffi.prop_set_cylindrical_constraint_motor_max_torque(instance, p_MotorMaxTorque0)
	getPointer(instance).MotorMaxTorque = p_MotorMaxTorque0;
end
function abi.ffi.prop_get_cylindrical_constraint_rotation_axis_visible(instance)
	return getPointer(instance).RotationAxisVisible and 1 or 0;
end
function abi.ffi.prop_set_cylindrical_constraint_rotation_axis_visible(instance, p_RotationAxisVisible0)
	getPointer(instance).RotationAxisVisible = p_RotationAxisVisible0 == 1;
end
function abi.ffi.prop_get_cylindrical_constraint_servo_max_torque(instance)
	return getPointer(instance).ServoMaxTorque;
end
function abi.ffi.prop_set_cylindrical_constraint_servo_max_torque(instance, p_ServoMaxTorque0)
	getPointer(instance).ServoMaxTorque = p_ServoMaxTorque0;
end
function abi.ffi.prop_get_cylindrical_constraint_target_angle(instance)
	return getPointer(instance).TargetAngle;
end
function abi.ffi.prop_set_cylindrical_constraint_target_angle(instance, p_TargetAngle0)
	getPointer(instance).TargetAngle = p_TargetAngle0;
end
function abi.ffi.prop_get_cylindrical_constraint_upper_angle(instance)
	return getPointer(instance).UpperAngle;
end
function abi.ffi.prop_set_cylindrical_constraint_upper_angle(instance, p_UpperAngle0)
	getPointer(instance).UpperAngle = p_UpperAngle0;
end
function abi.ffi.prop_get_cylindrical_constraint_world_rotation_axis(instance)
	return createPointer(getPointer(instance).WorldRotationAxis);
end
function abi.ffi.prop_get_spring_constraint_coils(instance)
	return getPointer(instance).Coils;
end
function abi.ffi.prop_set_spring_constraint_coils(instance, p_Coils0)
	getPointer(instance).Coils = p_Coils0;
end
function abi.ffi.prop_get_spring_constraint_current_length(instance)
	return getPointer(instance).CurrentLength;
end
function abi.ffi.prop_get_spring_constraint_damping(instance)
	return getPointer(instance).Damping;
end
function abi.ffi.prop_set_spring_constraint_damping(instance, p_Damping0)
	getPointer(instance).Damping = p_Damping0;
end
function abi.ffi.prop_get_spring_constraint_free_length(instance)
	return getPointer(instance).FreeLength;
end
function abi.ffi.prop_set_spring_constraint_free_length(instance, p_FreeLength0)
	getPointer(instance).FreeLength = p_FreeLength0;
end
function abi.ffi.prop_get_spring_constraint_limits_enabled(instance)
	return getPointer(instance).LimitsEnabled and 1 or 0;
end
function abi.ffi.prop_set_spring_constraint_limits_enabled(instance, p_LimitsEnabled0)
	getPointer(instance).LimitsEnabled = p_LimitsEnabled0 == 1;
end
function abi.ffi.prop_get_spring_constraint_max_force(instance)
	return getPointer(instance).MaxForce;
end
function abi.ffi.prop_set_spring_constraint_max_force(instance, p_MaxForce0)
	getPointer(instance).MaxForce = p_MaxForce0;
end
function abi.ffi.prop_get_spring_constraint_max_length(instance)
	return getPointer(instance).MaxLength;
end
function abi.ffi.prop_set_spring_constraint_max_length(instance, p_MaxLength0)
	getPointer(instance).MaxLength = p_MaxLength0;
end
function abi.ffi.prop_get_spring_constraint_min_length(instance)
	return getPointer(instance).MinLength;
end
function abi.ffi.prop_set_spring_constraint_min_length(instance, p_MinLength0)
	getPointer(instance).MinLength = p_MinLength0;
end
function abi.ffi.prop_get_spring_constraint_radius(instance)
	return getPointer(instance).Radius;
end
function abi.ffi.prop_set_spring_constraint_radius(instance, p_Radius0)
	getPointer(instance).Radius = p_Radius0;
end
function abi.ffi.prop_get_spring_constraint_stiffness(instance)
	return getPointer(instance).Stiffness;
end
function abi.ffi.prop_set_spring_constraint_stiffness(instance, p_Stiffness0)
	getPointer(instance).Stiffness = p_Stiffness0;
end
function abi.ffi.prop_get_spring_constraint_thickness(instance)
	return getPointer(instance).Thickness;
end
function abi.ffi.prop_set_spring_constraint_thickness(instance, p_Thickness0)
	getPointer(instance).Thickness = p_Thickness0;
end
function abi.ffi.prop_get_torque_relative_to(instance)
	return (getPointer(instance).RelativeTo).Value;
end
function abi.ffi.prop_set_torque_relative_to(instance, p_RelativeTo0)
	getPointer(instance).RelativeTo = p_RelativeTo0;
end
function abi.ffi.prop_get_torque_torque(instance)
	return createPointer(getPointer(instance).Torque);
end
function abi.ffi.prop_set_torque_torque(instance, p_Torque0)
	getPointer(instance).Torque = getPointer(p_Torque0);
end
function abi.ffi.prop_get_torsion_spring_constraint_coils(instance)
	return getPointer(instance).Coils;
end
function abi.ffi.prop_set_torsion_spring_constraint_coils(instance, p_Coils0)
	getPointer(instance).Coils = p_Coils0;
end
function abi.ffi.prop_get_torsion_spring_constraint_current_angle(instance)
	return getPointer(instance).CurrentAngle;
end
function abi.ffi.prop_get_torsion_spring_constraint_damping(instance)
	return getPointer(instance).Damping;
end
function abi.ffi.prop_set_torsion_spring_constraint_damping(instance, p_Damping0)
	getPointer(instance).Damping = p_Damping0;
end
function abi.ffi.prop_get_torsion_spring_constraint_limits_enabled(instance)
	return getPointer(instance).LimitsEnabled and 1 or 0;
end
function abi.ffi.prop_set_torsion_spring_constraint_limits_enabled(instance, p_LimitsEnabled0)
	getPointer(instance).LimitsEnabled = p_LimitsEnabled0 == 1;
end
function abi.ffi.prop_get_torsion_spring_constraint_max_angle(instance)
	return getPointer(instance).MaxAngle;
end
function abi.ffi.prop_set_torsion_spring_constraint_max_angle(instance, p_MaxAngle0)
	getPointer(instance).MaxAngle = p_MaxAngle0;
end
function abi.ffi.prop_get_torsion_spring_constraint_max_torque(instance)
	return getPointer(instance).MaxTorque;
end
function abi.ffi.prop_set_torsion_spring_constraint_max_torque(instance, p_MaxTorque0)
	getPointer(instance).MaxTorque = p_MaxTorque0;
end
function abi.ffi.prop_get_torsion_spring_constraint_radius(instance)
	return getPointer(instance).Radius;
end
function abi.ffi.prop_set_torsion_spring_constraint_radius(instance, p_Radius0)
	getPointer(instance).Radius = p_Radius0;
end
function abi.ffi.prop_get_torsion_spring_constraint_restitution(instance)
	return getPointer(instance).Restitution;
end
function abi.ffi.prop_set_torsion_spring_constraint_restitution(instance, p_Restitution0)
	getPointer(instance).Restitution = p_Restitution0;
end
function abi.ffi.prop_get_torsion_spring_constraint_stiffness(instance)
	return getPointer(instance).Stiffness;
end
function abi.ffi.prop_set_torsion_spring_constraint_stiffness(instance, p_Stiffness0)
	getPointer(instance).Stiffness = p_Stiffness0;
end
function abi.ffi.prop_get_universal_constraint_limits_enabled(instance)
	return getPointer(instance).LimitsEnabled and 1 or 0;
end
function abi.ffi.prop_set_universal_constraint_limits_enabled(instance, p_LimitsEnabled0)
	getPointer(instance).LimitsEnabled = p_LimitsEnabled0 == 1;
end
function abi.ffi.prop_get_universal_constraint_max_angle(instance)
	return getPointer(instance).MaxAngle;
end
function abi.ffi.prop_set_universal_constraint_max_angle(instance, p_MaxAngle0)
	getPointer(instance).MaxAngle = p_MaxAngle0;
end
function abi.ffi.prop_get_universal_constraint_radius(instance)
	return getPointer(instance).Radius;
end
function abi.ffi.prop_set_universal_constraint_radius(instance, p_Radius0)
	getPointer(instance).Radius = p_Radius0;
end
function abi.ffi.prop_get_universal_constraint_restitution(instance)
	return getPointer(instance).Restitution;
end
function abi.ffi.prop_set_universal_constraint_restitution(instance, p_Restitution0)
	getPointer(instance).Restitution = p_Restitution0;
end
function abi.ffi.prop_get_vector_force_apply_at_center_of_mass(instance)
	return getPointer(instance).ApplyAtCenterOfMass and 1 or 0;
end
function abi.ffi.prop_set_vector_force_apply_at_center_of_mass(instance, p_ApplyAtCenterOfMass0)
	getPointer(instance).ApplyAtCenterOfMass = p_ApplyAtCenterOfMass0 == 1;
end
function abi.ffi.prop_get_vector_force_force(instance)
	return createPointer(getPointer(instance).Force);
end
function abi.ffi.prop_set_vector_force_force(instance, p_Force0)
	getPointer(instance).Force = getPointer(p_Force0);
end
function abi.ffi.prop_get_vector_force_relative_to(instance)
	return (getPointer(instance).RelativeTo).Value;
end
function abi.ffi.prop_set_vector_force_relative_to(instance, p_RelativeTo0)
	getPointer(instance).RelativeTo = p_RelativeTo0;
end
function abi.ffi.prop_get_content_provider_base_url(output, instance)
	local value0 = getPointer(instance).BaseUrl;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_content_provider_request_queue_size(instance)
	return getPointer(instance).RequestQueueSize;
end
function abi.ffi.dyn_fn_content_provider_register_default_encryption_key(instance, p_encryptionKey0, p_encryptionKey1)
	return getPointer(instance):RegisterDefaultEncryptionKey(loadString(memory, p_encryptionKey0, p_encryptionKey1));
end
function abi.ffi.dyn_fn_content_provider_register_default_session_key(instance, p_sessionKey0, p_sessionKey1)
	return getPointer(instance):RegisterDefaultSessionKey(loadString(memory, p_sessionKey0, p_sessionKey1));
end
function abi.ffi.dyn_fn_content_provider_register_encrypted_asset(instance, p_assetId0, p_encryptionKey0, p_encryptionKey1)
	return getPointer(instance):RegisterEncryptedAsset(getPointer(p_assetId0), loadString(memory, p_encryptionKey0, p_encryptionKey1));
end
function abi.ffi.dyn_fn_content_provider_register_session_encrypted_asset(instance, p_contentId0, p_sessionKey0, p_sessionKey1)
	return getPointer(instance):RegisterSessionEncryptedAsset(getPointer(p_contentId0), loadString(memory, p_sessionKey0, p_sessionKey1));
end
function abi.ffi.dyn_fn_content_provider_unregister_default_encryption_key(instance)
	return getPointer(instance):UnregisterDefaultEncryptionKey();
end
function abi.ffi.dyn_fn_content_provider_unregister_encrypted_asset(instance, p_assetId0)
	return getPointer(instance):UnregisterEncryptedAsset(getPointer(p_assetId0));
end
function abi.ffi.connect_content_provider_asset_fetch_failed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).AssetFetchFailed:Connect(function(p_assetId)
		invokeFunction(data, vtable, createPointer(p_assetId));
	end))
end
function abi.ffi.dyn_fn_context_action_service_get_all_bound_action_info(instance)
	return createPointer(getPointer(instance):GetAllBoundActionInfo());
end
function abi.ffi.dyn_fn_context_action_service_get_bound_action_info(instance, p_actionName0, p_actionName1)
	return createPointer(getPointer(instance):GetBoundActionInfo(loadString(memory, p_actionName0, p_actionName1)));
end
function abi.ffi.dyn_fn_context_action_service_get_current_local_tool_icon(output, instance)
	local value0 = getPointer(instance):GetCurrentLocalToolIcon();
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_context_action_service_set_description(instance, p_actionName0, p_actionName1, p_description0, p_description1)
	return getPointer(instance):SetDescription(loadString(memory, p_actionName0, p_actionName1), loadString(memory, p_description0, p_description1));
end
function abi.ffi.dyn_fn_context_action_service_set_image(instance, p_actionName0, p_actionName1, p_image0, p_image1)
	return getPointer(instance):SetImage(loadString(memory, p_actionName0, p_actionName1), loadString(memory, p_image0, p_image1));
end
function abi.ffi.dyn_fn_context_action_service_set_position(instance, p_actionName0, p_actionName1, p_position0)
	return getPointer(instance):SetPosition(loadString(memory, p_actionName0, p_actionName1), getPointer(p_position0));
end
function abi.ffi.dyn_fn_context_action_service_set_title(instance, p_actionName0, p_actionName1, p_title0, p_title1)
	return getPointer(instance):SetTitle(loadString(memory, p_actionName0, p_actionName1), loadString(memory, p_title0, p_title1));
end
function abi.ffi.dyn_fn_context_action_service_unbind_action(instance, p_actionName0, p_actionName1)
	return getPointer(instance):UnbindAction(loadString(memory, p_actionName0, p_actionName1));
end
function abi.ffi.dyn_fn_context_action_service_unbind_activate(instance, p_userInputTypeForActivation0, p_keyCodeForActivation0)
	return getPointer(instance):UnbindActivate(p_userInputTypeForActivation0, p_keyCodeForActivation0);
end
function abi.ffi.dyn_fn_context_action_service_unbind_all_actions(instance)
	return getPointer(instance):UnbindAllActions();
end
function abi.ffi.dyn_fn_context_action_service_get_button(output, instance, p_actionName0, p_actionName1)
	local value0 = getPointer(instance):GetButton(loadString(memory, p_actionName0, p_actionName1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.connect_context_action_service_local_tool_equipped(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).LocalToolEquipped:Connect(function(p_toolEquipped)
		local value0 = p_toolEquipped;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_context_action_service_local_tool_unequipped(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).LocalToolUnequipped:Connect(function(p_toolUnequipped)
		local value0 = p_toolUnequipped;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.dyn_fn_controller_bind_button(instance, p_button0, p_caption0, p_caption1)
	return getPointer(instance):BindButton(p_button0, loadString(memory, p_caption0, p_caption1));
end
function abi.ffi.dyn_fn_controller_get_button(instance, p_button0)
	return getPointer(instance):GetButton(p_button0) and 1 or 0;
end
function abi.ffi.dyn_fn_controller_unbind_button(instance, p_button0)
	return getPointer(instance):UnbindButton(p_button0);
end
function abi.ffi.connect_controller_button_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).ButtonChanged:Connect(function(p_button)
		invokeFunction(data, vtable, (p_button).Value);
	end))
end
function abi.ffi.prop_get_skateboard_controller_steer(instance)
	return getPointer(instance).Steer;
end
function abi.ffi.prop_get_skateboard_controller_throttle(instance)
	return getPointer(instance).Throttle;
end
function abi.ffi.connect_skateboard_controller_axis_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).AxisChanged:Connect(function(p_axis)
		local value0 = p_axis;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.prop_get_controller_base_move_speed_factor(instance)
	return getPointer(instance).MoveSpeedFactor;
end
function abi.ffi.prop_set_controller_base_move_speed_factor(instance, p_MoveSpeedFactor0)
	getPointer(instance).MoveSpeedFactor = p_MoveSpeedFactor0;
end
function abi.ffi.prop_get_controller_base_rigidity_enabled(instance)
	return getPointer(instance).RigidityEnabled and 1 or 0;
end
function abi.ffi.prop_set_controller_base_rigidity_enabled(instance, p_RigidityEnabled0)
	getPointer(instance).RigidityEnabled = p_RigidityEnabled0 == 1;
end
function abi.ffi.prop_get_air_controller_cancel_air_momentum(instance)
	return getPointer(instance).CancelAirMomentum and 1 or 0;
end
function abi.ffi.prop_set_air_controller_cancel_air_momentum(instance, p_CancelAirMomentum0)
	getPointer(instance).CancelAirMomentum = p_CancelAirMomentum0 == 1;
end
function abi.ffi.prop_get_air_controller_move_max_force(instance)
	return getPointer(instance).MoveMaxForce;
end
function abi.ffi.prop_set_air_controller_move_max_force(instance, p_MoveMaxForce0)
	getPointer(instance).MoveMaxForce = p_MoveMaxForce0;
end
function abi.ffi.prop_get_air_controller_orientation_max_torque(instance)
	return getPointer(instance).OrientationMaxTorque;
end
function abi.ffi.prop_set_air_controller_orientation_max_torque(instance, p_OrientationMaxTorque0)
	getPointer(instance).OrientationMaxTorque = p_OrientationMaxTorque0;
end
function abi.ffi.prop_get_air_controller_orientation_speed_factor(instance)
	return getPointer(instance).OrientationSpeedFactor;
end
function abi.ffi.prop_set_air_controller_orientation_speed_factor(instance, p_OrientationSpeedFactor0)
	getPointer(instance).OrientationSpeedFactor = p_OrientationSpeedFactor0;
end
function abi.ffi.prop_get_air_controller_vector_force(instance)
	return createPointer(getPointer(instance).VectorForce);
end
function abi.ffi.prop_set_air_controller_vector_force(instance, p_VectorForce0)
	getPointer(instance).VectorForce = getPointer(p_VectorForce0);
end
function abi.ffi.prop_get_climb_controller_acceleration_time(instance)
	return getPointer(instance).AccelerationTime;
end
function abi.ffi.prop_set_climb_controller_acceleration_time(instance, p_AccelerationTime0)
	getPointer(instance).AccelerationTime = p_AccelerationTime0;
end
function abi.ffi.prop_get_climb_controller_move_max_force(instance)
	return getPointer(instance).MoveMaxForce;
end
function abi.ffi.prop_set_climb_controller_move_max_force(instance, p_MoveMaxForce0)
	getPointer(instance).MoveMaxForce = p_MoveMaxForce0;
end
function abi.ffi.prop_get_climb_controller_orientation_max_torque(instance)
	return getPointer(instance).OrientationMaxTorque;
end
function abi.ffi.prop_set_climb_controller_orientation_max_torque(instance, p_OrientationMaxTorque0)
	getPointer(instance).OrientationMaxTorque = p_OrientationMaxTorque0;
end
function abi.ffi.prop_get_climb_controller_orientation_speed_factor(instance)
	return getPointer(instance).OrientationSpeedFactor;
end
function abi.ffi.prop_set_climb_controller_orientation_speed_factor(instance, p_OrientationSpeedFactor0)
	getPointer(instance).OrientationSpeedFactor = p_OrientationSpeedFactor0;
end
function abi.ffi.prop_get_ground_controller_acceleration_lean(instance)
	return getPointer(instance).AccelerationLean;
end
function abi.ffi.prop_set_ground_controller_acceleration_lean(instance, p_AccelerationLean0)
	getPointer(instance).AccelerationLean = p_AccelerationLean0;
end
function abi.ffi.prop_get_ground_controller_acceleration_time(instance)
	return getPointer(instance).AccelerationTime;
end
function abi.ffi.prop_set_ground_controller_acceleration_time(instance, p_AccelerationTime0)
	getPointer(instance).AccelerationTime = p_AccelerationTime0;
end
function abi.ffi.prop_get_ground_controller_align_speed(instance)
	return getPointer(instance).AlignSpeed;
end
function abi.ffi.prop_set_ground_controller_align_speed(instance, p_AlignSpeed0)
	getPointer(instance).AlignSpeed = p_AlignSpeed0;
end
function abi.ffi.prop_get_ground_controller_align_torque(instance)
	return getPointer(instance).AlignTorque;
end
function abi.ffi.prop_set_ground_controller_align_torque(instance, p_AlignTorque0)
	getPointer(instance).AlignTorque = p_AlignTorque0;
end
function abi.ffi.prop_get_ground_controller_deceleration_time(instance)
	return getPointer(instance).DecelerationTime;
end
function abi.ffi.prop_set_ground_controller_deceleration_time(instance, p_DecelerationTime0)
	getPointer(instance).DecelerationTime = p_DecelerationTime0;
end
function abi.ffi.prop_get_ground_controller_friction(instance)
	return getPointer(instance).Friction;
end
function abi.ffi.prop_set_ground_controller_friction(instance, p_Friction0)
	getPointer(instance).Friction = p_Friction0;
end
function abi.ffi.prop_get_ground_controller_friction_weight(instance)
	return getPointer(instance).FrictionWeight;
end
function abi.ffi.prop_set_ground_controller_friction_weight(instance, p_FrictionWeight0)
	getPointer(instance).FrictionWeight = p_FrictionWeight0;
end
function abi.ffi.prop_get_ground_controller_ground_offset(instance)
	return getPointer(instance).GroundOffset;
end
function abi.ffi.prop_set_ground_controller_ground_offset(instance, p_GroundOffset0)
	getPointer(instance).GroundOffset = p_GroundOffset0;
end
function abi.ffi.prop_get_ground_controller_max_slope_angle(instance)
	return getPointer(instance).MaxSlopeAngle;
end
function abi.ffi.prop_set_ground_controller_max_slope_angle(instance, p_MaxSlopeAngle0)
	getPointer(instance).MaxSlopeAngle = p_MaxSlopeAngle0;
end
function abi.ffi.prop_get_ground_controller_stand_force(instance)
	return getPointer(instance).StandForce;
end
function abi.ffi.prop_set_ground_controller_stand_force(instance, p_StandForce0)
	getPointer(instance).StandForce = p_StandForce0;
end
function abi.ffi.prop_get_ground_controller_stand_speed(instance)
	return getPointer(instance).StandSpeed;
end
function abi.ffi.prop_set_ground_controller_stand_speed(instance, p_StandSpeed0)
	getPointer(instance).StandSpeed = p_StandSpeed0;
end
function abi.ffi.prop_get_ground_controller_turning_factor(instance)
	return getPointer(instance).TurningFactor;
end
function abi.ffi.prop_set_ground_controller_turning_factor(instance, p_TurningFactor0)
	getPointer(instance).TurningFactor = p_TurningFactor0;
end
function abi.ffi.prop_get_swim_controller_acceleration_time(instance)
	return getPointer(instance).AccelerationTime;
end
function abi.ffi.prop_set_swim_controller_acceleration_time(instance, p_AccelerationTime0)
	getPointer(instance).AccelerationTime = p_AccelerationTime0;
end
function abi.ffi.prop_get_swim_controller_pitch_max_torque(instance)
	return getPointer(instance).PitchMaxTorque;
end
function abi.ffi.prop_set_swim_controller_pitch_max_torque(instance, p_PitchMaxTorque0)
	getPointer(instance).PitchMaxTorque = p_PitchMaxTorque0;
end
function abi.ffi.prop_get_swim_controller_pitch_speed_factor(instance)
	return getPointer(instance).PitchSpeedFactor;
end
function abi.ffi.prop_set_swim_controller_pitch_speed_factor(instance, p_PitchSpeedFactor0)
	getPointer(instance).PitchSpeedFactor = p_PitchSpeedFactor0;
end
function abi.ffi.prop_get_swim_controller_roll_max_torque(instance)
	return getPointer(instance).RollMaxTorque;
end
function abi.ffi.prop_set_swim_controller_roll_max_torque(instance, p_RollMaxTorque0)
	getPointer(instance).RollMaxTorque = p_RollMaxTorque0;
end
function abi.ffi.prop_get_swim_controller_roll_speed_factor(instance)
	return getPointer(instance).RollSpeedFactor;
end
function abi.ffi.prop_set_swim_controller_roll_speed_factor(instance, p_RollSpeedFactor0)
	getPointer(instance).RollSpeedFactor = p_RollSpeedFactor0;
end
function abi.ffi.prop_get_controller_manager_active_controller(output, instance)
	local value0 = getPointer(instance).ActiveController;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_controller_manager_base_move_speed(instance)
	return getPointer(instance).BaseMoveSpeed;
end
function abi.ffi.prop_set_controller_manager_base_move_speed(instance, p_BaseMoveSpeed0)
	getPointer(instance).BaseMoveSpeed = p_BaseMoveSpeed0;
end
function abi.ffi.prop_get_controller_manager_base_turn_speed(instance)
	return getPointer(instance).BaseTurnSpeed;
end
function abi.ffi.prop_set_controller_manager_base_turn_speed(instance, p_BaseTurnSpeed0)
	getPointer(instance).BaseTurnSpeed = p_BaseTurnSpeed0;
end
function abi.ffi.prop_get_controller_manager_facing_direction(instance)
	return createPointer(getPointer(instance).FacingDirection);
end
function abi.ffi.prop_set_controller_manager_facing_direction(instance, p_FacingDirection0)
	getPointer(instance).FacingDirection = getPointer(p_FacingDirection0);
end
function abi.ffi.prop_get_controller_manager_hip_height(instance)
	return getPointer(instance).HipHeight;
end
function abi.ffi.prop_set_controller_manager_hip_height(instance, p_HipHeight0)
	getPointer(instance).HipHeight = p_HipHeight0;
end
function abi.ffi.prop_get_controller_manager_moving_direction(instance)
	return createPointer(getPointer(instance).MovingDirection);
end
function abi.ffi.prop_set_controller_manager_moving_direction(instance, p_MovingDirection0)
	getPointer(instance).MovingDirection = getPointer(p_MovingDirection0);
end
function abi.ffi.prop_get_data_model_mesh_offset(instance)
	return createPointer(getPointer(instance).Offset);
end
function abi.ffi.prop_set_data_model_mesh_offset(instance, p_Offset0)
	getPointer(instance).Offset = getPointer(p_Offset0);
end
function abi.ffi.prop_get_data_model_mesh_scale(instance)
	return createPointer(getPointer(instance).Scale);
end
function abi.ffi.prop_set_data_model_mesh_scale(instance, p_Scale0)
	getPointer(instance).Scale = getPointer(p_Scale0);
end
function abi.ffi.prop_get_data_model_mesh_vertex_color(instance)
	return createPointer(getPointer(instance).VertexColor);
end
function abi.ffi.prop_set_data_model_mesh_vertex_color(instance, p_VertexColor0)
	getPointer(instance).VertexColor = getPointer(p_VertexColor0);
end
function abi.ffi.prop_get_file_mesh_mesh_id(instance)
	return createPointer(getPointer(instance).MeshId);
end
function abi.ffi.prop_set_file_mesh_mesh_id(instance, p_MeshId0)
	getPointer(instance).MeshId = getPointer(p_MeshId0);
end
function abi.ffi.prop_get_file_mesh_texture_id(instance)
	return createPointer(getPointer(instance).TextureId);
end
function abi.ffi.prop_set_file_mesh_texture_id(instance, p_TextureId0)
	getPointer(instance).TextureId = getPointer(p_TextureId0);
end
function abi.ffi.prop_get_special_mesh_mesh_type(instance)
	return (getPointer(instance).MeshType).Value;
end
function abi.ffi.prop_set_special_mesh_mesh_type(instance, p_MeshType0)
	getPointer(instance).MeshType = p_MeshType0;
end
function abi.ffi.dyn_fn_data_store_increment_options_get_metadata(instance)
	return createPointer(getPointer(instance):GetMetadata());
end
function abi.ffi.dyn_fn_data_store_increment_options_set_metadata(instance, p_attributes0)
	return getPointer(instance):SetMetadata(getPointer(p_attributes0));
end
function abi.ffi.prop_get_data_store_info_created_time(instance)
	return getPointer(instance).CreatedTime;
end
function abi.ffi.prop_get_data_store_info_data_store_name(output, instance)
	local value0 = getPointer(instance).DataStoreName;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_data_store_info_updated_time(instance)
	return getPointer(instance).UpdatedTime;
end
function abi.ffi.prop_get_data_store_key_key_name(output, instance)
	local value0 = getPointer(instance).KeyName;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_data_store_key_info_created_time(instance)
	return getPointer(instance).CreatedTime;
end
function abi.ffi.prop_get_data_store_key_info_updated_time(instance)
	return getPointer(instance).UpdatedTime;
end
function abi.ffi.prop_get_data_store_key_info_version(output, instance)
	local value0 = getPointer(instance).Version;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_data_store_key_info_get_metadata(instance)
	return createPointer(getPointer(instance):GetMetadata());
end
function abi.ffi.prop_get_data_store_object_version_info_created_time(instance)
	return getPointer(instance).CreatedTime;
end
function abi.ffi.prop_get_data_store_object_version_info_is_deleted(instance)
	return getPointer(instance).IsDeleted and 1 or 0;
end
function abi.ffi.prop_get_data_store_object_version_info_version(output, instance)
	local value0 = getPointer(instance).Version;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_data_store_options_all_scopes(instance)
	return getPointer(instance).AllScopes and 1 or 0;
end
function abi.ffi.prop_set_data_store_options_all_scopes(instance, p_AllScopes0)
	getPointer(instance).AllScopes = p_AllScopes0 == 1;
end
function abi.ffi.dyn_fn_data_store_options_set_experimental_features(instance, p_experimentalFeatures0)
	return getPointer(instance):SetExperimentalFeatures(getPointer(p_experimentalFeatures0));
end
function abi.ffi.dyn_fn_data_store_service_get_data_store(output, instance, p_name0, p_name1, p_scope0, p_scope1, p_options0)
	local value0 = getPointer(instance):GetDataStore(loadString(memory, p_name0, p_name1), loadString(memory, p_scope0, p_scope1), getPointer(p_options0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_data_store_service_get_global_data_store(output, instance)
	local value0 = getPointer(instance):GetGlobalDataStore();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_data_store_service_get_ordered_data_store(output, instance, p_name0, p_name1, p_scope0, p_scope1)
	local value0 = getPointer(instance):GetOrderedDataStore(loadString(memory, p_name0, p_name1), loadString(memory, p_scope0, p_scope1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_data_store_service_get_request_budget_for_request_type(instance, p_requestType0)
	return getPointer(instance):GetRequestBudgetForRequestType(p_requestType0);
end
function abi.ffi.dyn_fn_data_store_service_list_data_stores_async(output, instance, p_prefix0, p_prefix1, p_pageSize0, p_cursor0, p_cursor1)
	local value0 = getPointer(instance):ListDataStoresAsync(loadString(memory, p_prefix0, p_prefix1), p_pageSize0, loadString(memory, p_cursor0, p_cursor1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_data_store_set_options_get_metadata(instance)
	return createPointer(getPointer(instance):GetMetadata());
end
function abi.ffi.dyn_fn_data_store_set_options_set_metadata(instance, p_attributes0)
	return getPointer(instance):SetMetadata(getPointer(p_attributes0));
end
function abi.ffi.dyn_fn_debris_add_item(instance, p_item0, p_lifetime0)
	return getPointer(instance):AddItem(getPointer(p_item0), p_lifetime0);
end
function abi.ffi.prop_get_dialog_behavior_type(instance)
	return (getPointer(instance).BehaviorType).Value;
end
function abi.ffi.prop_set_dialog_behavior_type(instance, p_BehaviorType0)
	getPointer(instance).BehaviorType = p_BehaviorType0;
end
function abi.ffi.prop_get_dialog_conversation_distance(instance)
	return getPointer(instance).ConversationDistance;
end
function abi.ffi.prop_set_dialog_conversation_distance(instance, p_ConversationDistance0)
	getPointer(instance).ConversationDistance = p_ConversationDistance0;
end
function abi.ffi.prop_get_dialog_goodbye_choice_active(instance)
	return getPointer(instance).GoodbyeChoiceActive and 1 or 0;
end
function abi.ffi.prop_set_dialog_goodbye_choice_active(instance, p_GoodbyeChoiceActive0)
	getPointer(instance).GoodbyeChoiceActive = p_GoodbyeChoiceActive0 == 1;
end
function abi.ffi.prop_get_dialog_goodbye_dialog(output, instance)
	local value0 = getPointer(instance).GoodbyeDialog;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_dialog_goodbye_dialog(instance, p_GoodbyeDialog0, p_GoodbyeDialog1)
	getPointer(instance).GoodbyeDialog = loadString(memory, p_GoodbyeDialog0, p_GoodbyeDialog1);
end
function abi.ffi.prop_get_dialog_in_use(instance)
	return getPointer(instance).InUse and 1 or 0;
end
function abi.ffi.prop_set_dialog_in_use(instance, p_InUse0)
	getPointer(instance).InUse = p_InUse0 == 1;
end
function abi.ffi.prop_get_dialog_initial_prompt(output, instance)
	local value0 = getPointer(instance).InitialPrompt;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_dialog_initial_prompt(instance, p_InitialPrompt0, p_InitialPrompt1)
	getPointer(instance).InitialPrompt = loadString(memory, p_InitialPrompt0, p_InitialPrompt1);
end
function abi.ffi.prop_get_dialog_purpose(instance)
	return (getPointer(instance).Purpose).Value;
end
function abi.ffi.prop_set_dialog_purpose(instance, p_Purpose0)
	getPointer(instance).Purpose = p_Purpose0;
end
function abi.ffi.prop_get_dialog_tone(instance)
	return (getPointer(instance).Tone).Value;
end
function abi.ffi.prop_set_dialog_tone(instance, p_Tone0)
	getPointer(instance).Tone = p_Tone0;
end
function abi.ffi.prop_get_dialog_trigger_distance(instance)
	return getPointer(instance).TriggerDistance;
end
function abi.ffi.prop_set_dialog_trigger_distance(instance, p_TriggerDistance0)
	getPointer(instance).TriggerDistance = p_TriggerDistance0;
end
function abi.ffi.prop_get_dialog_trigger_offset(instance)
	return createPointer(getPointer(instance).TriggerOffset);
end
function abi.ffi.prop_set_dialog_trigger_offset(instance, p_TriggerOffset0)
	getPointer(instance).TriggerOffset = getPointer(p_TriggerOffset0);
end
function abi.ffi.dyn_fn_dialog_get_current_players(output, instance)
	local result0 = getPointer(instance):GetCurrentPlayers();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.connect_dialog_dialog_choice_selected(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).DialogChoiceSelected:Connect(function(p_player, p_dialogChoice)
		local value0 = p_player;
		local value1 = p_dialogChoice;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, value1 and 1 or 0, value1 and createPointer(value1) or 0);
	end))
end
function abi.ffi.prop_get_dialog_choice_goodbye_choice_active(instance)
	return getPointer(instance).GoodbyeChoiceActive and 1 or 0;
end
function abi.ffi.prop_set_dialog_choice_goodbye_choice_active(instance, p_GoodbyeChoiceActive0)
	getPointer(instance).GoodbyeChoiceActive = p_GoodbyeChoiceActive0 == 1;
end
function abi.ffi.prop_get_dialog_choice_goodbye_dialog(output, instance)
	local value0 = getPointer(instance).GoodbyeDialog;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_dialog_choice_goodbye_dialog(instance, p_GoodbyeDialog0, p_GoodbyeDialog1)
	getPointer(instance).GoodbyeDialog = loadString(memory, p_GoodbyeDialog0, p_GoodbyeDialog1);
end
function abi.ffi.prop_get_dialog_choice_response_dialog(output, instance)
	local value0 = getPointer(instance).ResponseDialog;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_dialog_choice_response_dialog(instance, p_ResponseDialog0, p_ResponseDialog1)
	getPointer(instance).ResponseDialog = loadString(memory, p_ResponseDialog0, p_ResponseDialog1);
end
function abi.ffi.prop_get_dialog_choice_user_dialog(output, instance)
	local value0 = getPointer(instance).UserDialog;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_dialog_choice_user_dialog(instance, p_UserDialog0, p_UserDialog1)
	getPointer(instance).UserDialog = loadString(memory, p_UserDialog0, p_UserDialog1);
end
function abi.ffi.dyn_fn_dragger_axis_rotate(instance, p_axis0)
	return getPointer(instance):AxisRotate(p_axis0);
end
function abi.ffi.dyn_fn_dragger_mouse_down(instance, p_mousePart0, p_pointOnMousePart0, p_parts0, p_parts1)
	local result0 = table.create(p_parts1)
	for i = 1, p_parts1 do
		local value0_0 = loadU32(memory, p_parts0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	return getPointer(instance):MouseDown(getPointer(p_mousePart0), getPointer(p_pointOnMousePart0), result0);
end
function abi.ffi.dyn_fn_dragger_mouse_move(instance, p_mouseRay0)
	return getPointer(instance):MouseMove(getPointer(p_mouseRay0));
end
function abi.ffi.dyn_fn_dragger_mouse_up(instance)
	return getPointer(instance):MouseUp();
end
function abi.ffi.prop_get_dragger_service_align_dragged_objects(instance)
	return getPointer(instance).AlignDraggedObjects and 1 or 0;
end
function abi.ffi.prop_get_dragger_service_angle_snap_enabled(instance)
	return getPointer(instance).AngleSnapEnabled and 1 or 0;
end
function abi.ffi.prop_get_dragger_service_angle_snap_increment(instance)
	return getPointer(instance).AngleSnapIncrement;
end
function abi.ffi.prop_get_dragger_service_animate_hover(instance)
	return getPointer(instance).AnimateHover and 1 or 0;
end
function abi.ffi.prop_get_dragger_service_collisions_enabled(instance)
	return getPointer(instance).CollisionsEnabled and 1 or 0;
end
function abi.ffi.prop_get_dragger_service_dragger_coordinate_space(instance)
	return (getPointer(instance).DraggerCoordinateSpace).Value;
end
function abi.ffi.prop_get_dragger_service_dragger_movement_mode(instance)
	return (getPointer(instance).DraggerMovementMode).Value;
end
function abi.ffi.prop_get_dragger_service_geometry_snap_color(instance)
	return createPointer(getPointer(instance).GeometrySnapColor);
end
function abi.ffi.prop_get_dragger_service_hover_animate_frequency(instance)
	return getPointer(instance).HoverAnimateFrequency;
end
function abi.ffi.prop_get_dragger_service_hover_thickness(instance)
	return getPointer(instance).HoverThickness;
end
function abi.ffi.prop_get_dragger_service_joints_enabled(instance)
	return getPointer(instance).JointsEnabled and 1 or 0;
end
function abi.ffi.prop_get_dragger_service_linear_snap_enabled(instance)
	return getPointer(instance).LinearSnapEnabled and 1 or 0;
end
function abi.ffi.prop_get_dragger_service_linear_snap_increment(instance)
	return getPointer(instance).LinearSnapIncrement;
end
function abi.ffi.prop_get_dragger_service_show_hover(instance)
	return getPointer(instance).ShowHover and 1 or 0;
end
function abi.ffi.prop_get_dragger_service_show_pivot_indicator(instance)
	return getPointer(instance).ShowPivotIndicator and 1 or 0;
end
function abi.ffi.prop_set_dragger_service_show_pivot_indicator(instance, p_ShowPivotIndicator0)
	getPointer(instance).ShowPivotIndicator = p_ShowPivotIndicator0 == 1;
end
function abi.ffi.prop_get_euler_rotation_curve_rotation_order(instance)
	return (getPointer(instance).RotationOrder).Value;
end
function abi.ffi.prop_set_euler_rotation_curve_rotation_order(instance, p_RotationOrder0)
	getPointer(instance).RotationOrder = p_RotationOrder0;
end
function abi.ffi.dyn_fn_euler_rotation_curve_get_rotation_at_time(instance, p_time0)
	return createPointer(getPointer(instance):GetRotationAtTime(p_time0));
end
function abi.ffi.dyn_fn_euler_rotation_curve_x(output, instance)
	local value0 = getPointer(instance):X();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_euler_rotation_curve_y(output, instance)
	local value0 = getPointer(instance):Y();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_euler_rotation_curve_z(output, instance)
	local value0 = getPointer(instance):Z();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_experience_invite_options_invite_message_id(instance)
	return getPointer(instance).InviteMessageId;
end
function abi.ffi.prop_set_experience_invite_options_invite_message_id(instance, p_InviteMessageId0)
	getPointer(instance).InviteMessageId = p_InviteMessageId0;
end
function abi.ffi.prop_get_experience_invite_options_invite_user(instance)
	return getPointer(instance).InviteUser;
end
function abi.ffi.prop_set_experience_invite_options_invite_user(instance, p_InviteUser0)
	getPointer(instance).InviteUser = p_InviteUser0;
end
function abi.ffi.prop_get_experience_invite_options_launch_data(output, instance)
	local value0 = getPointer(instance).LaunchData;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_experience_invite_options_launch_data(instance, p_LaunchData0, p_LaunchData1)
	getPointer(instance).LaunchData = loadString(memory, p_LaunchData0, p_LaunchData1);
end
function abi.ffi.prop_get_experience_invite_options_prompt_message(output, instance)
	local value0 = getPointer(instance).PromptMessage;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_experience_invite_options_prompt_message(instance, p_PromptMessage0, p_PromptMessage1)
	getPointer(instance).PromptMessage = loadString(memory, p_PromptMessage0, p_PromptMessage1);
end
function abi.ffi.prop_get_explosion_blast_pressure(instance)
	return getPointer(instance).BlastPressure;
end
function abi.ffi.prop_set_explosion_blast_pressure(instance, p_BlastPressure0)
	getPointer(instance).BlastPressure = p_BlastPressure0;
end
function abi.ffi.prop_get_explosion_blast_radius(instance)
	return getPointer(instance).BlastRadius;
end
function abi.ffi.prop_set_explosion_blast_radius(instance, p_BlastRadius0)
	getPointer(instance).BlastRadius = p_BlastRadius0;
end
function abi.ffi.prop_get_explosion_destroy_joint_radius_percent(instance)
	return getPointer(instance).DestroyJointRadiusPercent;
end
function abi.ffi.prop_set_explosion_destroy_joint_radius_percent(instance, p_DestroyJointRadiusPercent0)
	getPointer(instance).DestroyJointRadiusPercent = p_DestroyJointRadiusPercent0;
end
function abi.ffi.prop_get_explosion_explosion_type(instance)
	return (getPointer(instance).ExplosionType).Value;
end
function abi.ffi.prop_set_explosion_explosion_type(instance, p_ExplosionType0)
	getPointer(instance).ExplosionType = p_ExplosionType0;
end
function abi.ffi.prop_get_explosion_position(instance)
	return createPointer(getPointer(instance).Position);
end
function abi.ffi.prop_set_explosion_position(instance, p_Position0)
	getPointer(instance).Position = getPointer(p_Position0);
end
function abi.ffi.prop_get_explosion_time_scale(instance)
	return getPointer(instance).TimeScale;
end
function abi.ffi.prop_set_explosion_time_scale(instance, p_TimeScale0)
	getPointer(instance).TimeScale = p_TimeScale0;
end
function abi.ffi.prop_get_explosion_visible(instance)
	return getPointer(instance).Visible and 1 or 0;
end
function abi.ffi.prop_set_explosion_visible(instance, p_Visible0)
	getPointer(instance).Visible = p_Visible0 == 1;
end
function abi.ffi.connect_explosion_hit(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Hit:Connect(function(p_part, p_distance)
		local value0 = p_part;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, p_distance);
	end))
end
function abi.ffi.prop_get_face_instance_face(instance)
	return (getPointer(instance).Face).Value;
end
function abi.ffi.prop_set_face_instance_face(instance, p_Face0)
	getPointer(instance).Face = p_Face0;
end
function abi.ffi.prop_get_decal_color_3(instance)
	return createPointer(getPointer(instance).Color3);
end
function abi.ffi.prop_set_decal_color_3(instance, p_Color30)
	getPointer(instance).Color3 = getPointer(p_Color30);
end
function abi.ffi.prop_get_decal_local_transparency_modifier(instance)
	return getPointer(instance).LocalTransparencyModifier;
end
function abi.ffi.prop_set_decal_local_transparency_modifier(instance, p_LocalTransparencyModifier0)
	getPointer(instance).LocalTransparencyModifier = p_LocalTransparencyModifier0;
end
function abi.ffi.prop_get_decal_texture(instance)
	return createPointer(getPointer(instance).Texture);
end
function abi.ffi.prop_set_decal_texture(instance, p_Texture0)
	getPointer(instance).Texture = getPointer(p_Texture0);
end
function abi.ffi.prop_get_decal_transparency(instance)
	return getPointer(instance).Transparency;
end
function abi.ffi.prop_set_decal_transparency(instance, p_Transparency0)
	getPointer(instance).Transparency = p_Transparency0;
end
function abi.ffi.prop_get_decal_z_index(instance)
	return getPointer(instance).ZIndex;
end
function abi.ffi.prop_set_decal_z_index(instance, p_ZIndex0)
	getPointer(instance).ZIndex = p_ZIndex0;
end
function abi.ffi.prop_get_texture_offset_studs_u(instance)
	return getPointer(instance).OffsetStudsU;
end
function abi.ffi.prop_set_texture_offset_studs_u(instance, p_OffsetStudsU0)
	getPointer(instance).OffsetStudsU = p_OffsetStudsU0;
end
function abi.ffi.prop_get_texture_offset_studs_v(instance)
	return getPointer(instance).OffsetStudsV;
end
function abi.ffi.prop_set_texture_offset_studs_v(instance, p_OffsetStudsV0)
	getPointer(instance).OffsetStudsV = p_OffsetStudsV0;
end
function abi.ffi.prop_get_texture_studs_per_tile_u(instance)
	return getPointer(instance).StudsPerTileU;
end
function abi.ffi.prop_set_texture_studs_per_tile_u(instance, p_StudsPerTileU0)
	getPointer(instance).StudsPerTileU = p_StudsPerTileU0;
end
function abi.ffi.prop_get_texture_studs_per_tile_v(instance)
	return getPointer(instance).StudsPerTileV;
end
function abi.ffi.prop_set_texture_studs_per_tile_v(instance, p_StudsPerTileV0)
	getPointer(instance).StudsPerTileV = p_StudsPerTileV0;
end
function abi.ffi.prop_get_feature_face_id(instance)
	return (getPointer(instance).FaceId).Value;
end
function abi.ffi.prop_set_feature_face_id(instance, p_FaceId0)
	getPointer(instance).FaceId = p_FaceId0;
end
function abi.ffi.prop_get_feature_in_out(instance)
	return (getPointer(instance).InOut).Value;
end
function abi.ffi.prop_set_feature_in_out(instance, p_InOut0)
	getPointer(instance).InOut = p_InOut0;
end
function abi.ffi.prop_get_feature_left_right(instance)
	return (getPointer(instance).LeftRight).Value;
end
function abi.ffi.prop_set_feature_left_right(instance, p_LeftRight0)
	getPointer(instance).LeftRight = p_LeftRight0;
end
function abi.ffi.prop_get_feature_top_bottom(instance)
	return (getPointer(instance).TopBottom).Value;
end
function abi.ffi.prop_set_feature_top_bottom(instance, p_TopBottom0)
	getPointer(instance).TopBottom = p_TopBottom0;
end
function abi.ffi.prop_get_fire_color(instance)
	return createPointer(getPointer(instance).Color);
end
function abi.ffi.prop_set_fire_color(instance, p_Color0)
	getPointer(instance).Color = getPointer(p_Color0);
end
function abi.ffi.prop_get_fire_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_fire_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_fire_heat(instance)
	return getPointer(instance).Heat;
end
function abi.ffi.prop_set_fire_heat(instance, p_Heat0)
	getPointer(instance).Heat = p_Heat0;
end
function abi.ffi.prop_get_fire_secondary_color(instance)
	return createPointer(getPointer(instance).SecondaryColor);
end
function abi.ffi.prop_set_fire_secondary_color(instance, p_SecondaryColor0)
	getPointer(instance).SecondaryColor = getPointer(p_SecondaryColor0);
end
function abi.ffi.prop_get_fire_size(instance)
	return getPointer(instance).Size;
end
function abi.ffi.prop_set_fire_size(instance, p_Size0)
	getPointer(instance).Size = p_Size0;
end
function abi.ffi.prop_get_fire_time_scale(instance)
	return getPointer(instance).TimeScale;
end
function abi.ffi.prop_set_fire_time_scale(instance, p_TimeScale0)
	getPointer(instance).TimeScale = p_TimeScale0;
end
function abi.ffi.prop_get_float_curve_length(instance)
	return getPointer(instance).Length;
end
function abi.ffi.dyn_fn_float_curve_get_key_at_index(instance, p_index0)
	return createPointer(getPointer(instance):GetKeyAtIndex(p_index0));
end
function abi.ffi.dyn_fn_float_curve_get_value_at_time(output, instance, p_time0)
	local value0 = getPointer(instance):GetValueAtTime(p_time0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and value0 or 0)
end
function abi.ffi.dyn_fn_float_curve_remove_key_at_index(instance, p_startingIndex0, p_count0)
	return getPointer(instance):RemoveKeyAtIndex(p_startingIndex0, p_count0);
end
function abi.ffi.prop_get_force_field_visible(instance)
	return getPointer(instance).Visible and 1 or 0;
end
function abi.ffi.prop_set_force_field_visible(instance, p_Visible0)
	getPointer(instance).Visible = p_Visible0 == 1;
end
function abi.ffi.prop_get_get_text_bounds_params_font(instance)
	return createPointer(getPointer(instance).Font);
end
function abi.ffi.prop_set_get_text_bounds_params_font(instance, p_Font0)
	getPointer(instance).Font = getPointer(p_Font0);
end
function abi.ffi.prop_get_get_text_bounds_params_size(instance)
	return getPointer(instance).Size;
end
function abi.ffi.prop_set_get_text_bounds_params_size(instance, p_Size0)
	getPointer(instance).Size = p_Size0;
end
function abi.ffi.prop_get_get_text_bounds_params_text(output, instance)
	local value0 = getPointer(instance).Text;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_get_text_bounds_params_text(instance, p_Text0, p_Text1)
	getPointer(instance).Text = loadString(memory, p_Text0, p_Text1);
end
function abi.ffi.prop_get_get_text_bounds_params_width(instance)
	return getPointer(instance).Width;
end
function abi.ffi.prop_set_get_text_bounds_params_width(instance, p_Width0)
	getPointer(instance).Width = p_Width0;
end
function abi.ffi.dyn_fn_data_store_list_keys_async(output, instance, p_prefix0, p_prefix1, p_pageSize0, p_cursor0, p_cursor1)
	local value0 = getPointer(instance):ListKeysAsync(loadString(memory, p_prefix0, p_prefix1), p_pageSize0, loadString(memory, p_cursor0, p_cursor1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_data_store_list_versions_async(output, instance, p_key0, p_key1, p_sortDirection0, p_minDate0, p_maxDate0, p_pageSize0)
	local value0 = getPointer(instance):ListVersionsAsync(loadString(memory, p_key0, p_key1), p_sortDirection0, p_minDate0, p_maxDate0, p_pageSize0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_data_store_remove_version_async(instance, p_key0, p_key1, p_version0, p_version1)
	return getPointer(instance):RemoveVersionAsync(loadString(memory, p_key0, p_key1), loadString(memory, p_version0, p_version1));
end
function abi.ffi.dyn_fn_ordered_data_store_get_sorted_async(output, instance, p_ascending0, p_pagesize0, p_minValue0, p_maxValue0)
	local value0 = getPointer(instance):GetSortedAsync(p_ascending0 == 1, p_pagesize0, getPointer(p_minValue0), getPointer(p_maxValue0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_group_service_get_allies_async(output, instance, p_groupId0)
	local value0 = getPointer(instance):GetAlliesAsync(p_groupId0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_group_service_get_enemies_async(output, instance, p_groupId0)
	local value0 = getPointer(instance):GetEnemiesAsync(p_groupId0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_group_service_get_group_info_async(instance, p_groupId0)
	return createPointer(getPointer(instance):GetGroupInfoAsync(p_groupId0));
end
function abi.ffi.prop_get_gui_base_2_d_absolute_position(instance)
	return createPointer(getPointer(instance).AbsolutePosition);
end
function abi.ffi.prop_get_gui_base_2_d_absolute_rotation(instance)
	return getPointer(instance).AbsoluteRotation;
end
function abi.ffi.prop_get_gui_base_2_d_absolute_size(instance)
	return createPointer(getPointer(instance).AbsoluteSize);
end
function abi.ffi.prop_get_gui_base_2_d_auto_localize(instance)
	return getPointer(instance).AutoLocalize and 1 or 0;
end
function abi.ffi.prop_set_gui_base_2_d_auto_localize(instance, p_AutoLocalize0)
	getPointer(instance).AutoLocalize = p_AutoLocalize0 == 1;
end
function abi.ffi.prop_get_gui_base_2_d_root_localization_table(output, instance)
	local value0 = getPointer(instance).RootLocalizationTable;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_gui_base_2_d_root_localization_table(instance, p_RootLocalizationTable0, p_RootLocalizationTable1)
	local value0;
	if p_RootLocalizationTable0 == 1 then
		value0 = getPointer(p_RootLocalizationTable1);
	end
	getPointer(instance).RootLocalizationTable = value0;
end
function abi.ffi.prop_get_gui_base_2_d_selection_behavior_down(instance)
	return (getPointer(instance).SelectionBehaviorDown).Value;
end
function abi.ffi.prop_set_gui_base_2_d_selection_behavior_down(instance, p_SelectionBehaviorDown0)
	getPointer(instance).SelectionBehaviorDown = p_SelectionBehaviorDown0;
end
function abi.ffi.prop_get_gui_base_2_d_selection_behavior_left(instance)
	return (getPointer(instance).SelectionBehaviorLeft).Value;
end
function abi.ffi.prop_set_gui_base_2_d_selection_behavior_left(instance, p_SelectionBehaviorLeft0)
	getPointer(instance).SelectionBehaviorLeft = p_SelectionBehaviorLeft0;
end
function abi.ffi.prop_get_gui_base_2_d_selection_behavior_right(instance)
	return (getPointer(instance).SelectionBehaviorRight).Value;
end
function abi.ffi.prop_set_gui_base_2_d_selection_behavior_right(instance, p_SelectionBehaviorRight0)
	getPointer(instance).SelectionBehaviorRight = p_SelectionBehaviorRight0;
end
function abi.ffi.prop_get_gui_base_2_d_selection_behavior_up(instance)
	return (getPointer(instance).SelectionBehaviorUp).Value;
end
function abi.ffi.prop_set_gui_base_2_d_selection_behavior_up(instance, p_SelectionBehaviorUp0)
	getPointer(instance).SelectionBehaviorUp = p_SelectionBehaviorUp0;
end
function abi.ffi.prop_get_gui_base_2_d_selection_group(instance)
	return getPointer(instance).SelectionGroup and 1 or 0;
end
function abi.ffi.prop_set_gui_base_2_d_selection_group(instance, p_SelectionGroup0)
	getPointer(instance).SelectionGroup = p_SelectionGroup0 == 1;
end
function abi.ffi.connect_gui_base_2_d_selection_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).SelectionChanged:Connect(function(p_amISelected, p_previousSelection, p_newSelection)
		local value0 = p_previousSelection;
		local value1 = p_newSelection;
		invokeFunction(data, vtable, p_amISelected and 1 or 0, value0 and 1 or 0, value0 and createPointer(value0) or 0, value1 and 1 or 0, value1 and createPointer(value1) or 0);
	end))
end
function abi.ffi.prop_get_gui_object_active(instance)
	return getPointer(instance).Active and 1 or 0;
end
function abi.ffi.prop_set_gui_object_active(instance, p_Active0)
	getPointer(instance).Active = p_Active0 == 1;
end
function abi.ffi.prop_get_gui_object_anchor_point(instance)
	return createPointer(getPointer(instance).AnchorPoint);
end
function abi.ffi.prop_set_gui_object_anchor_point(instance, p_AnchorPoint0)
	getPointer(instance).AnchorPoint = getPointer(p_AnchorPoint0);
end
function abi.ffi.prop_get_gui_object_automatic_size(instance)
	return (getPointer(instance).AutomaticSize).Value;
end
function abi.ffi.prop_set_gui_object_automatic_size(instance, p_AutomaticSize0)
	getPointer(instance).AutomaticSize = p_AutomaticSize0;
end
function abi.ffi.prop_get_gui_object_background_color_3(instance)
	return createPointer(getPointer(instance).BackgroundColor3);
end
function abi.ffi.prop_set_gui_object_background_color_3(instance, p_BackgroundColor30)
	getPointer(instance).BackgroundColor3 = getPointer(p_BackgroundColor30);
end
function abi.ffi.prop_get_gui_object_background_transparency(instance)
	return getPointer(instance).BackgroundTransparency;
end
function abi.ffi.prop_set_gui_object_background_transparency(instance, p_BackgroundTransparency0)
	getPointer(instance).BackgroundTransparency = p_BackgroundTransparency0;
end
function abi.ffi.prop_get_gui_object_border_color_3(instance)
	return createPointer(getPointer(instance).BorderColor3);
end
function abi.ffi.prop_set_gui_object_border_color_3(instance, p_BorderColor30)
	getPointer(instance).BorderColor3 = getPointer(p_BorderColor30);
end
function abi.ffi.prop_get_gui_object_border_mode(instance)
	return (getPointer(instance).BorderMode).Value;
end
function abi.ffi.prop_set_gui_object_border_mode(instance, p_BorderMode0)
	getPointer(instance).BorderMode = p_BorderMode0;
end
function abi.ffi.prop_get_gui_object_border_size_pixel(instance)
	return getPointer(instance).BorderSizePixel;
end
function abi.ffi.prop_set_gui_object_border_size_pixel(instance, p_BorderSizePixel0)
	getPointer(instance).BorderSizePixel = p_BorderSizePixel0;
end
function abi.ffi.prop_get_gui_object_clips_descendants(instance)
	return getPointer(instance).ClipsDescendants and 1 or 0;
end
function abi.ffi.prop_set_gui_object_clips_descendants(instance, p_ClipsDescendants0)
	getPointer(instance).ClipsDescendants = p_ClipsDescendants0 == 1;
end
function abi.ffi.prop_get_gui_object_layout_order(instance)
	return getPointer(instance).LayoutOrder;
end
function abi.ffi.prop_set_gui_object_layout_order(instance, p_LayoutOrder0)
	getPointer(instance).LayoutOrder = p_LayoutOrder0;
end
function abi.ffi.prop_get_gui_object_next_selection_down(output, instance)
	local value0 = getPointer(instance).NextSelectionDown;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_gui_object_next_selection_down(instance, p_NextSelectionDown0, p_NextSelectionDown1)
	local value0;
	if p_NextSelectionDown0 == 1 then
		value0 = getPointer(p_NextSelectionDown1);
	end
	getPointer(instance).NextSelectionDown = value0;
end
function abi.ffi.prop_get_gui_object_next_selection_left(output, instance)
	local value0 = getPointer(instance).NextSelectionLeft;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_gui_object_next_selection_left(instance, p_NextSelectionLeft0, p_NextSelectionLeft1)
	local value0;
	if p_NextSelectionLeft0 == 1 then
		value0 = getPointer(p_NextSelectionLeft1);
	end
	getPointer(instance).NextSelectionLeft = value0;
end
function abi.ffi.prop_get_gui_object_next_selection_right(output, instance)
	local value0 = getPointer(instance).NextSelectionRight;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_gui_object_next_selection_right(instance, p_NextSelectionRight0, p_NextSelectionRight1)
	local value0;
	if p_NextSelectionRight0 == 1 then
		value0 = getPointer(p_NextSelectionRight1);
	end
	getPointer(instance).NextSelectionRight = value0;
end
function abi.ffi.prop_get_gui_object_next_selection_up(output, instance)
	local value0 = getPointer(instance).NextSelectionUp;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_gui_object_next_selection_up(instance, p_NextSelectionUp0, p_NextSelectionUp1)
	local value0;
	if p_NextSelectionUp0 == 1 then
		value0 = getPointer(p_NextSelectionUp1);
	end
	getPointer(instance).NextSelectionUp = value0;
end
function abi.ffi.prop_get_gui_object_position(instance)
	return createPointer(getPointer(instance).Position);
end
function abi.ffi.prop_set_gui_object_position(instance, p_Position0)
	getPointer(instance).Position = getPointer(p_Position0);
end
function abi.ffi.prop_get_gui_object_rotation(instance)
	return getPointer(instance).Rotation;
end
function abi.ffi.prop_set_gui_object_rotation(instance, p_Rotation0)
	getPointer(instance).Rotation = p_Rotation0;
end
function abi.ffi.prop_get_gui_object_selectable(instance)
	return getPointer(instance).Selectable and 1 or 0;
end
function abi.ffi.prop_set_gui_object_selectable(instance, p_Selectable0)
	getPointer(instance).Selectable = p_Selectable0 == 1;
end
function abi.ffi.prop_get_gui_object_selection_image_object(output, instance)
	local value0 = getPointer(instance).SelectionImageObject;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_gui_object_selection_image_object(instance, p_SelectionImageObject0, p_SelectionImageObject1)
	local value0;
	if p_SelectionImageObject0 == 1 then
		value0 = getPointer(p_SelectionImageObject1);
	end
	getPointer(instance).SelectionImageObject = value0;
end
function abi.ffi.prop_get_gui_object_selection_order(instance)
	return getPointer(instance).SelectionOrder;
end
function abi.ffi.prop_set_gui_object_selection_order(instance, p_SelectionOrder0)
	getPointer(instance).SelectionOrder = p_SelectionOrder0;
end
function abi.ffi.prop_get_gui_object_size(instance)
	return createPointer(getPointer(instance).Size);
end
function abi.ffi.prop_set_gui_object_size(instance, p_Size0)
	getPointer(instance).Size = getPointer(p_Size0);
end
function abi.ffi.prop_get_gui_object_size_constraint(instance)
	return (getPointer(instance).SizeConstraint).Value;
end
function abi.ffi.prop_set_gui_object_size_constraint(instance, p_SizeConstraint0)
	getPointer(instance).SizeConstraint = p_SizeConstraint0;
end
function abi.ffi.prop_get_gui_object_transparency(instance)
	return getPointer(instance).Transparency;
end
function abi.ffi.prop_set_gui_object_transparency(instance, p_Transparency0)
	getPointer(instance).Transparency = p_Transparency0;
end
function abi.ffi.prop_get_gui_object_visible(instance)
	return getPointer(instance).Visible and 1 or 0;
end
function abi.ffi.prop_set_gui_object_visible(instance, p_Visible0)
	getPointer(instance).Visible = p_Visible0 == 1;
end
function abi.ffi.prop_get_gui_object_z_index(instance)
	return getPointer(instance).ZIndex;
end
function abi.ffi.prop_set_gui_object_z_index(instance, p_ZIndex0)
	getPointer(instance).ZIndex = p_ZIndex0;
end
function abi.ffi.connect_gui_object_input_began(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).InputBegan:Connect(function(p_input)
		local value0 = p_input;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_gui_object_input_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).InputChanged:Connect(function(p_input)
		local value0 = p_input;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_gui_object_input_ended(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).InputEnded:Connect(function(p_input)
		local value0 = p_input;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_gui_object_mouse_enter(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseEnter:Connect(function(p_x, p_y)
		invokeFunction(data, vtable, p_x, p_y);
	end))
end
function abi.ffi.connect_gui_object_mouse_leave(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseLeave:Connect(function(p_x, p_y)
		invokeFunction(data, vtable, p_x, p_y);
	end))
end
function abi.ffi.connect_gui_object_mouse_moved(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseMoved:Connect(function(p_x, p_y)
		invokeFunction(data, vtable, p_x, p_y);
	end))
end
function abi.ffi.connect_gui_object_mouse_wheel_backward(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseWheelBackward:Connect(function(p_x, p_y)
		invokeFunction(data, vtable, p_x, p_y);
	end))
end
function abi.ffi.connect_gui_object_mouse_wheel_forward(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseWheelForward:Connect(function(p_x, p_y)
		invokeFunction(data, vtable, p_x, p_y);
	end))
end
function abi.ffi.connect_gui_object_selection_gained(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).SelectionGained:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_gui_object_selection_lost(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).SelectionLost:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_gui_object_touch_swipe(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TouchSwipe:Connect(function(p_swipeDirection, p_numberOfTouches)
		invokeFunction(data, vtable, (p_swipeDirection).Value, p_numberOfTouches);
	end))
end
function abi.ffi.prop_get_canvas_group_group_color_3(instance)
	return createPointer(getPointer(instance).GroupColor3);
end
function abi.ffi.prop_set_canvas_group_group_color_3(instance, p_GroupColor30)
	getPointer(instance).GroupColor3 = getPointer(p_GroupColor30);
end
function abi.ffi.prop_get_canvas_group_group_transparency(instance)
	return getPointer(instance).GroupTransparency;
end
function abi.ffi.prop_set_canvas_group_group_transparency(instance, p_GroupTransparency0)
	getPointer(instance).GroupTransparency = p_GroupTransparency0;
end
function abi.ffi.prop_get_frame_style(instance)
	return (getPointer(instance).Style).Value;
end
function abi.ffi.prop_set_frame_style(instance, p_Style0)
	getPointer(instance).Style = p_Style0;
end
function abi.ffi.prop_get_gui_button_auto_button_color(instance)
	return getPointer(instance).AutoButtonColor and 1 or 0;
end
function abi.ffi.prop_set_gui_button_auto_button_color(instance, p_AutoButtonColor0)
	getPointer(instance).AutoButtonColor = p_AutoButtonColor0 == 1;
end
function abi.ffi.prop_get_gui_button_modal(instance)
	return getPointer(instance).Modal and 1 or 0;
end
function abi.ffi.prop_set_gui_button_modal(instance, p_Modal0)
	getPointer(instance).Modal = p_Modal0 == 1;
end
function abi.ffi.prop_get_gui_button_selected(instance)
	return getPointer(instance).Selected and 1 or 0;
end
function abi.ffi.prop_set_gui_button_selected(instance, p_Selected0)
	getPointer(instance).Selected = p_Selected0 == 1;
end
function abi.ffi.prop_get_gui_button_style(instance)
	return (getPointer(instance).Style).Value;
end
function abi.ffi.prop_set_gui_button_style(instance, p_Style0)
	getPointer(instance).Style = p_Style0;
end
function abi.ffi.connect_gui_button_activated(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Activated:Connect(function(p_inputObject, p_clickCount)
		local value0 = p_inputObject;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, p_clickCount);
	end))
end
function abi.ffi.connect_gui_button_mouse_button_1_click(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseButton1Click:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_gui_button_mouse_button_1_down(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseButton1Down:Connect(function(p_x, p_y)
		invokeFunction(data, vtable, p_x, p_y);
	end))
end
function abi.ffi.connect_gui_button_mouse_button_1_up(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseButton1Up:Connect(function(p_x, p_y)
		invokeFunction(data, vtable, p_x, p_y);
	end))
end
function abi.ffi.connect_gui_button_mouse_button_2_click(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseButton2Click:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_gui_button_mouse_button_2_down(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseButton2Down:Connect(function(p_x, p_y)
		invokeFunction(data, vtable, p_x, p_y);
	end))
end
function abi.ffi.connect_gui_button_mouse_button_2_up(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseButton2Up:Connect(function(p_x, p_y)
		invokeFunction(data, vtable, p_x, p_y);
	end))
end
function abi.ffi.prop_get_image_button_hover_image(instance)
	return createPointer(getPointer(instance).HoverImage);
end
function abi.ffi.prop_set_image_button_hover_image(instance, p_HoverImage0)
	getPointer(instance).HoverImage = getPointer(p_HoverImage0);
end
function abi.ffi.prop_get_image_button_image(instance)
	return createPointer(getPointer(instance).Image);
end
function abi.ffi.prop_set_image_button_image(instance, p_Image0)
	getPointer(instance).Image = getPointer(p_Image0);
end
function abi.ffi.prop_get_image_button_image_color_3(instance)
	return createPointer(getPointer(instance).ImageColor3);
end
function abi.ffi.prop_set_image_button_image_color_3(instance, p_ImageColor30)
	getPointer(instance).ImageColor3 = getPointer(p_ImageColor30);
end
function abi.ffi.prop_get_image_button_image_rect_offset(instance)
	return createPointer(getPointer(instance).ImageRectOffset);
end
function abi.ffi.prop_set_image_button_image_rect_offset(instance, p_ImageRectOffset0)
	getPointer(instance).ImageRectOffset = getPointer(p_ImageRectOffset0);
end
function abi.ffi.prop_get_image_button_image_rect_size(instance)
	return createPointer(getPointer(instance).ImageRectSize);
end
function abi.ffi.prop_set_image_button_image_rect_size(instance, p_ImageRectSize0)
	getPointer(instance).ImageRectSize = getPointer(p_ImageRectSize0);
end
function abi.ffi.prop_get_image_button_image_transparency(instance)
	return getPointer(instance).ImageTransparency;
end
function abi.ffi.prop_set_image_button_image_transparency(instance, p_ImageTransparency0)
	getPointer(instance).ImageTransparency = p_ImageTransparency0;
end
function abi.ffi.prop_get_image_button_is_loaded(instance)
	return getPointer(instance).IsLoaded and 1 or 0;
end
function abi.ffi.prop_get_image_button_pressed_image(instance)
	return createPointer(getPointer(instance).PressedImage);
end
function abi.ffi.prop_set_image_button_pressed_image(instance, p_PressedImage0)
	getPointer(instance).PressedImage = getPointer(p_PressedImage0);
end
function abi.ffi.prop_get_image_button_resample_mode(instance)
	return (getPointer(instance).ResampleMode).Value;
end
function abi.ffi.prop_set_image_button_resample_mode(instance, p_ResampleMode0)
	getPointer(instance).ResampleMode = p_ResampleMode0;
end
function abi.ffi.prop_get_image_button_scale_type(instance)
	return (getPointer(instance).ScaleType).Value;
end
function abi.ffi.prop_set_image_button_scale_type(instance, p_ScaleType0)
	getPointer(instance).ScaleType = p_ScaleType0;
end
function abi.ffi.prop_get_image_button_slice_center(instance)
	return createPointer(getPointer(instance).SliceCenter);
end
function abi.ffi.prop_set_image_button_slice_center(instance, p_SliceCenter0)
	getPointer(instance).SliceCenter = getPointer(p_SliceCenter0);
end
function abi.ffi.prop_get_image_button_slice_scale(instance)
	return getPointer(instance).SliceScale;
end
function abi.ffi.prop_set_image_button_slice_scale(instance, p_SliceScale0)
	getPointer(instance).SliceScale = p_SliceScale0;
end
function abi.ffi.prop_get_image_button_tile_size(instance)
	return createPointer(getPointer(instance).TileSize);
end
function abi.ffi.prop_set_image_button_tile_size(instance, p_TileSize0)
	getPointer(instance).TileSize = getPointer(p_TileSize0);
end
function abi.ffi.prop_get_text_button_content_text(output, instance)
	local value0 = getPointer(instance).ContentText;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_text_button_font(instance)
	return (getPointer(instance).Font).Value;
end
function abi.ffi.prop_set_text_button_font(instance, p_Font0)
	getPointer(instance).Font = p_Font0;
end
function abi.ffi.prop_get_text_button_font_face(instance)
	return createPointer(getPointer(instance).FontFace);
end
function abi.ffi.prop_set_text_button_font_face(instance, p_FontFace0)
	getPointer(instance).FontFace = getPointer(p_FontFace0);
end
function abi.ffi.prop_get_text_button_line_height(instance)
	return getPointer(instance).LineHeight;
end
function abi.ffi.prop_set_text_button_line_height(instance, p_LineHeight0)
	getPointer(instance).LineHeight = p_LineHeight0;
end
function abi.ffi.prop_get_text_button_localized_text(output, instance)
	local value0 = getPointer(instance).LocalizedText;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_text_button_max_visible_graphemes(instance)
	return getPointer(instance).MaxVisibleGraphemes;
end
function abi.ffi.prop_set_text_button_max_visible_graphemes(instance, p_MaxVisibleGraphemes0)
	getPointer(instance).MaxVisibleGraphemes = p_MaxVisibleGraphemes0;
end
function abi.ffi.prop_get_text_button_rich_text(instance)
	return getPointer(instance).RichText and 1 or 0;
end
function abi.ffi.prop_set_text_button_rich_text(instance, p_RichText0)
	getPointer(instance).RichText = p_RichText0 == 1;
end
function abi.ffi.prop_get_text_button_text(output, instance)
	local value0 = getPointer(instance).Text;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_text_button_text(instance, p_Text0, p_Text1)
	getPointer(instance).Text = loadString(memory, p_Text0, p_Text1);
end
function abi.ffi.prop_get_text_button_text_bounds(instance)
	return createPointer(getPointer(instance).TextBounds);
end
function abi.ffi.prop_get_text_button_text_color_3(instance)
	return createPointer(getPointer(instance).TextColor3);
end
function abi.ffi.prop_set_text_button_text_color_3(instance, p_TextColor30)
	getPointer(instance).TextColor3 = getPointer(p_TextColor30);
end
function abi.ffi.prop_get_text_button_text_fits(instance)
	return getPointer(instance).TextFits and 1 or 0;
end
function abi.ffi.prop_get_text_button_text_scaled(instance)
	return getPointer(instance).TextScaled and 1 or 0;
end
function abi.ffi.prop_set_text_button_text_scaled(instance, p_TextScaled0)
	getPointer(instance).TextScaled = p_TextScaled0 == 1;
end
function abi.ffi.prop_get_text_button_text_size(instance)
	return getPointer(instance).TextSize;
end
function abi.ffi.prop_set_text_button_text_size(instance, p_TextSize0)
	getPointer(instance).TextSize = p_TextSize0;
end
function abi.ffi.prop_get_text_button_text_stroke_color_3(instance)
	return createPointer(getPointer(instance).TextStrokeColor3);
end
function abi.ffi.prop_set_text_button_text_stroke_color_3(instance, p_TextStrokeColor30)
	getPointer(instance).TextStrokeColor3 = getPointer(p_TextStrokeColor30);
end
function abi.ffi.prop_get_text_button_text_stroke_transparency(instance)
	return getPointer(instance).TextStrokeTransparency;
end
function abi.ffi.prop_set_text_button_text_stroke_transparency(instance, p_TextStrokeTransparency0)
	getPointer(instance).TextStrokeTransparency = p_TextStrokeTransparency0;
end
function abi.ffi.prop_get_text_button_text_transparency(instance)
	return getPointer(instance).TextTransparency;
end
function abi.ffi.prop_set_text_button_text_transparency(instance, p_TextTransparency0)
	getPointer(instance).TextTransparency = p_TextTransparency0;
end
function abi.ffi.prop_get_text_button_text_truncate(instance)
	return (getPointer(instance).TextTruncate).Value;
end
function abi.ffi.prop_set_text_button_text_truncate(instance, p_TextTruncate0)
	getPointer(instance).TextTruncate = p_TextTruncate0;
end
function abi.ffi.prop_get_text_button_text_wrapped(instance)
	return getPointer(instance).TextWrapped and 1 or 0;
end
function abi.ffi.prop_set_text_button_text_wrapped(instance, p_TextWrapped0)
	getPointer(instance).TextWrapped = p_TextWrapped0 == 1;
end
function abi.ffi.prop_get_text_button_text_x_alignment(instance)
	return (getPointer(instance).TextXAlignment).Value;
end
function abi.ffi.prop_set_text_button_text_x_alignment(instance, p_TextXAlignment0)
	getPointer(instance).TextXAlignment = p_TextXAlignment0;
end
function abi.ffi.prop_get_text_button_text_y_alignment(instance)
	return (getPointer(instance).TextYAlignment).Value;
end
function abi.ffi.prop_set_text_button_text_y_alignment(instance, p_TextYAlignment0)
	getPointer(instance).TextYAlignment = p_TextYAlignment0;
end
function abi.ffi.prop_get_image_label_image(instance)
	return createPointer(getPointer(instance).Image);
end
function abi.ffi.prop_set_image_label_image(instance, p_Image0)
	getPointer(instance).Image = getPointer(p_Image0);
end
function abi.ffi.prop_get_image_label_image_color_3(instance)
	return createPointer(getPointer(instance).ImageColor3);
end
function abi.ffi.prop_set_image_label_image_color_3(instance, p_ImageColor30)
	getPointer(instance).ImageColor3 = getPointer(p_ImageColor30);
end
function abi.ffi.prop_get_image_label_image_rect_offset(instance)
	return createPointer(getPointer(instance).ImageRectOffset);
end
function abi.ffi.prop_set_image_label_image_rect_offset(instance, p_ImageRectOffset0)
	getPointer(instance).ImageRectOffset = getPointer(p_ImageRectOffset0);
end
function abi.ffi.prop_get_image_label_image_rect_size(instance)
	return createPointer(getPointer(instance).ImageRectSize);
end
function abi.ffi.prop_set_image_label_image_rect_size(instance, p_ImageRectSize0)
	getPointer(instance).ImageRectSize = getPointer(p_ImageRectSize0);
end
function abi.ffi.prop_get_image_label_image_transparency(instance)
	return getPointer(instance).ImageTransparency;
end
function abi.ffi.prop_set_image_label_image_transparency(instance, p_ImageTransparency0)
	getPointer(instance).ImageTransparency = p_ImageTransparency0;
end
function abi.ffi.prop_get_image_label_is_loaded(instance)
	return getPointer(instance).IsLoaded and 1 or 0;
end
function abi.ffi.prop_get_image_label_resample_mode(instance)
	return (getPointer(instance).ResampleMode).Value;
end
function abi.ffi.prop_set_image_label_resample_mode(instance, p_ResampleMode0)
	getPointer(instance).ResampleMode = p_ResampleMode0;
end
function abi.ffi.prop_get_image_label_scale_type(instance)
	return (getPointer(instance).ScaleType).Value;
end
function abi.ffi.prop_set_image_label_scale_type(instance, p_ScaleType0)
	getPointer(instance).ScaleType = p_ScaleType0;
end
function abi.ffi.prop_get_image_label_slice_center(instance)
	return createPointer(getPointer(instance).SliceCenter);
end
function abi.ffi.prop_set_image_label_slice_center(instance, p_SliceCenter0)
	getPointer(instance).SliceCenter = getPointer(p_SliceCenter0);
end
function abi.ffi.prop_get_image_label_slice_scale(instance)
	return getPointer(instance).SliceScale;
end
function abi.ffi.prop_set_image_label_slice_scale(instance, p_SliceScale0)
	getPointer(instance).SliceScale = p_SliceScale0;
end
function abi.ffi.prop_get_image_label_tile_size(instance)
	return createPointer(getPointer(instance).TileSize);
end
function abi.ffi.prop_set_image_label_tile_size(instance, p_TileSize0)
	getPointer(instance).TileSize = getPointer(p_TileSize0);
end
function abi.ffi.prop_get_text_label_content_text(output, instance)
	local value0 = getPointer(instance).ContentText;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_text_label_font(instance)
	return (getPointer(instance).Font).Value;
end
function abi.ffi.prop_set_text_label_font(instance, p_Font0)
	getPointer(instance).Font = p_Font0;
end
function abi.ffi.prop_get_text_label_font_face(instance)
	return createPointer(getPointer(instance).FontFace);
end
function abi.ffi.prop_set_text_label_font_face(instance, p_FontFace0)
	getPointer(instance).FontFace = getPointer(p_FontFace0);
end
function abi.ffi.prop_get_text_label_line_height(instance)
	return getPointer(instance).LineHeight;
end
function abi.ffi.prop_set_text_label_line_height(instance, p_LineHeight0)
	getPointer(instance).LineHeight = p_LineHeight0;
end
function abi.ffi.prop_get_text_label_localized_text(output, instance)
	local value0 = getPointer(instance).LocalizedText;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_text_label_max_visible_graphemes(instance)
	return getPointer(instance).MaxVisibleGraphemes;
end
function abi.ffi.prop_set_text_label_max_visible_graphemes(instance, p_MaxVisibleGraphemes0)
	getPointer(instance).MaxVisibleGraphemes = p_MaxVisibleGraphemes0;
end
function abi.ffi.prop_get_text_label_rich_text(instance)
	return getPointer(instance).RichText and 1 or 0;
end
function abi.ffi.prop_set_text_label_rich_text(instance, p_RichText0)
	getPointer(instance).RichText = p_RichText0 == 1;
end
function abi.ffi.prop_get_text_label_text(output, instance)
	local value0 = getPointer(instance).Text;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_text_label_text(instance, p_Text0, p_Text1)
	getPointer(instance).Text = loadString(memory, p_Text0, p_Text1);
end
function abi.ffi.prop_get_text_label_text_bounds(instance)
	return createPointer(getPointer(instance).TextBounds);
end
function abi.ffi.prop_get_text_label_text_color_3(instance)
	return createPointer(getPointer(instance).TextColor3);
end
function abi.ffi.prop_set_text_label_text_color_3(instance, p_TextColor30)
	getPointer(instance).TextColor3 = getPointer(p_TextColor30);
end
function abi.ffi.prop_get_text_label_text_fits(instance)
	return getPointer(instance).TextFits and 1 or 0;
end
function abi.ffi.prop_get_text_label_text_scaled(instance)
	return getPointer(instance).TextScaled and 1 or 0;
end
function abi.ffi.prop_set_text_label_text_scaled(instance, p_TextScaled0)
	getPointer(instance).TextScaled = p_TextScaled0 == 1;
end
function abi.ffi.prop_get_text_label_text_size(instance)
	return getPointer(instance).TextSize;
end
function abi.ffi.prop_set_text_label_text_size(instance, p_TextSize0)
	getPointer(instance).TextSize = p_TextSize0;
end
function abi.ffi.prop_get_text_label_text_stroke_color_3(instance)
	return createPointer(getPointer(instance).TextStrokeColor3);
end
function abi.ffi.prop_set_text_label_text_stroke_color_3(instance, p_TextStrokeColor30)
	getPointer(instance).TextStrokeColor3 = getPointer(p_TextStrokeColor30);
end
function abi.ffi.prop_get_text_label_text_stroke_transparency(instance)
	return getPointer(instance).TextStrokeTransparency;
end
function abi.ffi.prop_set_text_label_text_stroke_transparency(instance, p_TextStrokeTransparency0)
	getPointer(instance).TextStrokeTransparency = p_TextStrokeTransparency0;
end
function abi.ffi.prop_get_text_label_text_transparency(instance)
	return getPointer(instance).TextTransparency;
end
function abi.ffi.prop_set_text_label_text_transparency(instance, p_TextTransparency0)
	getPointer(instance).TextTransparency = p_TextTransparency0;
end
function abi.ffi.prop_get_text_label_text_truncate(instance)
	return (getPointer(instance).TextTruncate).Value;
end
function abi.ffi.prop_set_text_label_text_truncate(instance, p_TextTruncate0)
	getPointer(instance).TextTruncate = p_TextTruncate0;
end
function abi.ffi.prop_get_text_label_text_wrapped(instance)
	return getPointer(instance).TextWrapped and 1 or 0;
end
function abi.ffi.prop_set_text_label_text_wrapped(instance, p_TextWrapped0)
	getPointer(instance).TextWrapped = p_TextWrapped0 == 1;
end
function abi.ffi.prop_get_text_label_text_x_alignment(instance)
	return (getPointer(instance).TextXAlignment).Value;
end
function abi.ffi.prop_set_text_label_text_x_alignment(instance, p_TextXAlignment0)
	getPointer(instance).TextXAlignment = p_TextXAlignment0;
end
function abi.ffi.prop_get_text_label_text_y_alignment(instance)
	return (getPointer(instance).TextYAlignment).Value;
end
function abi.ffi.prop_set_text_label_text_y_alignment(instance, p_TextYAlignment0)
	getPointer(instance).TextYAlignment = p_TextYAlignment0;
end
function abi.ffi.prop_get_scrolling_frame_absolute_canvas_size(instance)
	return createPointer(getPointer(instance).AbsoluteCanvasSize);
end
function abi.ffi.prop_get_scrolling_frame_absolute_window_size(instance)
	return createPointer(getPointer(instance).AbsoluteWindowSize);
end
function abi.ffi.prop_get_scrolling_frame_automatic_canvas_size(instance)
	return (getPointer(instance).AutomaticCanvasSize).Value;
end
function abi.ffi.prop_set_scrolling_frame_automatic_canvas_size(instance, p_AutomaticCanvasSize0)
	getPointer(instance).AutomaticCanvasSize = p_AutomaticCanvasSize0;
end
function abi.ffi.prop_get_scrolling_frame_bottom_image(instance)
	return createPointer(getPointer(instance).BottomImage);
end
function abi.ffi.prop_set_scrolling_frame_bottom_image(instance, p_BottomImage0)
	getPointer(instance).BottomImage = getPointer(p_BottomImage0);
end
function abi.ffi.prop_get_scrolling_frame_canvas_position(instance)
	return createPointer(getPointer(instance).CanvasPosition);
end
function abi.ffi.prop_set_scrolling_frame_canvas_position(instance, p_CanvasPosition0)
	getPointer(instance).CanvasPosition = getPointer(p_CanvasPosition0);
end
function abi.ffi.prop_get_scrolling_frame_canvas_size(instance)
	return createPointer(getPointer(instance).CanvasSize);
end
function abi.ffi.prop_set_scrolling_frame_canvas_size(instance, p_CanvasSize0)
	getPointer(instance).CanvasSize = getPointer(p_CanvasSize0);
end
function abi.ffi.prop_get_scrolling_frame_elastic_behavior(instance)
	return (getPointer(instance).ElasticBehavior).Value;
end
function abi.ffi.prop_set_scrolling_frame_elastic_behavior(instance, p_ElasticBehavior0)
	getPointer(instance).ElasticBehavior = p_ElasticBehavior0;
end
function abi.ffi.prop_get_scrolling_frame_horizontal_scroll_bar_inset(instance)
	return (getPointer(instance).HorizontalScrollBarInset).Value;
end
function abi.ffi.prop_set_scrolling_frame_horizontal_scroll_bar_inset(instance, p_HorizontalScrollBarInset0)
	getPointer(instance).HorizontalScrollBarInset = p_HorizontalScrollBarInset0;
end
function abi.ffi.prop_get_scrolling_frame_mid_image(instance)
	return createPointer(getPointer(instance).MidImage);
end
function abi.ffi.prop_set_scrolling_frame_mid_image(instance, p_MidImage0)
	getPointer(instance).MidImage = getPointer(p_MidImage0);
end
function abi.ffi.prop_get_scrolling_frame_scroll_bar_image_color_3(instance)
	return createPointer(getPointer(instance).ScrollBarImageColor3);
end
function abi.ffi.prop_set_scrolling_frame_scroll_bar_image_color_3(instance, p_ScrollBarImageColor30)
	getPointer(instance).ScrollBarImageColor3 = getPointer(p_ScrollBarImageColor30);
end
function abi.ffi.prop_get_scrolling_frame_scroll_bar_image_transparency(instance)
	return getPointer(instance).ScrollBarImageTransparency;
end
function abi.ffi.prop_set_scrolling_frame_scroll_bar_image_transparency(instance, p_ScrollBarImageTransparency0)
	getPointer(instance).ScrollBarImageTransparency = p_ScrollBarImageTransparency0;
end
function abi.ffi.prop_get_scrolling_frame_scroll_bar_thickness(instance)
	return getPointer(instance).ScrollBarThickness;
end
function abi.ffi.prop_set_scrolling_frame_scroll_bar_thickness(instance, p_ScrollBarThickness0)
	getPointer(instance).ScrollBarThickness = p_ScrollBarThickness0;
end
function abi.ffi.prop_get_scrolling_frame_scrolling_direction(instance)
	return (getPointer(instance).ScrollingDirection).Value;
end
function abi.ffi.prop_set_scrolling_frame_scrolling_direction(instance, p_ScrollingDirection0)
	getPointer(instance).ScrollingDirection = p_ScrollingDirection0;
end
function abi.ffi.prop_get_scrolling_frame_scrolling_enabled(instance)
	return getPointer(instance).ScrollingEnabled and 1 or 0;
end
function abi.ffi.prop_set_scrolling_frame_scrolling_enabled(instance, p_ScrollingEnabled0)
	getPointer(instance).ScrollingEnabled = p_ScrollingEnabled0 == 1;
end
function abi.ffi.prop_get_scrolling_frame_top_image(instance)
	return createPointer(getPointer(instance).TopImage);
end
function abi.ffi.prop_set_scrolling_frame_top_image(instance, p_TopImage0)
	getPointer(instance).TopImage = getPointer(p_TopImage0);
end
function abi.ffi.prop_get_scrolling_frame_vertical_scroll_bar_inset(instance)
	return (getPointer(instance).VerticalScrollBarInset).Value;
end
function abi.ffi.prop_set_scrolling_frame_vertical_scroll_bar_inset(instance, p_VerticalScrollBarInset0)
	getPointer(instance).VerticalScrollBarInset = p_VerticalScrollBarInset0;
end
function abi.ffi.prop_get_scrolling_frame_vertical_scroll_bar_position(instance)
	return (getPointer(instance).VerticalScrollBarPosition).Value;
end
function abi.ffi.prop_set_scrolling_frame_vertical_scroll_bar_position(instance, p_VerticalScrollBarPosition0)
	getPointer(instance).VerticalScrollBarPosition = p_VerticalScrollBarPosition0;
end
function abi.ffi.prop_get_text_box_clear_text_on_focus(instance)
	return getPointer(instance).ClearTextOnFocus and 1 or 0;
end
function abi.ffi.prop_set_text_box_clear_text_on_focus(instance, p_ClearTextOnFocus0)
	getPointer(instance).ClearTextOnFocus = p_ClearTextOnFocus0 == 1;
end
function abi.ffi.prop_get_text_box_content_text(output, instance)
	local value0 = getPointer(instance).ContentText;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_text_box_cursor_position(instance)
	return getPointer(instance).CursorPosition;
end
function abi.ffi.prop_set_text_box_cursor_position(instance, p_CursorPosition0)
	getPointer(instance).CursorPosition = p_CursorPosition0;
end
function abi.ffi.prop_get_text_box_font(instance)
	return (getPointer(instance).Font).Value;
end
function abi.ffi.prop_set_text_box_font(instance, p_Font0)
	getPointer(instance).Font = p_Font0;
end
function abi.ffi.prop_get_text_box_font_face(instance)
	return createPointer(getPointer(instance).FontFace);
end
function abi.ffi.prop_set_text_box_font_face(instance, p_FontFace0)
	getPointer(instance).FontFace = getPointer(p_FontFace0);
end
function abi.ffi.prop_get_text_box_line_height(instance)
	return getPointer(instance).LineHeight;
end
function abi.ffi.prop_set_text_box_line_height(instance, p_LineHeight0)
	getPointer(instance).LineHeight = p_LineHeight0;
end
function abi.ffi.prop_get_text_box_max_visible_graphemes(instance)
	return getPointer(instance).MaxVisibleGraphemes;
end
function abi.ffi.prop_set_text_box_max_visible_graphemes(instance, p_MaxVisibleGraphemes0)
	getPointer(instance).MaxVisibleGraphemes = p_MaxVisibleGraphemes0;
end
function abi.ffi.prop_get_text_box_multi_line(instance)
	return getPointer(instance).MultiLine and 1 or 0;
end
function abi.ffi.prop_set_text_box_multi_line(instance, p_MultiLine0)
	getPointer(instance).MultiLine = p_MultiLine0 == 1;
end
function abi.ffi.prop_get_text_box_placeholder_color_3(instance)
	return createPointer(getPointer(instance).PlaceholderColor3);
end
function abi.ffi.prop_set_text_box_placeholder_color_3(instance, p_PlaceholderColor30)
	getPointer(instance).PlaceholderColor3 = getPointer(p_PlaceholderColor30);
end
function abi.ffi.prop_get_text_box_placeholder_text(output, instance)
	local value0 = getPointer(instance).PlaceholderText;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_text_box_placeholder_text(instance, p_PlaceholderText0, p_PlaceholderText1)
	getPointer(instance).PlaceholderText = loadString(memory, p_PlaceholderText0, p_PlaceholderText1);
end
function abi.ffi.prop_get_text_box_rich_text(instance)
	return getPointer(instance).RichText and 1 or 0;
end
function abi.ffi.prop_set_text_box_rich_text(instance, p_RichText0)
	getPointer(instance).RichText = p_RichText0 == 1;
end
function abi.ffi.prop_get_text_box_selection_start(instance)
	return getPointer(instance).SelectionStart;
end
function abi.ffi.prop_set_text_box_selection_start(instance, p_SelectionStart0)
	getPointer(instance).SelectionStart = p_SelectionStart0;
end
function abi.ffi.prop_get_text_box_show_native_input(instance)
	return getPointer(instance).ShowNativeInput and 1 or 0;
end
function abi.ffi.prop_set_text_box_show_native_input(instance, p_ShowNativeInput0)
	getPointer(instance).ShowNativeInput = p_ShowNativeInput0 == 1;
end
function abi.ffi.prop_get_text_box_text(output, instance)
	local value0 = getPointer(instance).Text;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_text_box_text(instance, p_Text0, p_Text1)
	getPointer(instance).Text = loadString(memory, p_Text0, p_Text1);
end
function abi.ffi.prop_get_text_box_text_bounds(instance)
	return createPointer(getPointer(instance).TextBounds);
end
function abi.ffi.prop_get_text_box_text_color_3(instance)
	return createPointer(getPointer(instance).TextColor3);
end
function abi.ffi.prop_set_text_box_text_color_3(instance, p_TextColor30)
	getPointer(instance).TextColor3 = getPointer(p_TextColor30);
end
function abi.ffi.prop_get_text_box_text_editable(instance)
	return getPointer(instance).TextEditable and 1 or 0;
end
function abi.ffi.prop_set_text_box_text_editable(instance, p_TextEditable0)
	getPointer(instance).TextEditable = p_TextEditable0 == 1;
end
function abi.ffi.prop_get_text_box_text_fits(instance)
	return getPointer(instance).TextFits and 1 or 0;
end
function abi.ffi.prop_get_text_box_text_scaled(instance)
	return getPointer(instance).TextScaled and 1 or 0;
end
function abi.ffi.prop_set_text_box_text_scaled(instance, p_TextScaled0)
	getPointer(instance).TextScaled = p_TextScaled0 == 1;
end
function abi.ffi.prop_get_text_box_text_size(instance)
	return getPointer(instance).TextSize;
end
function abi.ffi.prop_set_text_box_text_size(instance, p_TextSize0)
	getPointer(instance).TextSize = p_TextSize0;
end
function abi.ffi.prop_get_text_box_text_stroke_color_3(instance)
	return createPointer(getPointer(instance).TextStrokeColor3);
end
function abi.ffi.prop_set_text_box_text_stroke_color_3(instance, p_TextStrokeColor30)
	getPointer(instance).TextStrokeColor3 = getPointer(p_TextStrokeColor30);
end
function abi.ffi.prop_get_text_box_text_stroke_transparency(instance)
	return getPointer(instance).TextStrokeTransparency;
end
function abi.ffi.prop_set_text_box_text_stroke_transparency(instance, p_TextStrokeTransparency0)
	getPointer(instance).TextStrokeTransparency = p_TextStrokeTransparency0;
end
function abi.ffi.prop_get_text_box_text_transparency(instance)
	return getPointer(instance).TextTransparency;
end
function abi.ffi.prop_set_text_box_text_transparency(instance, p_TextTransparency0)
	getPointer(instance).TextTransparency = p_TextTransparency0;
end
function abi.ffi.prop_get_text_box_text_truncate(instance)
	return (getPointer(instance).TextTruncate).Value;
end
function abi.ffi.prop_set_text_box_text_truncate(instance, p_TextTruncate0)
	getPointer(instance).TextTruncate = p_TextTruncate0;
end
function abi.ffi.prop_get_text_box_text_wrapped(instance)
	return getPointer(instance).TextWrapped and 1 or 0;
end
function abi.ffi.prop_set_text_box_text_wrapped(instance, p_TextWrapped0)
	getPointer(instance).TextWrapped = p_TextWrapped0 == 1;
end
function abi.ffi.prop_get_text_box_text_x_alignment(instance)
	return (getPointer(instance).TextXAlignment).Value;
end
function abi.ffi.prop_set_text_box_text_x_alignment(instance, p_TextXAlignment0)
	getPointer(instance).TextXAlignment = p_TextXAlignment0;
end
function abi.ffi.prop_get_text_box_text_y_alignment(instance)
	return (getPointer(instance).TextYAlignment).Value;
end
function abi.ffi.prop_set_text_box_text_y_alignment(instance, p_TextYAlignment0)
	getPointer(instance).TextYAlignment = p_TextYAlignment0;
end
function abi.ffi.dyn_fn_text_box_capture_focus(instance)
	return getPointer(instance):CaptureFocus();
end
function abi.ffi.dyn_fn_text_box_is_focused(instance)
	return getPointer(instance):IsFocused() and 1 or 0;
end
function abi.ffi.dyn_fn_text_box_release_focus(instance, p_submitted0)
	return getPointer(instance):ReleaseFocus(p_submitted0 == 1);
end
function abi.ffi.connect_text_box_focus_lost(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).FocusLost:Connect(function(p_enterPressed, p_inputThatCausedFocusLoss)
		local value0 = p_inputThatCausedFocusLoss;
		invokeFunction(data, vtable, p_enterPressed and 1 or 0, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_text_box_focused(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Focused:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_text_box_return_pressed_from_on_screen_keyboard(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).ReturnPressedFromOnScreenKeyboard:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.prop_get_video_frame_is_loaded(instance)
	return getPointer(instance).IsLoaded and 1 or 0;
end
function abi.ffi.prop_get_video_frame_looped(instance)
	return getPointer(instance).Looped and 1 or 0;
end
function abi.ffi.prop_set_video_frame_looped(instance, p_Looped0)
	getPointer(instance).Looped = p_Looped0 == 1;
end
function abi.ffi.prop_get_video_frame_playing(instance)
	return getPointer(instance).Playing and 1 or 0;
end
function abi.ffi.prop_set_video_frame_playing(instance, p_Playing0)
	getPointer(instance).Playing = p_Playing0 == 1;
end
function abi.ffi.prop_get_video_frame_resolution(instance)
	return createPointer(getPointer(instance).Resolution);
end
function abi.ffi.prop_get_video_frame_time_length(instance)
	return getPointer(instance).TimeLength;
end
function abi.ffi.prop_get_video_frame_time_position(instance)
	return getPointer(instance).TimePosition;
end
function abi.ffi.prop_set_video_frame_time_position(instance, p_TimePosition0)
	getPointer(instance).TimePosition = p_TimePosition0;
end
function abi.ffi.prop_get_video_frame_video(instance)
	return createPointer(getPointer(instance).Video);
end
function abi.ffi.prop_set_video_frame_video(instance, p_Video0)
	getPointer(instance).Video = getPointer(p_Video0);
end
function abi.ffi.prop_get_video_frame_volume(instance)
	return getPointer(instance).Volume;
end
function abi.ffi.prop_set_video_frame_volume(instance, p_Volume0)
	getPointer(instance).Volume = p_Volume0;
end
function abi.ffi.dyn_fn_video_frame_pause(instance)
	return getPointer(instance):Pause();
end
function abi.ffi.dyn_fn_video_frame_play(instance)
	return getPointer(instance):Play();
end
function abi.ffi.connect_video_frame_did_loop(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).DidLoop:Connect(function(p_video)
		local value0 = p_video;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.connect_video_frame_ended(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Ended:Connect(function(p_video)
		local value0 = p_video;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.connect_video_frame_loaded(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Loaded:Connect(function(p_video)
		local value0 = p_video;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.connect_video_frame_paused(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Paused:Connect(function(p_video)
		local value0 = p_video;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.connect_video_frame_played(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Played:Connect(function(p_video)
		local value0 = p_video;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.prop_get_viewport_frame_ambient(instance)
	return createPointer(getPointer(instance).Ambient);
end
function abi.ffi.prop_set_viewport_frame_ambient(instance, p_Ambient0)
	getPointer(instance).Ambient = getPointer(p_Ambient0);
end
function abi.ffi.prop_get_viewport_frame_current_camera(output, instance)
	local value0 = getPointer(instance).CurrentCamera;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_viewport_frame_current_camera(instance, p_CurrentCamera0, p_CurrentCamera1)
	local value0;
	if p_CurrentCamera0 == 1 then
		value0 = getPointer(p_CurrentCamera1);
	end
	getPointer(instance).CurrentCamera = value0;
end
function abi.ffi.prop_get_viewport_frame_image_color_3(instance)
	return createPointer(getPointer(instance).ImageColor3);
end
function abi.ffi.prop_set_viewport_frame_image_color_3(instance, p_ImageColor30)
	getPointer(instance).ImageColor3 = getPointer(p_ImageColor30);
end
function abi.ffi.prop_get_viewport_frame_image_transparency(instance)
	return getPointer(instance).ImageTransparency;
end
function abi.ffi.prop_set_viewport_frame_image_transparency(instance, p_ImageTransparency0)
	getPointer(instance).ImageTransparency = p_ImageTransparency0;
end
function abi.ffi.prop_get_viewport_frame_light_color(instance)
	return createPointer(getPointer(instance).LightColor);
end
function abi.ffi.prop_set_viewport_frame_light_color(instance, p_LightColor0)
	getPointer(instance).LightColor = getPointer(p_LightColor0);
end
function abi.ffi.prop_get_viewport_frame_light_direction(instance)
	return createPointer(getPointer(instance).LightDirection);
end
function abi.ffi.prop_set_viewport_frame_light_direction(instance, p_LightDirection0)
	getPointer(instance).LightDirection = getPointer(p_LightDirection0);
end
function abi.ffi.prop_get_layer_collector_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_layer_collector_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_layer_collector_reset_on_spawn(instance)
	return getPointer(instance).ResetOnSpawn and 1 or 0;
end
function abi.ffi.prop_set_layer_collector_reset_on_spawn(instance, p_ResetOnSpawn0)
	getPointer(instance).ResetOnSpawn = p_ResetOnSpawn0 == 1;
end
function abi.ffi.prop_get_layer_collector_z_index_behavior(instance)
	return (getPointer(instance).ZIndexBehavior).Value;
end
function abi.ffi.prop_set_layer_collector_z_index_behavior(instance, p_ZIndexBehavior0)
	getPointer(instance).ZIndexBehavior = p_ZIndexBehavior0;
end
function abi.ffi.prop_get_billboard_gui_active(instance)
	return getPointer(instance).Active and 1 or 0;
end
function abi.ffi.prop_set_billboard_gui_active(instance, p_Active0)
	getPointer(instance).Active = p_Active0 == 1;
end
function abi.ffi.prop_get_billboard_gui_adornee(output, instance)
	local value0 = getPointer(instance).Adornee;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_billboard_gui_adornee(instance, p_Adornee0, p_Adornee1)
	local value0;
	if p_Adornee0 == 1 then
		value0 = getPointer(p_Adornee1);
	end
	getPointer(instance).Adornee = value0;
end
function abi.ffi.prop_get_billboard_gui_always_on_top(instance)
	return getPointer(instance).AlwaysOnTop and 1 or 0;
end
function abi.ffi.prop_set_billboard_gui_always_on_top(instance, p_AlwaysOnTop0)
	getPointer(instance).AlwaysOnTop = p_AlwaysOnTop0 == 1;
end
function abi.ffi.prop_get_billboard_gui_brightness(instance)
	return getPointer(instance).Brightness;
end
function abi.ffi.prop_set_billboard_gui_brightness(instance, p_Brightness0)
	getPointer(instance).Brightness = p_Brightness0;
end
function abi.ffi.prop_get_billboard_gui_clips_descendants(instance)
	return getPointer(instance).ClipsDescendants and 1 or 0;
end
function abi.ffi.prop_set_billboard_gui_clips_descendants(instance, p_ClipsDescendants0)
	getPointer(instance).ClipsDescendants = p_ClipsDescendants0 == 1;
end
function abi.ffi.prop_get_billboard_gui_current_distance(instance)
	return getPointer(instance).CurrentDistance;
end
function abi.ffi.prop_get_billboard_gui_distance_lower_limit(instance)
	return getPointer(instance).DistanceLowerLimit;
end
function abi.ffi.prop_set_billboard_gui_distance_lower_limit(instance, p_DistanceLowerLimit0)
	getPointer(instance).DistanceLowerLimit = p_DistanceLowerLimit0;
end
function abi.ffi.prop_get_billboard_gui_distance_step(instance)
	return getPointer(instance).DistanceStep;
end
function abi.ffi.prop_set_billboard_gui_distance_step(instance, p_DistanceStep0)
	getPointer(instance).DistanceStep = p_DistanceStep0;
end
function abi.ffi.prop_get_billboard_gui_distance_upper_limit(instance)
	return getPointer(instance).DistanceUpperLimit;
end
function abi.ffi.prop_set_billboard_gui_distance_upper_limit(instance, p_DistanceUpperLimit0)
	getPointer(instance).DistanceUpperLimit = p_DistanceUpperLimit0;
end
function abi.ffi.prop_get_billboard_gui_extents_offset(instance)
	return createPointer(getPointer(instance).ExtentsOffset);
end
function abi.ffi.prop_set_billboard_gui_extents_offset(instance, p_ExtentsOffset0)
	getPointer(instance).ExtentsOffset = getPointer(p_ExtentsOffset0);
end
function abi.ffi.prop_get_billboard_gui_extents_offset_world_space(instance)
	return createPointer(getPointer(instance).ExtentsOffsetWorldSpace);
end
function abi.ffi.prop_set_billboard_gui_extents_offset_world_space(instance, p_ExtentsOffsetWorldSpace0)
	getPointer(instance).ExtentsOffsetWorldSpace = getPointer(p_ExtentsOffsetWorldSpace0);
end
function abi.ffi.prop_get_billboard_gui_light_influence(instance)
	return getPointer(instance).LightInfluence;
end
function abi.ffi.prop_set_billboard_gui_light_influence(instance, p_LightInfluence0)
	getPointer(instance).LightInfluence = p_LightInfluence0;
end
function abi.ffi.prop_get_billboard_gui_max_distance(instance)
	return getPointer(instance).MaxDistance;
end
function abi.ffi.prop_set_billboard_gui_max_distance(instance, p_MaxDistance0)
	getPointer(instance).MaxDistance = p_MaxDistance0;
end
function abi.ffi.prop_get_billboard_gui_player_to_hide_from(output, instance)
	local value0 = getPointer(instance).PlayerToHideFrom;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_billboard_gui_player_to_hide_from(instance, p_PlayerToHideFrom0, p_PlayerToHideFrom1)
	local value0;
	if p_PlayerToHideFrom0 == 1 then
		value0 = getPointer(p_PlayerToHideFrom1);
	end
	getPointer(instance).PlayerToHideFrom = value0;
end
function abi.ffi.prop_get_billboard_gui_size(instance)
	return createPointer(getPointer(instance).Size);
end
function abi.ffi.prop_set_billboard_gui_size(instance, p_Size0)
	getPointer(instance).Size = getPointer(p_Size0);
end
function abi.ffi.prop_get_billboard_gui_size_offset(instance)
	return createPointer(getPointer(instance).SizeOffset);
end
function abi.ffi.prop_set_billboard_gui_size_offset(instance, p_SizeOffset0)
	getPointer(instance).SizeOffset = getPointer(p_SizeOffset0);
end
function abi.ffi.prop_get_billboard_gui_studs_offset(instance)
	return createPointer(getPointer(instance).StudsOffset);
end
function abi.ffi.prop_set_billboard_gui_studs_offset(instance, p_StudsOffset0)
	getPointer(instance).StudsOffset = getPointer(p_StudsOffset0);
end
function abi.ffi.prop_get_billboard_gui_studs_offset_world_space(instance)
	return createPointer(getPointer(instance).StudsOffsetWorldSpace);
end
function abi.ffi.prop_set_billboard_gui_studs_offset_world_space(instance, p_StudsOffsetWorldSpace0)
	getPointer(instance).StudsOffsetWorldSpace = getPointer(p_StudsOffsetWorldSpace0);
end
function abi.ffi.prop_get_screen_gui_clip_to_device_safe_area(instance)
	return getPointer(instance).ClipToDeviceSafeArea and 1 or 0;
end
function abi.ffi.prop_set_screen_gui_clip_to_device_safe_area(instance, p_ClipToDeviceSafeArea0)
	getPointer(instance).ClipToDeviceSafeArea = p_ClipToDeviceSafeArea0 == 1;
end
function abi.ffi.prop_get_screen_gui_display_order(instance)
	return getPointer(instance).DisplayOrder;
end
function abi.ffi.prop_set_screen_gui_display_order(instance, p_DisplayOrder0)
	getPointer(instance).DisplayOrder = p_DisplayOrder0;
end
function abi.ffi.prop_get_screen_gui_ignore_gui_inset(instance)
	return getPointer(instance).IgnoreGuiInset and 1 or 0;
end
function abi.ffi.prop_set_screen_gui_ignore_gui_inset(instance, p_IgnoreGuiInset0)
	getPointer(instance).IgnoreGuiInset = p_IgnoreGuiInset0 == 1;
end
function abi.ffi.prop_get_screen_gui_safe_area_compatibility(instance)
	return (getPointer(instance).SafeAreaCompatibility).Value;
end
function abi.ffi.prop_set_screen_gui_safe_area_compatibility(instance, p_SafeAreaCompatibility0)
	getPointer(instance).SafeAreaCompatibility = p_SafeAreaCompatibility0;
end
function abi.ffi.prop_get_surface_gui_base_active(instance)
	return getPointer(instance).Active and 1 or 0;
end
function abi.ffi.prop_set_surface_gui_base_active(instance, p_Active0)
	getPointer(instance).Active = p_Active0 == 1;
end
function abi.ffi.prop_get_surface_gui_base_adornee(output, instance)
	local value0 = getPointer(instance).Adornee;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_surface_gui_base_adornee(instance, p_Adornee0, p_Adornee1)
	local value0;
	if p_Adornee0 == 1 then
		value0 = getPointer(p_Adornee1);
	end
	getPointer(instance).Adornee = value0;
end
function abi.ffi.prop_get_surface_gui_base_face(instance)
	return (getPointer(instance).Face).Value;
end
function abi.ffi.prop_set_surface_gui_base_face(instance, p_Face0)
	getPointer(instance).Face = p_Face0;
end
function abi.ffi.prop_get_ad_gui_ad_shape(instance)
	return (getPointer(instance).AdShape).Value;
end
function abi.ffi.prop_set_ad_gui_ad_shape(instance, p_AdShape0)
	getPointer(instance).AdShape = p_AdShape0;
end
function abi.ffi.prop_get_surface_gui_always_on_top(instance)
	return getPointer(instance).AlwaysOnTop and 1 or 0;
end
function abi.ffi.prop_set_surface_gui_always_on_top(instance, p_AlwaysOnTop0)
	getPointer(instance).AlwaysOnTop = p_AlwaysOnTop0 == 1;
end
function abi.ffi.prop_get_surface_gui_brightness(instance)
	return getPointer(instance).Brightness;
end
function abi.ffi.prop_set_surface_gui_brightness(instance, p_Brightness0)
	getPointer(instance).Brightness = p_Brightness0;
end
function abi.ffi.prop_get_surface_gui_canvas_size(instance)
	return createPointer(getPointer(instance).CanvasSize);
end
function abi.ffi.prop_set_surface_gui_canvas_size(instance, p_CanvasSize0)
	getPointer(instance).CanvasSize = getPointer(p_CanvasSize0);
end
function abi.ffi.prop_get_surface_gui_clips_descendants(instance)
	return getPointer(instance).ClipsDescendants and 1 or 0;
end
function abi.ffi.prop_set_surface_gui_clips_descendants(instance, p_ClipsDescendants0)
	getPointer(instance).ClipsDescendants = p_ClipsDescendants0 == 1;
end
function abi.ffi.prop_get_surface_gui_light_influence(instance)
	return getPointer(instance).LightInfluence;
end
function abi.ffi.prop_set_surface_gui_light_influence(instance, p_LightInfluence0)
	getPointer(instance).LightInfluence = p_LightInfluence0;
end
function abi.ffi.prop_get_surface_gui_pixels_per_stud(instance)
	return getPointer(instance).PixelsPerStud;
end
function abi.ffi.prop_set_surface_gui_pixels_per_stud(instance, p_PixelsPerStud0)
	getPointer(instance).PixelsPerStud = p_PixelsPerStud0;
end
function abi.ffi.prop_get_surface_gui_sizing_mode(instance)
	return (getPointer(instance).SizingMode).Value;
end
function abi.ffi.prop_set_surface_gui_sizing_mode(instance, p_SizingMode0)
	getPointer(instance).SizingMode = p_SizingMode0;
end
function abi.ffi.prop_get_surface_gui_tool_punch_through_distance(instance)
	return getPointer(instance).ToolPunchThroughDistance;
end
function abi.ffi.prop_set_surface_gui_tool_punch_through_distance(instance, p_ToolPunchThroughDistance0)
	getPointer(instance).ToolPunchThroughDistance = p_ToolPunchThroughDistance0;
end
function abi.ffi.prop_get_surface_gui_z_offset(instance)
	return getPointer(instance).ZOffset;
end
function abi.ffi.prop_set_surface_gui_z_offset(instance, p_ZOffset0)
	getPointer(instance).ZOffset = p_ZOffset0;
end
function abi.ffi.prop_get_gui_base_3_d_color_3(instance)
	return createPointer(getPointer(instance).Color3);
end
function abi.ffi.prop_set_gui_base_3_d_color_3(instance, p_Color30)
	getPointer(instance).Color3 = getPointer(p_Color30);
end
function abi.ffi.prop_get_gui_base_3_d_transparency(instance)
	return getPointer(instance).Transparency;
end
function abi.ffi.prop_set_gui_base_3_d_transparency(instance, p_Transparency0)
	getPointer(instance).Transparency = p_Transparency0;
end
function abi.ffi.prop_get_gui_base_3_d_visible(instance)
	return getPointer(instance).Visible and 1 or 0;
end
function abi.ffi.prop_set_gui_base_3_d_visible(instance, p_Visible0)
	getPointer(instance).Visible = p_Visible0 == 1;
end
function abi.ffi.prop_get_instance_adornment_adornee(output, instance)
	local value0 = getPointer(instance).Adornee;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_instance_adornment_adornee(instance, p_Adornee0, p_Adornee1)
	local value0;
	if p_Adornee0 == 1 then
		value0 = getPointer(p_Adornee1);
	end
	getPointer(instance).Adornee = value0;
end
function abi.ffi.prop_get_selection_box_line_thickness(instance)
	return getPointer(instance).LineThickness;
end
function abi.ffi.prop_set_selection_box_line_thickness(instance, p_LineThickness0)
	getPointer(instance).LineThickness = p_LineThickness0;
end
function abi.ffi.prop_get_selection_box_surface_color_3(instance)
	return createPointer(getPointer(instance).SurfaceColor3);
end
function abi.ffi.prop_set_selection_box_surface_color_3(instance, p_SurfaceColor30)
	getPointer(instance).SurfaceColor3 = getPointer(p_SurfaceColor30);
end
function abi.ffi.prop_get_selection_box_surface_transparency(instance)
	return getPointer(instance).SurfaceTransparency;
end
function abi.ffi.prop_set_selection_box_surface_transparency(instance, p_SurfaceTransparency0)
	getPointer(instance).SurfaceTransparency = p_SurfaceTransparency0;
end
function abi.ffi.prop_get_pv_adornment_adornee(output, instance)
	local value0 = getPointer(instance).Adornee;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_pv_adornment_adornee(instance, p_Adornee0, p_Adornee1)
	local value0;
	if p_Adornee0 == 1 then
		value0 = getPointer(p_Adornee1);
	end
	getPointer(instance).Adornee = value0;
end
function abi.ffi.prop_get_handle_adornment_adorn_culling_mode(instance)
	return (getPointer(instance).AdornCullingMode).Value;
end
function abi.ffi.prop_set_handle_adornment_adorn_culling_mode(instance, p_AdornCullingMode0)
	getPointer(instance).AdornCullingMode = p_AdornCullingMode0;
end
function abi.ffi.prop_get_handle_adornment_always_on_top(instance)
	return getPointer(instance).AlwaysOnTop and 1 or 0;
end
function abi.ffi.prop_set_handle_adornment_always_on_top(instance, p_AlwaysOnTop0)
	getPointer(instance).AlwaysOnTop = p_AlwaysOnTop0 == 1;
end
function abi.ffi.prop_get_handle_adornment_c_frame(instance)
	return createPointer(getPointer(instance).CFrame);
end
function abi.ffi.prop_set_handle_adornment_c_frame(instance, p_CFrame0)
	getPointer(instance).CFrame = getPointer(p_CFrame0);
end
function abi.ffi.prop_get_handle_adornment_size_relative_offset(instance)
	return createPointer(getPointer(instance).SizeRelativeOffset);
end
function abi.ffi.prop_set_handle_adornment_size_relative_offset(instance, p_SizeRelativeOffset0)
	getPointer(instance).SizeRelativeOffset = getPointer(p_SizeRelativeOffset0);
end
function abi.ffi.prop_get_handle_adornment_z_index(instance)
	return getPointer(instance).ZIndex;
end
function abi.ffi.prop_set_handle_adornment_z_index(instance, p_ZIndex0)
	getPointer(instance).ZIndex = p_ZIndex0;
end
function abi.ffi.connect_handle_adornment_mouse_button_1_down(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseButton1Down:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_handle_adornment_mouse_button_1_up(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseButton1Up:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_handle_adornment_mouse_enter(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseEnter:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_handle_adornment_mouse_leave(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseLeave:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.prop_get_box_handle_adornment_size(instance)
	return createPointer(getPointer(instance).Size);
end
function abi.ffi.prop_set_box_handle_adornment_size(instance, p_Size0)
	getPointer(instance).Size = getPointer(p_Size0);
end
function abi.ffi.prop_get_cone_handle_adornment_height(instance)
	return getPointer(instance).Height;
end
function abi.ffi.prop_set_cone_handle_adornment_height(instance, p_Height0)
	getPointer(instance).Height = p_Height0;
end
function abi.ffi.prop_get_cone_handle_adornment_radius(instance)
	return getPointer(instance).Radius;
end
function abi.ffi.prop_set_cone_handle_adornment_radius(instance, p_Radius0)
	getPointer(instance).Radius = p_Radius0;
end
function abi.ffi.prop_get_cylinder_handle_adornment_angle(instance)
	return getPointer(instance).Angle;
end
function abi.ffi.prop_set_cylinder_handle_adornment_angle(instance, p_Angle0)
	getPointer(instance).Angle = p_Angle0;
end
function abi.ffi.prop_get_cylinder_handle_adornment_height(instance)
	return getPointer(instance).Height;
end
function abi.ffi.prop_set_cylinder_handle_adornment_height(instance, p_Height0)
	getPointer(instance).Height = p_Height0;
end
function abi.ffi.prop_get_cylinder_handle_adornment_inner_radius(instance)
	return getPointer(instance).InnerRadius;
end
function abi.ffi.prop_set_cylinder_handle_adornment_inner_radius(instance, p_InnerRadius0)
	getPointer(instance).InnerRadius = p_InnerRadius0;
end
function abi.ffi.prop_get_cylinder_handle_adornment_radius(instance)
	return getPointer(instance).Radius;
end
function abi.ffi.prop_set_cylinder_handle_adornment_radius(instance, p_Radius0)
	getPointer(instance).Radius = p_Radius0;
end
function abi.ffi.prop_get_image_handle_adornment_image(instance)
	return createPointer(getPointer(instance).Image);
end
function abi.ffi.prop_set_image_handle_adornment_image(instance, p_Image0)
	getPointer(instance).Image = getPointer(p_Image0);
end
function abi.ffi.prop_get_image_handle_adornment_size(instance)
	return createPointer(getPointer(instance).Size);
end
function abi.ffi.prop_set_image_handle_adornment_size(instance, p_Size0)
	getPointer(instance).Size = getPointer(p_Size0);
end
function abi.ffi.prop_get_line_handle_adornment_length(instance)
	return getPointer(instance).Length;
end
function abi.ffi.prop_set_line_handle_adornment_length(instance, p_Length0)
	getPointer(instance).Length = p_Length0;
end
function abi.ffi.prop_get_line_handle_adornment_thickness(instance)
	return getPointer(instance).Thickness;
end
function abi.ffi.prop_set_line_handle_adornment_thickness(instance, p_Thickness0)
	getPointer(instance).Thickness = p_Thickness0;
end
function abi.ffi.prop_get_sphere_handle_adornment_radius(instance)
	return getPointer(instance).Radius;
end
function abi.ffi.prop_set_sphere_handle_adornment_radius(instance, p_Radius0)
	getPointer(instance).Radius = p_Radius0;
end
function abi.ffi.dyn_fn_wireframe_handle_adornment_add_line(instance, p_from0, p_to0)
	return getPointer(instance):AddLine(getPointer(p_from0), getPointer(p_to0));
end
function abi.ffi.dyn_fn_wireframe_handle_adornment_clear(instance)
	return getPointer(instance):Clear();
end
function abi.ffi.prop_get_selection_sphere_surface_color_3(instance)
	return createPointer(getPointer(instance).SurfaceColor3);
end
function abi.ffi.prop_set_selection_sphere_surface_color_3(instance, p_SurfaceColor30)
	getPointer(instance).SurfaceColor3 = getPointer(p_SurfaceColor30);
end
function abi.ffi.prop_get_selection_sphere_surface_transparency(instance)
	return getPointer(instance).SurfaceTransparency;
end
function abi.ffi.prop_set_selection_sphere_surface_transparency(instance, p_SurfaceTransparency0)
	getPointer(instance).SurfaceTransparency = p_SurfaceTransparency0;
end
function abi.ffi.prop_get_part_adornment_adornee(output, instance)
	local value0 = getPointer(instance).Adornee;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_part_adornment_adornee(instance, p_Adornee0, p_Adornee1)
	local value0;
	if p_Adornee0 == 1 then
		value0 = getPointer(p_Adornee1);
	end
	getPointer(instance).Adornee = value0;
end
function abi.ffi.prop_get_arc_handles_axes(instance)
	return createPointer(getPointer(instance).Axes);
end
function abi.ffi.prop_set_arc_handles_axes(instance, p_Axes0)
	getPointer(instance).Axes = getPointer(p_Axes0);
end
function abi.ffi.connect_arc_handles_mouse_button_1_down(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseButton1Down:Connect(function(p_axis)
		invokeFunction(data, vtable, (p_axis).Value);
	end))
end
function abi.ffi.connect_arc_handles_mouse_button_1_up(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseButton1Up:Connect(function(p_axis)
		invokeFunction(data, vtable, (p_axis).Value);
	end))
end
function abi.ffi.connect_arc_handles_mouse_drag(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseDrag:Connect(function(p_axis, p_relativeAngle, p_deltaRadius)
		invokeFunction(data, vtable, (p_axis).Value, p_relativeAngle, p_deltaRadius);
	end))
end
function abi.ffi.connect_arc_handles_mouse_enter(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseEnter:Connect(function(p_axis)
		invokeFunction(data, vtable, (p_axis).Value);
	end))
end
function abi.ffi.connect_arc_handles_mouse_leave(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseLeave:Connect(function(p_axis)
		invokeFunction(data, vtable, (p_axis).Value);
	end))
end
function abi.ffi.prop_get_handles_faces(instance)
	return createPointer(getPointer(instance).Faces);
end
function abi.ffi.prop_set_handles_faces(instance, p_Faces0)
	getPointer(instance).Faces = getPointer(p_Faces0);
end
function abi.ffi.prop_get_handles_style(instance)
	return (getPointer(instance).Style).Value;
end
function abi.ffi.prop_set_handles_style(instance, p_Style0)
	getPointer(instance).Style = p_Style0;
end
function abi.ffi.connect_handles_mouse_button_1_down(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseButton1Down:Connect(function(p_face)
		invokeFunction(data, vtable, (p_face).Value);
	end))
end
function abi.ffi.connect_handles_mouse_button_1_up(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseButton1Up:Connect(function(p_face)
		invokeFunction(data, vtable, (p_face).Value);
	end))
end
function abi.ffi.connect_handles_mouse_drag(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseDrag:Connect(function(p_face, p_distance)
		invokeFunction(data, vtable, (p_face).Value, p_distance);
	end))
end
function abi.ffi.connect_handles_mouse_enter(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseEnter:Connect(function(p_face)
		invokeFunction(data, vtable, (p_face).Value);
	end))
end
function abi.ffi.connect_handles_mouse_leave(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MouseLeave:Connect(function(p_face)
		invokeFunction(data, vtable, (p_face).Value);
	end))
end
function abi.ffi.prop_get_surface_selection_target_surface(instance)
	return (getPointer(instance).TargetSurface).Value;
end
function abi.ffi.prop_set_surface_selection_target_surface(instance, p_TargetSurface0)
	getPointer(instance).TargetSurface = p_TargetSurface0;
end
function abi.ffi.prop_get_selection_lasso_humanoid(output, instance)
	local value0 = getPointer(instance).Humanoid;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_selection_lasso_humanoid(instance, p_Humanoid0, p_Humanoid1)
	local value0;
	if p_Humanoid0 == 1 then
		value0 = getPointer(p_Humanoid1);
	end
	getPointer(instance).Humanoid = value0;
end
function abi.ffi.prop_get_gui_service_auto_select_gui_enabled(instance)
	return getPointer(instance).AutoSelectGuiEnabled and 1 or 0;
end
function abi.ffi.prop_set_gui_service_auto_select_gui_enabled(instance, p_AutoSelectGuiEnabled0)
	getPointer(instance).AutoSelectGuiEnabled = p_AutoSelectGuiEnabled0 == 1;
end
function abi.ffi.prop_get_gui_service_core_gui_navigation_enabled(instance)
	return getPointer(instance).CoreGuiNavigationEnabled and 1 or 0;
end
function abi.ffi.prop_set_gui_service_core_gui_navigation_enabled(instance, p_CoreGuiNavigationEnabled0)
	getPointer(instance).CoreGuiNavigationEnabled = p_CoreGuiNavigationEnabled0 == 1;
end
function abi.ffi.prop_get_gui_service_gui_navigation_enabled(instance)
	return getPointer(instance).GuiNavigationEnabled and 1 or 0;
end
function abi.ffi.prop_set_gui_service_gui_navigation_enabled(instance, p_GuiNavigationEnabled0)
	getPointer(instance).GuiNavigationEnabled = p_GuiNavigationEnabled0 == 1;
end
function abi.ffi.prop_get_gui_service_menu_is_open(instance)
	return getPointer(instance).MenuIsOpen and 1 or 0;
end
function abi.ffi.prop_get_gui_service_selected_object(output, instance)
	local value0 = getPointer(instance).SelectedObject;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_gui_service_selected_object(instance, p_SelectedObject0, p_SelectedObject1)
	local value0;
	if p_SelectedObject0 == 1 then
		value0 = getPointer(p_SelectedObject1);
	end
	getPointer(instance).SelectedObject = value0;
end
function abi.ffi.prop_get_gui_service_touch_controls_enabled(instance)
	return getPointer(instance).TouchControlsEnabled and 1 or 0;
end
function abi.ffi.prop_set_gui_service_touch_controls_enabled(instance, p_TouchControlsEnabled0)
	getPointer(instance).TouchControlsEnabled = p_TouchControlsEnabled0 == 1;
end
function abi.ffi.dyn_fn_gui_service_add_selection_parent(instance, p_selectionName0, p_selectionName1, p_selectionParent0)
	return getPointer(instance):AddSelectionParent(loadString(memory, p_selectionName0, p_selectionName1), getPointer(p_selectionParent0));
end
function abi.ffi.dyn_fn_gui_service_close_inspect_menu(instance)
	return getPointer(instance):CloseInspectMenu();
end
function abi.ffi.dyn_fn_gui_service_get_emotes_menu_open(instance)
	return getPointer(instance):GetEmotesMenuOpen() and 1 or 0;
end
function abi.ffi.dyn_fn_gui_service_get_gameplay_paused_notification_enabled(instance)
	return getPointer(instance):GetGameplayPausedNotificationEnabled() and 1 or 0;
end
function abi.ffi.dyn_fn_gui_service_get_inspect_menu_enabled(instance)
	return getPointer(instance):GetInspectMenuEnabled() and 1 or 0;
end
function abi.ffi.dyn_fn_gui_service_inspect_player_from_humanoid_description(instance, p_humanoidDescription0, p_name0, p_name1)
	return getPointer(instance):InspectPlayerFromHumanoidDescription(getPointer(p_humanoidDescription0), loadString(memory, p_name0, p_name1));
end
function abi.ffi.dyn_fn_gui_service_inspect_player_from_user_id(instance, p_userId0)
	return getPointer(instance):InspectPlayerFromUserId(p_userId0);
end
function abi.ffi.dyn_fn_gui_service_is_ten_foot_interface(instance)
	return getPointer(instance):IsTenFootInterface() and 1 or 0;
end
function abi.ffi.dyn_fn_gui_service_remove_selection_group(instance, p_selectionName0, p_selectionName1)
	return getPointer(instance):RemoveSelectionGroup(loadString(memory, p_selectionName0, p_selectionName1));
end
function abi.ffi.dyn_fn_gui_service_select(instance, p_selectionParent0)
	return getPointer(instance):Select(getPointer(p_selectionParent0));
end
function abi.ffi.dyn_fn_gui_service_set_emotes_menu_open(instance, p_isOpen0)
	return getPointer(instance):SetEmotesMenuOpen(p_isOpen0 == 1);
end
function abi.ffi.dyn_fn_gui_service_set_gameplay_paused_notification_enabled(instance, p_enabled0)
	return getPointer(instance):SetGameplayPausedNotificationEnabled(p_enabled0 == 1);
end
function abi.ffi.dyn_fn_gui_service_set_inspect_menu_enabled(instance, p_enabled0)
	return getPointer(instance):SetInspectMenuEnabled(p_enabled0 == 1);
end
function abi.ffi.connect_gui_service_menu_closed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MenuClosed:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_gui_service_menu_opened(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MenuOpened:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.dyn_fn_haptic_service_is_motor_supported(instance, p_inputType0, p_vibrationMotor0)
	return getPointer(instance):IsMotorSupported(p_inputType0, p_vibrationMotor0) and 1 or 0;
end
function abi.ffi.dyn_fn_haptic_service_is_vibration_supported(instance, p_inputType0)
	return getPointer(instance):IsVibrationSupported(p_inputType0) and 1 or 0;
end
function abi.ffi.prop_get_highlight_adornee(output, instance)
	local value0 = getPointer(instance).Adornee;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_highlight_adornee(instance, p_Adornee0, p_Adornee1)
	local value0;
	if p_Adornee0 == 1 then
		value0 = getPointer(p_Adornee1);
	end
	getPointer(instance).Adornee = value0;
end
function abi.ffi.prop_get_highlight_depth_mode(instance)
	return (getPointer(instance).DepthMode).Value;
end
function abi.ffi.prop_set_highlight_depth_mode(instance, p_DepthMode0)
	getPointer(instance).DepthMode = p_DepthMode0;
end
function abi.ffi.prop_get_highlight_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_highlight_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_highlight_fill_color(instance)
	return createPointer(getPointer(instance).FillColor);
end
function abi.ffi.prop_set_highlight_fill_color(instance, p_FillColor0)
	getPointer(instance).FillColor = getPointer(p_FillColor0);
end
function abi.ffi.prop_get_highlight_fill_transparency(instance)
	return getPointer(instance).FillTransparency;
end
function abi.ffi.prop_set_highlight_fill_transparency(instance, p_FillTransparency0)
	getPointer(instance).FillTransparency = p_FillTransparency0;
end
function abi.ffi.prop_get_highlight_outline_color(instance)
	return createPointer(getPointer(instance).OutlineColor);
end
function abi.ffi.prop_set_highlight_outline_color(instance, p_OutlineColor0)
	getPointer(instance).OutlineColor = getPointer(p_OutlineColor0);
end
function abi.ffi.prop_get_highlight_outline_transparency(instance)
	return getPointer(instance).OutlineTransparency;
end
function abi.ffi.prop_set_highlight_outline_transparency(instance, p_OutlineTransparency0)
	getPointer(instance).OutlineTransparency = p_OutlineTransparency0;
end
function abi.ffi.dyn_fn_http_service_generate_guid(output, instance, p_wrapInCurlyBraces0)
	local value0 = getPointer(instance):GenerateGUID(p_wrapInCurlyBraces0 == 1);
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_http_service_json_decode(instance, p_input0, p_input1)
	return createPointer(getPointer(instance):JSONDecode(loadString(memory, p_input0, p_input1)));
end
function abi.ffi.dyn_fn_http_service_json_encode(output, instance, p_input0)
	local value0 = getPointer(instance):JSONEncode(getPointer(p_input0));
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_http_service_url_encode(output, instance, p_input0, p_input1)
	local value0 = getPointer(instance):UrlEncode(loadString(memory, p_input0, p_input1));
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_http_service_get_async(output, instance, p_url0, p_url1, p_nocache0, p_headers0)
	local value0 = getPointer(instance):GetAsync(loadString(memory, p_url0, p_url1), p_nocache0 == 1, getPointer(p_headers0));
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_http_service_post_async(output, instance, p_url0, p_url1, p_data0, p_data1, p_content_type0, p_compress0, p_headers0)
	local value0 = getPointer(instance):PostAsync(loadString(memory, p_url0, p_url1), loadString(memory, p_data0, p_data1), p_content_type0, p_compress0 == 1, getPointer(p_headers0));
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_http_service_request_async(instance, p_requestOptions0)
	return createPointer(getPointer(instance):RequestAsync(getPointer(p_requestOptions0)));
end
function abi.ffi.prop_get_humanoid_auto_jump_enabled(instance)
	return getPointer(instance).AutoJumpEnabled and 1 or 0;
end
function abi.ffi.prop_set_humanoid_auto_jump_enabled(instance, p_AutoJumpEnabled0)
	getPointer(instance).AutoJumpEnabled = p_AutoJumpEnabled0 == 1;
end
function abi.ffi.prop_get_humanoid_auto_rotate(instance)
	return getPointer(instance).AutoRotate and 1 or 0;
end
function abi.ffi.prop_set_humanoid_auto_rotate(instance, p_AutoRotate0)
	getPointer(instance).AutoRotate = p_AutoRotate0 == 1;
end
function abi.ffi.prop_get_humanoid_automatic_scaling_enabled(instance)
	return getPointer(instance).AutomaticScalingEnabled and 1 or 0;
end
function abi.ffi.prop_set_humanoid_automatic_scaling_enabled(instance, p_AutomaticScalingEnabled0)
	getPointer(instance).AutomaticScalingEnabled = p_AutomaticScalingEnabled0 == 1;
end
function abi.ffi.prop_get_humanoid_break_joints_on_death(instance)
	return getPointer(instance).BreakJointsOnDeath and 1 or 0;
end
function abi.ffi.prop_set_humanoid_break_joints_on_death(instance, p_BreakJointsOnDeath0)
	getPointer(instance).BreakJointsOnDeath = p_BreakJointsOnDeath0 == 1;
end
function abi.ffi.prop_get_humanoid_camera_offset(instance)
	return createPointer(getPointer(instance).CameraOffset);
end
function abi.ffi.prop_set_humanoid_camera_offset(instance, p_CameraOffset0)
	getPointer(instance).CameraOffset = getPointer(p_CameraOffset0);
end
function abi.ffi.prop_get_humanoid_display_distance_type(instance)
	return (getPointer(instance).DisplayDistanceType).Value;
end
function abi.ffi.prop_set_humanoid_display_distance_type(instance, p_DisplayDistanceType0)
	getPointer(instance).DisplayDistanceType = p_DisplayDistanceType0;
end
function abi.ffi.prop_get_humanoid_display_name(output, instance)
	local value0 = getPointer(instance).DisplayName;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_humanoid_display_name(instance, p_DisplayName0, p_DisplayName1)
	getPointer(instance).DisplayName = loadString(memory, p_DisplayName0, p_DisplayName1);
end
function abi.ffi.prop_get_humanoid_evaluate_state_machine(instance)
	return getPointer(instance).EvaluateStateMachine and 1 or 0;
end
function abi.ffi.prop_set_humanoid_evaluate_state_machine(instance, p_EvaluateStateMachine0)
	getPointer(instance).EvaluateStateMachine = p_EvaluateStateMachine0 == 1;
end
function abi.ffi.prop_get_humanoid_floor_material(instance)
	return (getPointer(instance).FloorMaterial).Value;
end
function abi.ffi.prop_get_humanoid_health(instance)
	return getPointer(instance).Health;
end
function abi.ffi.prop_set_humanoid_health(instance, p_Health0)
	getPointer(instance).Health = p_Health0;
end
function abi.ffi.prop_get_humanoid_health_display_distance(instance)
	return getPointer(instance).HealthDisplayDistance;
end
function abi.ffi.prop_set_humanoid_health_display_distance(instance, p_HealthDisplayDistance0)
	getPointer(instance).HealthDisplayDistance = p_HealthDisplayDistance0;
end
function abi.ffi.prop_get_humanoid_health_display_type(instance)
	return (getPointer(instance).HealthDisplayType).Value;
end
function abi.ffi.prop_set_humanoid_health_display_type(instance, p_HealthDisplayType0)
	getPointer(instance).HealthDisplayType = p_HealthDisplayType0;
end
function abi.ffi.prop_get_humanoid_hip_height(instance)
	return getPointer(instance).HipHeight;
end
function abi.ffi.prop_set_humanoid_hip_height(instance, p_HipHeight0)
	getPointer(instance).HipHeight = p_HipHeight0;
end
function abi.ffi.prop_get_humanoid_jump(instance)
	return getPointer(instance).Jump and 1 or 0;
end
function abi.ffi.prop_set_humanoid_jump(instance, p_Jump0)
	getPointer(instance).Jump = p_Jump0 == 1;
end
function abi.ffi.prop_get_humanoid_jump_height(instance)
	return getPointer(instance).JumpHeight;
end
function abi.ffi.prop_set_humanoid_jump_height(instance, p_JumpHeight0)
	getPointer(instance).JumpHeight = p_JumpHeight0;
end
function abi.ffi.prop_get_humanoid_jump_power(instance)
	return getPointer(instance).JumpPower;
end
function abi.ffi.prop_set_humanoid_jump_power(instance, p_JumpPower0)
	getPointer(instance).JumpPower = p_JumpPower0;
end
function abi.ffi.prop_get_humanoid_max_health(instance)
	return getPointer(instance).MaxHealth;
end
function abi.ffi.prop_set_humanoid_max_health(instance, p_MaxHealth0)
	getPointer(instance).MaxHealth = p_MaxHealth0;
end
function abi.ffi.prop_get_humanoid_max_slope_angle(instance)
	return getPointer(instance).MaxSlopeAngle;
end
function abi.ffi.prop_set_humanoid_max_slope_angle(instance, p_MaxSlopeAngle0)
	getPointer(instance).MaxSlopeAngle = p_MaxSlopeAngle0;
end
function abi.ffi.prop_get_humanoid_move_direction(instance)
	return createPointer(getPointer(instance).MoveDirection);
end
function abi.ffi.prop_get_humanoid_name_display_distance(instance)
	return getPointer(instance).NameDisplayDistance;
end
function abi.ffi.prop_set_humanoid_name_display_distance(instance, p_NameDisplayDistance0)
	getPointer(instance).NameDisplayDistance = p_NameDisplayDistance0;
end
function abi.ffi.prop_get_humanoid_name_occlusion(instance)
	return (getPointer(instance).NameOcclusion).Value;
end
function abi.ffi.prop_set_humanoid_name_occlusion(instance, p_NameOcclusion0)
	getPointer(instance).NameOcclusion = p_NameOcclusion0;
end
function abi.ffi.prop_get_humanoid_platform_stand(instance)
	return getPointer(instance).PlatformStand and 1 or 0;
end
function abi.ffi.prop_set_humanoid_platform_stand(instance, p_PlatformStand0)
	getPointer(instance).PlatformStand = p_PlatformStand0 == 1;
end
function abi.ffi.prop_get_humanoid_requires_neck(instance)
	return getPointer(instance).RequiresNeck and 1 or 0;
end
function abi.ffi.prop_set_humanoid_requires_neck(instance, p_RequiresNeck0)
	getPointer(instance).RequiresNeck = p_RequiresNeck0 == 1;
end
function abi.ffi.prop_get_humanoid_rig_type(instance)
	return (getPointer(instance).RigType).Value;
end
function abi.ffi.prop_set_humanoid_rig_type(instance, p_RigType0)
	getPointer(instance).RigType = p_RigType0;
end
function abi.ffi.prop_get_humanoid_root_part(output, instance)
	local value0 = getPointer(instance).RootPart;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_humanoid_seat_part(output, instance)
	local value0 = getPointer(instance).SeatPart;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_humanoid_sit(instance)
	return getPointer(instance).Sit and 1 or 0;
end
function abi.ffi.prop_set_humanoid_sit(instance, p_Sit0)
	getPointer(instance).Sit = p_Sit0 == 1;
end
function abi.ffi.prop_get_humanoid_target_point(instance)
	return createPointer(getPointer(instance).TargetPoint);
end
function abi.ffi.prop_set_humanoid_target_point(instance, p_TargetPoint0)
	getPointer(instance).TargetPoint = getPointer(p_TargetPoint0);
end
function abi.ffi.prop_get_humanoid_use_jump_power(instance)
	return getPointer(instance).UseJumpPower and 1 or 0;
end
function abi.ffi.prop_set_humanoid_use_jump_power(instance, p_UseJumpPower0)
	getPointer(instance).UseJumpPower = p_UseJumpPower0 == 1;
end
function abi.ffi.prop_get_humanoid_walk_speed(instance)
	return getPointer(instance).WalkSpeed;
end
function abi.ffi.prop_set_humanoid_walk_speed(instance, p_WalkSpeed0)
	getPointer(instance).WalkSpeed = p_WalkSpeed0;
end
function abi.ffi.prop_get_humanoid_walk_to_part(output, instance)
	local value0 = getPointer(instance).WalkToPart;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_humanoid_walk_to_part(instance, p_WalkToPart0, p_WalkToPart1)
	local value0;
	if p_WalkToPart0 == 1 then
		value0 = getPointer(p_WalkToPart1);
	end
	getPointer(instance).WalkToPart = value0;
end
function abi.ffi.prop_get_humanoid_walk_to_point(instance)
	return createPointer(getPointer(instance).WalkToPoint);
end
function abi.ffi.prop_set_humanoid_walk_to_point(instance, p_WalkToPoint0)
	getPointer(instance).WalkToPoint = getPointer(p_WalkToPoint0);
end
function abi.ffi.dyn_fn_humanoid_add_accessory(instance, p_accessory0)
	return getPointer(instance):AddAccessory(getPointer(p_accessory0));
end
function abi.ffi.dyn_fn_humanoid_build_rig_from_attachments(instance)
	return getPointer(instance):BuildRigFromAttachments();
end
function abi.ffi.dyn_fn_humanoid_change_state(instance, p_state0)
	return getPointer(instance):ChangeState(p_state0);
end
function abi.ffi.dyn_fn_humanoid_equip_tool(instance, p_tool0)
	return getPointer(instance):EquipTool(getPointer(p_tool0));
end
function abi.ffi.dyn_fn_humanoid_get_applied_description(output, instance)
	local value0 = getPointer(instance):GetAppliedDescription();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_humanoid_get_body_part_r_15(instance, p_part0)
	return (getPointer(instance):GetBodyPartR15(getPointer(p_part0))).Value;
end
function abi.ffi.dyn_fn_humanoid_get_limb(instance, p_part0)
	return (getPointer(instance):GetLimb(getPointer(p_part0))).Value;
end
function abi.ffi.dyn_fn_humanoid_get_state(instance)
	return (getPointer(instance):GetState()).Value;
end
function abi.ffi.dyn_fn_humanoid_get_state_enabled(instance, p_state0)
	return getPointer(instance):GetStateEnabled(p_state0) and 1 or 0;
end
function abi.ffi.dyn_fn_humanoid_fn_move(instance, p_moveDirection0, p_relativeToCamera0)
	return getPointer(instance):FnMove(getPointer(p_moveDirection0), p_relativeToCamera0 == 1);
end
function abi.ffi.dyn_fn_humanoid_move_to(instance, p_location0, p_part0)
	return getPointer(instance):MoveTo(getPointer(p_location0), getPointer(p_part0));
end
function abi.ffi.dyn_fn_humanoid_remove_accessories(instance)
	return getPointer(instance):RemoveAccessories();
end
function abi.ffi.dyn_fn_humanoid_replace_body_part_r_15(instance, p_bodyPart0, p_part0)
	return getPointer(instance):ReplaceBodyPartR15(p_bodyPart0, getPointer(p_part0)) and 1 or 0;
end
function abi.ffi.dyn_fn_humanoid_set_state_enabled(instance, p_state0, p_enabled0)
	return getPointer(instance):SetStateEnabled(p_state0, p_enabled0 == 1);
end
function abi.ffi.dyn_fn_humanoid_take_damage(instance, p_amount0)
	return getPointer(instance):TakeDamage(p_amount0);
end
function abi.ffi.dyn_fn_humanoid_unequip_tools(instance)
	return getPointer(instance):UnequipTools();
end
function abi.ffi.dyn_fn_humanoid_apply_description(instance, p_humanoidDescription0, p_assetTypeVerification0)
	return getPointer(instance):ApplyDescription(getPointer(p_humanoidDescription0), p_assetTypeVerification0);
end
function abi.ffi.dyn_fn_humanoid_apply_description_reset(instance, p_humanoidDescription0, p_assetTypeVerification0)
	return getPointer(instance):ApplyDescriptionReset(getPointer(p_humanoidDescription0), p_assetTypeVerification0);
end
function abi.ffi.dyn_fn_humanoid_play_emote(instance, p_emoteName0, p_emoteName1)
	return getPointer(instance):PlayEmote(loadString(memory, p_emoteName0, p_emoteName1)) and 1 or 0;
end
function abi.ffi.connect_humanoid_climbing(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Climbing:Connect(function(p_speed)
		invokeFunction(data, vtable, p_speed);
	end))
end
function abi.ffi.connect_humanoid_died(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Died:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_humanoid_falling_down(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).FallingDown:Connect(function(p_active)
		invokeFunction(data, vtable, p_active and 1 or 0);
	end))
end
function abi.ffi.connect_humanoid_free_falling(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).FreeFalling:Connect(function(p_active)
		invokeFunction(data, vtable, p_active and 1 or 0);
	end))
end
function abi.ffi.connect_humanoid_getting_up(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).GettingUp:Connect(function(p_active)
		invokeFunction(data, vtable, p_active and 1 or 0);
	end))
end
function abi.ffi.connect_humanoid_health_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).HealthChanged:Connect(function(p_health)
		invokeFunction(data, vtable, p_health);
	end))
end
function abi.ffi.connect_humanoid_jumping(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Jumping:Connect(function(p_active)
		invokeFunction(data, vtable, p_active and 1 or 0);
	end))
end
function abi.ffi.connect_humanoid_move_to_finished(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MoveToFinished:Connect(function(p_reached)
		invokeFunction(data, vtable, p_reached and 1 or 0);
	end))
end
function abi.ffi.connect_humanoid_platform_standing(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PlatformStanding:Connect(function(p_active)
		invokeFunction(data, vtable, p_active and 1 or 0);
	end))
end
function abi.ffi.connect_humanoid_ragdoll(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Ragdoll:Connect(function(p_active)
		invokeFunction(data, vtable, p_active and 1 or 0);
	end))
end
function abi.ffi.connect_humanoid_running(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Running:Connect(function(p_speed)
		invokeFunction(data, vtable, p_speed);
	end))
end
function abi.ffi.connect_humanoid_seated(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Seated:Connect(function(p_active, p_currentSeatPart)
		local value0 = p_currentSeatPart;
		invokeFunction(data, vtable, p_active and 1 or 0, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_humanoid_state_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).StateChanged:Connect(function(p_old, p_new)
		invokeFunction(data, vtable, (p_old).Value, (p_new).Value);
	end))
end
function abi.ffi.connect_humanoid_state_enabled_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).StateEnabledChanged:Connect(function(p_state, p_isEnabled)
		invokeFunction(data, vtable, (p_state).Value, p_isEnabled and 1 or 0);
	end))
end
function abi.ffi.connect_humanoid_strafing(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Strafing:Connect(function(p_active)
		invokeFunction(data, vtable, p_active and 1 or 0);
	end))
end
function abi.ffi.connect_humanoid_swimming(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Swimming:Connect(function(p_speed)
		invokeFunction(data, vtable, p_speed);
	end))
end
function abi.ffi.connect_humanoid_touched(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Touched:Connect(function(p_touchingPart, p_humanoidPart)
		invokeFunction(data, vtable, createPointer(p_touchingPart), createPointer(p_humanoidPart));
	end))
end
function abi.ffi.prop_get_humanoid_description_back_accessory(output, instance)
	local value0 = getPointer(instance).BackAccessory;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_humanoid_description_back_accessory(instance, p_BackAccessory0, p_BackAccessory1)
	getPointer(instance).BackAccessory = loadString(memory, p_BackAccessory0, p_BackAccessory1);
end
function abi.ffi.prop_get_humanoid_description_body_type_scale(instance)
	return getPointer(instance).BodyTypeScale;
end
function abi.ffi.prop_set_humanoid_description_body_type_scale(instance, p_BodyTypeScale0)
	getPointer(instance).BodyTypeScale = p_BodyTypeScale0;
end
function abi.ffi.prop_get_humanoid_description_climb_animation(instance)
	return getPointer(instance).ClimbAnimation;
end
function abi.ffi.prop_set_humanoid_description_climb_animation(instance, p_ClimbAnimation0)
	getPointer(instance).ClimbAnimation = p_ClimbAnimation0;
end
function abi.ffi.prop_get_humanoid_description_depth_scale(instance)
	return getPointer(instance).DepthScale;
end
function abi.ffi.prop_set_humanoid_description_depth_scale(instance, p_DepthScale0)
	getPointer(instance).DepthScale = p_DepthScale0;
end
function abi.ffi.prop_get_humanoid_description_face(instance)
	return getPointer(instance).Face;
end
function abi.ffi.prop_set_humanoid_description_face(instance, p_Face0)
	getPointer(instance).Face = p_Face0;
end
function abi.ffi.prop_get_humanoid_description_face_accessory(output, instance)
	local value0 = getPointer(instance).FaceAccessory;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_humanoid_description_face_accessory(instance, p_FaceAccessory0, p_FaceAccessory1)
	getPointer(instance).FaceAccessory = loadString(memory, p_FaceAccessory0, p_FaceAccessory1);
end
function abi.ffi.prop_get_humanoid_description_fall_animation(instance)
	return getPointer(instance).FallAnimation;
end
function abi.ffi.prop_set_humanoid_description_fall_animation(instance, p_FallAnimation0)
	getPointer(instance).FallAnimation = p_FallAnimation0;
end
function abi.ffi.prop_get_humanoid_description_front_accessory(output, instance)
	local value0 = getPointer(instance).FrontAccessory;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_humanoid_description_front_accessory(instance, p_FrontAccessory0, p_FrontAccessory1)
	getPointer(instance).FrontAccessory = loadString(memory, p_FrontAccessory0, p_FrontAccessory1);
end
function abi.ffi.prop_get_humanoid_description_graphic_t_shirt(instance)
	return getPointer(instance).GraphicTShirt;
end
function abi.ffi.prop_set_humanoid_description_graphic_t_shirt(instance, p_GraphicTShirt0)
	getPointer(instance).GraphicTShirt = p_GraphicTShirt0;
end
function abi.ffi.prop_get_humanoid_description_hair_accessory(output, instance)
	local value0 = getPointer(instance).HairAccessory;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_humanoid_description_hair_accessory(instance, p_HairAccessory0, p_HairAccessory1)
	getPointer(instance).HairAccessory = loadString(memory, p_HairAccessory0, p_HairAccessory1);
end
function abi.ffi.prop_get_humanoid_description_hat_accessory(output, instance)
	local value0 = getPointer(instance).HatAccessory;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_humanoid_description_hat_accessory(instance, p_HatAccessory0, p_HatAccessory1)
	getPointer(instance).HatAccessory = loadString(memory, p_HatAccessory0, p_HatAccessory1);
end
function abi.ffi.prop_get_humanoid_description_head(instance)
	return getPointer(instance).Head;
end
function abi.ffi.prop_set_humanoid_description_head(instance, p_Head0)
	getPointer(instance).Head = p_Head0;
end
function abi.ffi.prop_get_humanoid_description_head_color(instance)
	return createPointer(getPointer(instance).HeadColor);
end
function abi.ffi.prop_set_humanoid_description_head_color(instance, p_HeadColor0)
	getPointer(instance).HeadColor = getPointer(p_HeadColor0);
end
function abi.ffi.prop_get_humanoid_description_head_scale(instance)
	return getPointer(instance).HeadScale;
end
function abi.ffi.prop_set_humanoid_description_head_scale(instance, p_HeadScale0)
	getPointer(instance).HeadScale = p_HeadScale0;
end
function abi.ffi.prop_get_humanoid_description_height_scale(instance)
	return getPointer(instance).HeightScale;
end
function abi.ffi.prop_set_humanoid_description_height_scale(instance, p_HeightScale0)
	getPointer(instance).HeightScale = p_HeightScale0;
end
function abi.ffi.prop_get_humanoid_description_idle_animation(instance)
	return getPointer(instance).IdleAnimation;
end
function abi.ffi.prop_set_humanoid_description_idle_animation(instance, p_IdleAnimation0)
	getPointer(instance).IdleAnimation = p_IdleAnimation0;
end
function abi.ffi.prop_get_humanoid_description_jump_animation(instance)
	return getPointer(instance).JumpAnimation;
end
function abi.ffi.prop_set_humanoid_description_jump_animation(instance, p_JumpAnimation0)
	getPointer(instance).JumpAnimation = p_JumpAnimation0;
end
function abi.ffi.prop_get_humanoid_description_left_arm(instance)
	return getPointer(instance).LeftArm;
end
function abi.ffi.prop_set_humanoid_description_left_arm(instance, p_LeftArm0)
	getPointer(instance).LeftArm = p_LeftArm0;
end
function abi.ffi.prop_get_humanoid_description_left_arm_color(instance)
	return createPointer(getPointer(instance).LeftArmColor);
end
function abi.ffi.prop_set_humanoid_description_left_arm_color(instance, p_LeftArmColor0)
	getPointer(instance).LeftArmColor = getPointer(p_LeftArmColor0);
end
function abi.ffi.prop_get_humanoid_description_left_leg(instance)
	return getPointer(instance).LeftLeg;
end
function abi.ffi.prop_set_humanoid_description_left_leg(instance, p_LeftLeg0)
	getPointer(instance).LeftLeg = p_LeftLeg0;
end
function abi.ffi.prop_get_humanoid_description_left_leg_color(instance)
	return createPointer(getPointer(instance).LeftLegColor);
end
function abi.ffi.prop_set_humanoid_description_left_leg_color(instance, p_LeftLegColor0)
	getPointer(instance).LeftLegColor = getPointer(p_LeftLegColor0);
end
function abi.ffi.prop_get_humanoid_description_mood_animation(instance)
	return getPointer(instance).MoodAnimation;
end
function abi.ffi.prop_set_humanoid_description_mood_animation(instance, p_MoodAnimation0)
	getPointer(instance).MoodAnimation = p_MoodAnimation0;
end
function abi.ffi.prop_get_humanoid_description_neck_accessory(output, instance)
	local value0 = getPointer(instance).NeckAccessory;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_humanoid_description_neck_accessory(instance, p_NeckAccessory0, p_NeckAccessory1)
	getPointer(instance).NeckAccessory = loadString(memory, p_NeckAccessory0, p_NeckAccessory1);
end
function abi.ffi.prop_get_humanoid_description_pants(instance)
	return getPointer(instance).Pants;
end
function abi.ffi.prop_set_humanoid_description_pants(instance, p_Pants0)
	getPointer(instance).Pants = p_Pants0;
end
function abi.ffi.prop_get_humanoid_description_proportion_scale(instance)
	return getPointer(instance).ProportionScale;
end
function abi.ffi.prop_set_humanoid_description_proportion_scale(instance, p_ProportionScale0)
	getPointer(instance).ProportionScale = p_ProportionScale0;
end
function abi.ffi.prop_get_humanoid_description_right_arm(instance)
	return getPointer(instance).RightArm;
end
function abi.ffi.prop_set_humanoid_description_right_arm(instance, p_RightArm0)
	getPointer(instance).RightArm = p_RightArm0;
end
function abi.ffi.prop_get_humanoid_description_right_arm_color(instance)
	return createPointer(getPointer(instance).RightArmColor);
end
function abi.ffi.prop_set_humanoid_description_right_arm_color(instance, p_RightArmColor0)
	getPointer(instance).RightArmColor = getPointer(p_RightArmColor0);
end
function abi.ffi.prop_get_humanoid_description_right_leg(instance)
	return getPointer(instance).RightLeg;
end
function abi.ffi.prop_set_humanoid_description_right_leg(instance, p_RightLeg0)
	getPointer(instance).RightLeg = p_RightLeg0;
end
function abi.ffi.prop_get_humanoid_description_right_leg_color(instance)
	return createPointer(getPointer(instance).RightLegColor);
end
function abi.ffi.prop_set_humanoid_description_right_leg_color(instance, p_RightLegColor0)
	getPointer(instance).RightLegColor = getPointer(p_RightLegColor0);
end
function abi.ffi.prop_get_humanoid_description_run_animation(instance)
	return getPointer(instance).RunAnimation;
end
function abi.ffi.prop_set_humanoid_description_run_animation(instance, p_RunAnimation0)
	getPointer(instance).RunAnimation = p_RunAnimation0;
end
function abi.ffi.prop_get_humanoid_description_shirt(instance)
	return getPointer(instance).Shirt;
end
function abi.ffi.prop_set_humanoid_description_shirt(instance, p_Shirt0)
	getPointer(instance).Shirt = p_Shirt0;
end
function abi.ffi.prop_get_humanoid_description_shoulders_accessory(output, instance)
	local value0 = getPointer(instance).ShouldersAccessory;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_humanoid_description_shoulders_accessory(instance, p_ShouldersAccessory0, p_ShouldersAccessory1)
	getPointer(instance).ShouldersAccessory = loadString(memory, p_ShouldersAccessory0, p_ShouldersAccessory1);
end
function abi.ffi.prop_get_humanoid_description_swim_animation(instance)
	return getPointer(instance).SwimAnimation;
end
function abi.ffi.prop_set_humanoid_description_swim_animation(instance, p_SwimAnimation0)
	getPointer(instance).SwimAnimation = p_SwimAnimation0;
end
function abi.ffi.prop_get_humanoid_description_torso(instance)
	return getPointer(instance).Torso;
end
function abi.ffi.prop_set_humanoid_description_torso(instance, p_Torso0)
	getPointer(instance).Torso = p_Torso0;
end
function abi.ffi.prop_get_humanoid_description_torso_color(instance)
	return createPointer(getPointer(instance).TorsoColor);
end
function abi.ffi.prop_set_humanoid_description_torso_color(instance, p_TorsoColor0)
	getPointer(instance).TorsoColor = getPointer(p_TorsoColor0);
end
function abi.ffi.prop_get_humanoid_description_waist_accessory(output, instance)
	local value0 = getPointer(instance).WaistAccessory;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_humanoid_description_waist_accessory(instance, p_WaistAccessory0, p_WaistAccessory1)
	getPointer(instance).WaistAccessory = loadString(memory, p_WaistAccessory0, p_WaistAccessory1);
end
function abi.ffi.prop_get_humanoid_description_walk_animation(instance)
	return getPointer(instance).WalkAnimation;
end
function abi.ffi.prop_set_humanoid_description_walk_animation(instance, p_WalkAnimation0)
	getPointer(instance).WalkAnimation = p_WalkAnimation0;
end
function abi.ffi.prop_get_humanoid_description_width_scale(instance)
	return getPointer(instance).WidthScale;
end
function abi.ffi.prop_set_humanoid_description_width_scale(instance, p_WidthScale0)
	getPointer(instance).WidthScale = p_WidthScale0;
end
function abi.ffi.dyn_fn_humanoid_description_add_emote(instance, p_name0, p_name1, p_assetId0)
	return getPointer(instance):AddEmote(loadString(memory, p_name0, p_name1), p_assetId0);
end
function abi.ffi.dyn_fn_humanoid_description_get_emotes(instance)
	return createPointer(getPointer(instance):GetEmotes());
end
function abi.ffi.dyn_fn_humanoid_description_remove_emote(instance, p_name0, p_name1)
	return getPointer(instance):RemoveEmote(loadString(memory, p_name0, p_name1));
end
function abi.ffi.dyn_fn_humanoid_description_set_emotes(instance, p_emotes0)
	return getPointer(instance):SetEmotes(getPointer(p_emotes0));
end
function abi.ffi.connect_humanoid_description_emotes_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).EmotesChanged:Connect(function(p_newEmotes)
		invokeFunction(data, vtable, createPointer(p_newEmotes));
	end))
end
function abi.ffi.prop_get_ik_control_alignment_offset(instance)
	return createPointer(getPointer(instance).AlignmentOffset);
end
function abi.ffi.prop_set_ik_control_alignment_offset(instance, p_AlignmentOffset0)
	getPointer(instance).AlignmentOffset = getPointer(p_AlignmentOffset0);
end
function abi.ffi.prop_get_ik_control_chain_root(output, instance)
	local value0 = getPointer(instance).ChainRoot;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_ik_control_chain_root(instance, p_ChainRoot0, p_ChainRoot1)
	local value0;
	if p_ChainRoot0 == 1 then
		value0 = getPointer(p_ChainRoot1);
	end
	getPointer(instance).ChainRoot = value0;
end
function abi.ffi.prop_get_ik_control_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_ik_control_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_ik_control_end_effector(output, instance)
	local value0 = getPointer(instance).EndEffector;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_ik_control_end_effector(instance, p_EndEffector0, p_EndEffector1)
	local value0;
	if p_EndEffector0 == 1 then
		value0 = getPointer(p_EndEffector1);
	end
	getPointer(instance).EndEffector = value0;
end
function abi.ffi.prop_get_ik_control_offset(instance)
	return createPointer(getPointer(instance).Offset);
end
function abi.ffi.prop_set_ik_control_offset(instance, p_Offset0)
	getPointer(instance).Offset = getPointer(p_Offset0);
end
function abi.ffi.prop_get_ik_control_pole(output, instance)
	local value0 = getPointer(instance).Pole;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_ik_control_pole(instance, p_Pole0, p_Pole1)
	local value0;
	if p_Pole0 == 1 then
		value0 = getPointer(p_Pole1);
	end
	getPointer(instance).Pole = value0;
end
function abi.ffi.prop_get_ik_control_priority(instance)
	return getPointer(instance).Priority;
end
function abi.ffi.prop_set_ik_control_priority(instance, p_Priority0)
	getPointer(instance).Priority = p_Priority0;
end
function abi.ffi.prop_get_ik_control_target(output, instance)
	local value0 = getPointer(instance).Target;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_ik_control_target(instance, p_Target0, p_Target1)
	local value0;
	if p_Target0 == 1 then
		value0 = getPointer(p_Target1);
	end
	getPointer(instance).Target = value0;
end
function abi.ffi.prop_get_ik_control_type(instance)
	return (getPointer(instance).Type).Value;
end
function abi.ffi.prop_set_ik_control_type(instance, p_Type0)
	getPointer(instance).Type = p_Type0;
end
function abi.ffi.prop_get_ik_control_weight(instance)
	return getPointer(instance).Weight;
end
function abi.ffi.prop_set_ik_control_weight(instance, p_Weight0)
	getPointer(instance).Weight = p_Weight0;
end
function abi.ffi.prop_get_importer_base_settings_id(output, instance)
	local value0 = getPointer(instance).Id;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_importer_base_settings_import_name(output, instance)
	local value0 = getPointer(instance).ImportName;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_importer_base_settings_import_name(instance, p_ImportName0, p_ImportName1)
	getPointer(instance).ImportName = loadString(memory, p_ImportName0, p_ImportName1);
end
function abi.ffi.prop_get_importer_base_settings_should_import(instance)
	return getPointer(instance).ShouldImport and 1 or 0;
end
function abi.ffi.prop_set_importer_base_settings_should_import(instance, p_ShouldImport0)
	getPointer(instance).ShouldImport = p_ShouldImport0 == 1;
end
function abi.ffi.prop_get_importer_group_settings_anchored(instance)
	return getPointer(instance).Anchored and 1 or 0;
end
function abi.ffi.prop_set_importer_group_settings_anchored(instance, p_Anchored0)
	getPointer(instance).Anchored = p_Anchored0 == 1;
end
function abi.ffi.prop_get_importer_group_settings_import_as_model_asset(instance)
	return getPointer(instance).ImportAsModelAsset and 1 or 0;
end
function abi.ffi.prop_set_importer_group_settings_import_as_model_asset(instance, p_ImportAsModelAsset0)
	getPointer(instance).ImportAsModelAsset = p_ImportAsModelAsset0 == 1;
end
function abi.ffi.prop_get_importer_group_settings_insert_in_workspace(instance)
	return getPointer(instance).InsertInWorkspace and 1 or 0;
end
function abi.ffi.prop_set_importer_group_settings_insert_in_workspace(instance, p_InsertInWorkspace0)
	getPointer(instance).InsertInWorkspace = p_InsertInWorkspace0 == 1;
end
function abi.ffi.prop_get_importer_material_settings_diffuse_file_path(output, instance)
	local value0 = getPointer(instance).DiffuseFilePath;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_importer_material_settings_diffuse_file_path(instance, p_DiffuseFilePath0, p_DiffuseFilePath1)
	getPointer(instance).DiffuseFilePath = loadString(memory, p_DiffuseFilePath0, p_DiffuseFilePath1);
end
function abi.ffi.prop_get_importer_material_settings_is_pbr(instance)
	return getPointer(instance).IsPbr and 1 or 0;
end
function abi.ffi.prop_get_importer_material_settings_metalness_file_path(output, instance)
	local value0 = getPointer(instance).MetalnessFilePath;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_importer_material_settings_metalness_file_path(instance, p_MetalnessFilePath0, p_MetalnessFilePath1)
	getPointer(instance).MetalnessFilePath = loadString(memory, p_MetalnessFilePath0, p_MetalnessFilePath1);
end
function abi.ffi.prop_get_importer_material_settings_normal_file_path(output, instance)
	local value0 = getPointer(instance).NormalFilePath;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_importer_material_settings_normal_file_path(instance, p_NormalFilePath0, p_NormalFilePath1)
	getPointer(instance).NormalFilePath = loadString(memory, p_NormalFilePath0, p_NormalFilePath1);
end
function abi.ffi.prop_get_importer_material_settings_roughness_file_path(output, instance)
	local value0 = getPointer(instance).RoughnessFilePath;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_importer_material_settings_roughness_file_path(instance, p_RoughnessFilePath0, p_RoughnessFilePath1)
	getPointer(instance).RoughnessFilePath = loadString(memory, p_RoughnessFilePath0, p_RoughnessFilePath1);
end
function abi.ffi.prop_get_importer_mesh_settings_anchored(instance)
	return getPointer(instance).Anchored and 1 or 0;
end
function abi.ffi.prop_set_importer_mesh_settings_anchored(instance, p_Anchored0)
	getPointer(instance).Anchored = p_Anchored0 == 1;
end
function abi.ffi.prop_get_importer_mesh_settings_cage_manifold(instance)
	return getPointer(instance).CageManifold and 1 or 0;
end
function abi.ffi.prop_get_importer_mesh_settings_cage_mesh_intersected_preview(instance)
	return getPointer(instance).CageMeshIntersectedPreview and 1 or 0;
end
function abi.ffi.prop_set_importer_mesh_settings_cage_mesh_intersected_preview(instance, p_CageMeshIntersectedPreview0)
	getPointer(instance).CageMeshIntersectedPreview = p_CageMeshIntersectedPreview0 == 1;
end
function abi.ffi.prop_get_importer_mesh_settings_cage_mesh_not_intersected(instance)
	return getPointer(instance).CageMeshNotIntersected and 1 or 0;
end
function abi.ffi.prop_get_importer_mesh_settings_cage_no_overlapping_vertices(instance)
	return getPointer(instance).CageNoOverlappingVertices and 1 or 0;
end
function abi.ffi.prop_get_importer_mesh_settings_cage_non_manifold_preview(instance)
	return getPointer(instance).CageNonManifoldPreview and 1 or 0;
end
function abi.ffi.prop_set_importer_mesh_settings_cage_non_manifold_preview(instance, p_CageNonManifoldPreview0)
	getPointer(instance).CageNonManifoldPreview = p_CageNonManifoldPreview0 == 1;
end
function abi.ffi.prop_get_importer_mesh_settings_cage_overlapping_vertices_preview(instance)
	return getPointer(instance).CageOverlappingVerticesPreview and 1 or 0;
end
function abi.ffi.prop_set_importer_mesh_settings_cage_overlapping_vertices_preview(instance, p_CageOverlappingVerticesPreview0)
	getPointer(instance).CageOverlappingVerticesPreview = p_CageOverlappingVerticesPreview0 == 1;
end
function abi.ffi.prop_get_importer_mesh_settings_cage_uv_matched(instance)
	return getPointer(instance).CageUVMatched and 1 or 0;
end
function abi.ffi.prop_get_importer_mesh_settings_cage_uv_mis_matched_preview(instance)
	return getPointer(instance).CageUVMisMatchedPreview and 1 or 0;
end
function abi.ffi.prop_set_importer_mesh_settings_cage_uv_mis_matched_preview(instance, p_CageUVMisMatchedPreview0)
	getPointer(instance).CageUVMisMatchedPreview = p_CageUVMisMatchedPreview0 == 1;
end
function abi.ffi.prop_get_importer_mesh_settings_dimensions(instance)
	return createPointer(getPointer(instance).Dimensions);
end
function abi.ffi.prop_get_importer_mesh_settings_double_sided(instance)
	return getPointer(instance).DoubleSided and 1 or 0;
end
function abi.ffi.prop_set_importer_mesh_settings_double_sided(instance, p_DoubleSided0)
	getPointer(instance).DoubleSided = p_DoubleSided0 == 1;
end
function abi.ffi.prop_get_importer_mesh_settings_ignore_vertex_colors(instance)
	return getPointer(instance).IgnoreVertexColors and 1 or 0;
end
function abi.ffi.prop_set_importer_mesh_settings_ignore_vertex_colors(instance, p_IgnoreVertexColors0)
	getPointer(instance).IgnoreVertexColors = p_IgnoreVertexColors0 == 1;
end
function abi.ffi.prop_get_importer_mesh_settings_irrelevant_cage_modified_preview(instance)
	return getPointer(instance).IrrelevantCageModifiedPreview and 1 or 0;
end
function abi.ffi.prop_set_importer_mesh_settings_irrelevant_cage_modified_preview(instance, p_IrrelevantCageModifiedPreview0)
	getPointer(instance).IrrelevantCageModifiedPreview = p_IrrelevantCageModifiedPreview0 == 1;
end
function abi.ffi.prop_get_importer_mesh_settings_mesh_hole_detected_preview(instance)
	return getPointer(instance).MeshHoleDetectedPreview and 1 or 0;
end
function abi.ffi.prop_set_importer_mesh_settings_mesh_hole_detected_preview(instance, p_MeshHoleDetectedPreview0)
	getPointer(instance).MeshHoleDetectedPreview = p_MeshHoleDetectedPreview0 == 1;
end
function abi.ffi.prop_get_importer_mesh_settings_mesh_no_hole_detected(instance)
	return getPointer(instance).MeshNoHoleDetected and 1 or 0;
end
function abi.ffi.prop_get_importer_mesh_settings_no_irrelevant_cage_modified(instance)
	return getPointer(instance).NoIrrelevantCageModified and 1 or 0;
end
function abi.ffi.prop_get_importer_mesh_settings_no_outer_cage_far_extended_from_mesh(instance)
	return getPointer(instance).NoOuterCageFarExtendedFromMesh and 1 or 0;
end
function abi.ffi.prop_get_importer_mesh_settings_outer_cage_far_extended_from_mesh_preview(instance)
	return getPointer(instance).OuterCageFarExtendedFromMeshPreview and 1 or 0;
end
function abi.ffi.prop_set_importer_mesh_settings_outer_cage_far_extended_from_mesh_preview(instance, p_OuterCageFarExtendedFromMeshPreview0)
	getPointer(instance).OuterCageFarExtendedFromMeshPreview = p_OuterCageFarExtendedFromMeshPreview0 == 1;
end
function abi.ffi.prop_get_importer_mesh_settings_polygon_count(instance)
	return getPointer(instance).PolygonCount;
end
function abi.ffi.prop_get_importer_mesh_settings_use_imported_pivot(instance)
	return getPointer(instance).UseImportedPivot and 1 or 0;
end
function abi.ffi.prop_set_importer_mesh_settings_use_imported_pivot(instance, p_UseImportedPivot0)
	getPointer(instance).UseImportedPivot = p_UseImportedPivot0 == 1;
end
function abi.ffi.prop_get_importer_root_settings_anchored(instance)
	return getPointer(instance).Anchored and 1 or 0;
end
function abi.ffi.prop_set_importer_root_settings_anchored(instance, p_Anchored0)
	getPointer(instance).Anchored = p_Anchored0 == 1;
end
function abi.ffi.prop_get_importer_root_settings_file_dimensions(instance)
	return createPointer(getPointer(instance).FileDimensions);
end
function abi.ffi.prop_get_importer_root_settings_import_as_model_asset(instance)
	return getPointer(instance).ImportAsModelAsset and 1 or 0;
end
function abi.ffi.prop_set_importer_root_settings_import_as_model_asset(instance, p_ImportAsModelAsset0)
	getPointer(instance).ImportAsModelAsset = p_ImportAsModelAsset0 == 1;
end
function abi.ffi.prop_get_importer_root_settings_insert_in_workspace(instance)
	return getPointer(instance).InsertInWorkspace and 1 or 0;
end
function abi.ffi.prop_set_importer_root_settings_insert_in_workspace(instance, p_InsertInWorkspace0)
	getPointer(instance).InsertInWorkspace = p_InsertInWorkspace0 == 1;
end
function abi.ffi.prop_get_importer_root_settings_insert_with_scene_position(instance)
	return getPointer(instance).InsertWithScenePosition and 1 or 0;
end
function abi.ffi.prop_set_importer_root_settings_insert_with_scene_position(instance, p_InsertWithScenePosition0)
	getPointer(instance).InsertWithScenePosition = p_InsertWithScenePosition0 == 1;
end
function abi.ffi.prop_get_importer_root_settings_invert_negative_faces(instance)
	return getPointer(instance).InvertNegativeFaces and 1 or 0;
end
function abi.ffi.prop_set_importer_root_settings_invert_negative_faces(instance, p_InvertNegativeFaces0)
	getPointer(instance).InvertNegativeFaces = p_InvertNegativeFaces0 == 1;
end
function abi.ffi.prop_get_importer_root_settings_merge_meshes(instance)
	return getPointer(instance).MergeMeshes and 1 or 0;
end
function abi.ffi.prop_set_importer_root_settings_merge_meshes(instance, p_MergeMeshes0)
	getPointer(instance).MergeMeshes = p_MergeMeshes0 == 1;
end
function abi.ffi.prop_get_importer_root_settings_polygon_count(instance)
	return getPointer(instance).PolygonCount;
end
function abi.ffi.prop_get_importer_root_settings_rig_type(instance)
	return (getPointer(instance).RigType).Value;
end
function abi.ffi.prop_set_importer_root_settings_rig_type(instance, p_RigType0)
	getPointer(instance).RigType = p_RigType0;
end
function abi.ffi.prop_get_importer_root_settings_scale_unit(instance)
	return (getPointer(instance).ScaleUnit).Value;
end
function abi.ffi.prop_set_importer_root_settings_scale_unit(instance, p_ScaleUnit0)
	getPointer(instance).ScaleUnit = p_ScaleUnit0;
end
function abi.ffi.prop_get_importer_root_settings_use_scene_origin_as_pivot(instance)
	return getPointer(instance).UseSceneOriginAsPivot and 1 or 0;
end
function abi.ffi.prop_set_importer_root_settings_use_scene_origin_as_pivot(instance, p_UseSceneOriginAsPivot0)
	getPointer(instance).UseSceneOriginAsPivot = p_UseSceneOriginAsPivot0 == 1;
end
function abi.ffi.prop_get_importer_root_settings_world_forward(instance)
	return (getPointer(instance).WorldForward).Value;
end
function abi.ffi.prop_set_importer_root_settings_world_forward(instance, p_WorldForward0)
	getPointer(instance).WorldForward = p_WorldForward0;
end
function abi.ffi.prop_get_importer_root_settings_world_up(instance)
	return (getPointer(instance).WorldUp).Value;
end
function abi.ffi.prop_set_importer_root_settings_world_up(instance, p_WorldUp0)
	getPointer(instance).WorldUp = p_WorldUp0;
end
function abi.ffi.prop_get_input_object_delta(instance)
	return createPointer(getPointer(instance).Delta);
end
function abi.ffi.prop_set_input_object_delta(instance, p_Delta0)
	getPointer(instance).Delta = getPointer(p_Delta0);
end
function abi.ffi.prop_get_input_object_key_code(instance)
	return (getPointer(instance).KeyCode).Value;
end
function abi.ffi.prop_set_input_object_key_code(instance, p_KeyCode0)
	getPointer(instance).KeyCode = p_KeyCode0;
end
function abi.ffi.prop_get_input_object_position(instance)
	return createPointer(getPointer(instance).Position);
end
function abi.ffi.prop_set_input_object_position(instance, p_Position0)
	getPointer(instance).Position = getPointer(p_Position0);
end
function abi.ffi.prop_get_input_object_user_input_state(instance)
	return (getPointer(instance).UserInputState).Value;
end
function abi.ffi.prop_set_input_object_user_input_state(instance, p_UserInputState0)
	getPointer(instance).UserInputState = p_UserInputState0;
end
function abi.ffi.prop_get_input_object_user_input_type(instance)
	return (getPointer(instance).UserInputType).Value;
end
function abi.ffi.prop_set_input_object_user_input_type(instance, p_UserInputType0)
	getPointer(instance).UserInputType = p_UserInputType0;
end
function abi.ffi.dyn_fn_input_object_is_modifier_key_down(instance, p_modifierKey0)
	return getPointer(instance):IsModifierKeyDown(p_modifierKey0) and 1 or 0;
end
function abi.ffi.dyn_fn_insert_service_get_latest_asset_version_async(instance, p_assetId0)
	return getPointer(instance):GetLatestAssetVersionAsync(p_assetId0);
end
function abi.ffi.dyn_fn_insert_service_load_asset(output, instance, p_assetId0)
	local value0 = getPointer(instance):LoadAsset(p_assetId0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_insert_service_load_asset_version(output, instance, p_assetVersionId0)
	local value0 = getPointer(instance):LoadAssetVersion(p_assetVersionId0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_joint_instance_active(instance)
	return getPointer(instance).Active and 1 or 0;
end
function abi.ffi.prop_get_joint_instance_c_0(instance)
	return createPointer(getPointer(instance).C0);
end
function abi.ffi.prop_set_joint_instance_c_0(instance, p_C00)
	getPointer(instance).C0 = getPointer(p_C00);
end
function abi.ffi.prop_get_joint_instance_c_1(instance)
	return createPointer(getPointer(instance).C1);
end
function abi.ffi.prop_set_joint_instance_c_1(instance, p_C10)
	getPointer(instance).C1 = getPointer(p_C10);
end
function abi.ffi.prop_get_joint_instance_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_joint_instance_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_joint_instance_part_0(output, instance)
	local value0 = getPointer(instance).Part0;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_joint_instance_part_0(instance, p_Part00, p_Part01)
	local value0;
	if p_Part00 == 1 then
		value0 = getPointer(p_Part01);
	end
	getPointer(instance).Part0 = value0;
end
function abi.ffi.prop_get_joint_instance_part_1(output, instance)
	local value0 = getPointer(instance).Part1;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_joint_instance_part_1(instance, p_Part10, p_Part11)
	local value0;
	if p_Part10 == 1 then
		value0 = getPointer(p_Part11);
	end
	getPointer(instance).Part1 = value0;
end
function abi.ffi.prop_get_dynamic_rotate_base_angle(instance)
	return getPointer(instance).BaseAngle;
end
function abi.ffi.prop_set_dynamic_rotate_base_angle(instance, p_BaseAngle0)
	getPointer(instance).BaseAngle = p_BaseAngle0;
end
function abi.ffi.prop_get_motor_current_angle(instance)
	return getPointer(instance).CurrentAngle;
end
function abi.ffi.prop_set_motor_current_angle(instance, p_CurrentAngle0)
	getPointer(instance).CurrentAngle = p_CurrentAngle0;
end
function abi.ffi.prop_get_motor_desired_angle(instance)
	return getPointer(instance).DesiredAngle;
end
function abi.ffi.prop_set_motor_desired_angle(instance, p_DesiredAngle0)
	getPointer(instance).DesiredAngle = p_DesiredAngle0;
end
function abi.ffi.prop_get_motor_max_velocity(instance)
	return getPointer(instance).MaxVelocity;
end
function abi.ffi.prop_set_motor_max_velocity(instance, p_MaxVelocity0)
	getPointer(instance).MaxVelocity = p_MaxVelocity0;
end
function abi.ffi.dyn_fn_motor_fn_set_desired_angle(instance, p_value0)
	return getPointer(instance):FnSetDesiredAngle(p_value0);
end
function abi.ffi.prop_get_motor_6_d_transform(instance)
	return createPointer(getPointer(instance).Transform);
end
function abi.ffi.prop_set_motor_6_d_transform(instance, p_Transform0)
	getPointer(instance).Transform = getPointer(p_Transform0);
end
function abi.ffi.prop_get_velocity_motor_current_angle(instance)
	return getPointer(instance).CurrentAngle;
end
function abi.ffi.prop_set_velocity_motor_current_angle(instance, p_CurrentAngle0)
	getPointer(instance).CurrentAngle = p_CurrentAngle0;
end
function abi.ffi.prop_get_velocity_motor_desired_angle(instance)
	return getPointer(instance).DesiredAngle;
end
function abi.ffi.prop_set_velocity_motor_desired_angle(instance, p_DesiredAngle0)
	getPointer(instance).DesiredAngle = p_DesiredAngle0;
end
function abi.ffi.prop_get_velocity_motor_max_velocity(instance)
	return getPointer(instance).MaxVelocity;
end
function abi.ffi.prop_set_velocity_motor_max_velocity(instance, p_MaxVelocity0)
	getPointer(instance).MaxVelocity = p_MaxVelocity0;
end
function abi.ffi.prop_get_keyframe_time(instance)
	return getPointer(instance).Time;
end
function abi.ffi.prop_set_keyframe_time(instance, p_Time0)
	getPointer(instance).Time = p_Time0;
end
function abi.ffi.dyn_fn_keyframe_add_marker(instance, p_marker0)
	return getPointer(instance):AddMarker(getPointer(p_marker0));
end
function abi.ffi.dyn_fn_keyframe_add_pose(instance, p_pose0)
	return getPointer(instance):AddPose(getPointer(p_pose0));
end
function abi.ffi.dyn_fn_keyframe_get_markers(output, instance)
	local result0 = getPointer(instance):GetMarkers();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_keyframe_get_poses(output, instance)
	local result0 = getPointer(instance):GetPoses();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_keyframe_remove_marker(instance, p_marker0)
	return getPointer(instance):RemoveMarker(getPointer(p_marker0));
end
function abi.ffi.dyn_fn_keyframe_remove_pose(instance, p_pose0)
	return getPointer(instance):RemovePose(getPointer(p_pose0));
end
function abi.ffi.prop_get_keyframe_marker_value(output, instance)
	local value0 = getPointer(instance).Value;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_keyframe_marker_value(instance, p_Value0, p_Value1)
	getPointer(instance).Value = loadString(memory, p_Value0, p_Value1);
end
function abi.ffi.dyn_fn_keyframe_sequence_provider_register_active_keyframe_sequence(instance, p_keyframeSequence0)
	return createPointer(getPointer(instance):RegisterActiveKeyframeSequence(getPointer(p_keyframeSequence0)));
end
function abi.ffi.dyn_fn_keyframe_sequence_provider_register_keyframe_sequence(instance, p_keyframeSequence0)
	return createPointer(getPointer(instance):RegisterKeyframeSequence(getPointer(p_keyframeSequence0)));
end
function abi.ffi.dyn_fn_keyframe_sequence_provider_get_animations(output, instance, p_userId0)
	local value0 = getPointer(instance):GetAnimations(p_userId0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_keyframe_sequence_provider_get_keyframe_sequence_async(output, instance, p_assetId0)
	local value0 = getPointer(instance):GetKeyframeSequenceAsync(getPointer(p_assetId0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_light_brightness(instance)
	return getPointer(instance).Brightness;
end
function abi.ffi.prop_set_light_brightness(instance, p_Brightness0)
	getPointer(instance).Brightness = p_Brightness0;
end
function abi.ffi.prop_get_light_color(instance)
	return createPointer(getPointer(instance).Color);
end
function abi.ffi.prop_set_light_color(instance, p_Color0)
	getPointer(instance).Color = getPointer(p_Color0);
end
function abi.ffi.prop_get_light_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_light_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_light_shadows(instance)
	return getPointer(instance).Shadows and 1 or 0;
end
function abi.ffi.prop_set_light_shadows(instance, p_Shadows0)
	getPointer(instance).Shadows = p_Shadows0 == 1;
end
function abi.ffi.prop_get_point_light_range(instance)
	return getPointer(instance).Range;
end
function abi.ffi.prop_set_point_light_range(instance, p_Range0)
	getPointer(instance).Range = p_Range0;
end
function abi.ffi.prop_get_spot_light_angle(instance)
	return getPointer(instance).Angle;
end
function abi.ffi.prop_set_spot_light_angle(instance, p_Angle0)
	getPointer(instance).Angle = p_Angle0;
end
function abi.ffi.prop_get_spot_light_face(instance)
	return (getPointer(instance).Face).Value;
end
function abi.ffi.prop_set_spot_light_face(instance, p_Face0)
	getPointer(instance).Face = p_Face0;
end
function abi.ffi.prop_get_spot_light_range(instance)
	return getPointer(instance).Range;
end
function abi.ffi.prop_set_spot_light_range(instance, p_Range0)
	getPointer(instance).Range = p_Range0;
end
function abi.ffi.prop_get_surface_light_angle(instance)
	return getPointer(instance).Angle;
end
function abi.ffi.prop_set_surface_light_angle(instance, p_Angle0)
	getPointer(instance).Angle = p_Angle0;
end
function abi.ffi.prop_get_surface_light_face(instance)
	return (getPointer(instance).Face).Value;
end
function abi.ffi.prop_set_surface_light_face(instance, p_Face0)
	getPointer(instance).Face = p_Face0;
end
function abi.ffi.prop_get_surface_light_range(instance)
	return getPointer(instance).Range;
end
function abi.ffi.prop_set_surface_light_range(instance, p_Range0)
	getPointer(instance).Range = p_Range0;
end
function abi.ffi.prop_get_lighting_ambient(instance)
	return createPointer(getPointer(instance).Ambient);
end
function abi.ffi.prop_set_lighting_ambient(instance, p_Ambient0)
	getPointer(instance).Ambient = getPointer(p_Ambient0);
end
function abi.ffi.prop_get_lighting_brightness(instance)
	return getPointer(instance).Brightness;
end
function abi.ffi.prop_set_lighting_brightness(instance, p_Brightness0)
	getPointer(instance).Brightness = p_Brightness0;
end
function abi.ffi.prop_get_lighting_clock_time(instance)
	return getPointer(instance).ClockTime;
end
function abi.ffi.prop_set_lighting_clock_time(instance, p_ClockTime0)
	getPointer(instance).ClockTime = p_ClockTime0;
end
function abi.ffi.prop_get_lighting_color_shift_bottom(instance)
	return createPointer(getPointer(instance).ColorShift_Bottom);
end
function abi.ffi.prop_set_lighting_color_shift_bottom(instance, p_ColorShift_Bottom0)
	getPointer(instance).ColorShift_Bottom = getPointer(p_ColorShift_Bottom0);
end
function abi.ffi.prop_get_lighting_color_shift_top(instance)
	return createPointer(getPointer(instance).ColorShift_Top);
end
function abi.ffi.prop_set_lighting_color_shift_top(instance, p_ColorShift_Top0)
	getPointer(instance).ColorShift_Top = getPointer(p_ColorShift_Top0);
end
function abi.ffi.prop_get_lighting_environment_diffuse_scale(instance)
	return getPointer(instance).EnvironmentDiffuseScale;
end
function abi.ffi.prop_set_lighting_environment_diffuse_scale(instance, p_EnvironmentDiffuseScale0)
	getPointer(instance).EnvironmentDiffuseScale = p_EnvironmentDiffuseScale0;
end
function abi.ffi.prop_get_lighting_environment_specular_scale(instance)
	return getPointer(instance).EnvironmentSpecularScale;
end
function abi.ffi.prop_set_lighting_environment_specular_scale(instance, p_EnvironmentSpecularScale0)
	getPointer(instance).EnvironmentSpecularScale = p_EnvironmentSpecularScale0;
end
function abi.ffi.prop_get_lighting_exposure_compensation(instance)
	return getPointer(instance).ExposureCompensation;
end
function abi.ffi.prop_set_lighting_exposure_compensation(instance, p_ExposureCompensation0)
	getPointer(instance).ExposureCompensation = p_ExposureCompensation0;
end
function abi.ffi.prop_get_lighting_fog_color(instance)
	return createPointer(getPointer(instance).FogColor);
end
function abi.ffi.prop_set_lighting_fog_color(instance, p_FogColor0)
	getPointer(instance).FogColor = getPointer(p_FogColor0);
end
function abi.ffi.prop_get_lighting_fog_end(instance)
	return getPointer(instance).FogEnd;
end
function abi.ffi.prop_set_lighting_fog_end(instance, p_FogEnd0)
	getPointer(instance).FogEnd = p_FogEnd0;
end
function abi.ffi.prop_get_lighting_fog_start(instance)
	return getPointer(instance).FogStart;
end
function abi.ffi.prop_set_lighting_fog_start(instance, p_FogStart0)
	getPointer(instance).FogStart = p_FogStart0;
end
function abi.ffi.prop_get_lighting_geographic_latitude(instance)
	return getPointer(instance).GeographicLatitude;
end
function abi.ffi.prop_set_lighting_geographic_latitude(instance, p_GeographicLatitude0)
	getPointer(instance).GeographicLatitude = p_GeographicLatitude0;
end
function abi.ffi.prop_get_lighting_global_shadows(instance)
	return getPointer(instance).GlobalShadows and 1 or 0;
end
function abi.ffi.prop_set_lighting_global_shadows(instance, p_GlobalShadows0)
	getPointer(instance).GlobalShadows = p_GlobalShadows0 == 1;
end
function abi.ffi.prop_get_lighting_outdoor_ambient(instance)
	return createPointer(getPointer(instance).OutdoorAmbient);
end
function abi.ffi.prop_set_lighting_outdoor_ambient(instance, p_OutdoorAmbient0)
	getPointer(instance).OutdoorAmbient = getPointer(p_OutdoorAmbient0);
end
function abi.ffi.prop_get_lighting_shadow_softness(instance)
	return getPointer(instance).ShadowSoftness;
end
function abi.ffi.prop_set_lighting_shadow_softness(instance, p_ShadowSoftness0)
	getPointer(instance).ShadowSoftness = p_ShadowSoftness0;
end
function abi.ffi.prop_get_lighting_time_of_day(output, instance)
	local value0 = getPointer(instance).TimeOfDay;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_lighting_time_of_day(instance, p_TimeOfDay0, p_TimeOfDay1)
	getPointer(instance).TimeOfDay = loadString(memory, p_TimeOfDay0, p_TimeOfDay1);
end
function abi.ffi.dyn_fn_lighting_get_minutes_after_midnight(instance)
	return getPointer(instance):GetMinutesAfterMidnight();
end
function abi.ffi.dyn_fn_lighting_get_moon_direction(instance)
	return createPointer(getPointer(instance):GetMoonDirection());
end
function abi.ffi.dyn_fn_lighting_get_moon_phase(instance)
	return getPointer(instance):GetMoonPhase();
end
function abi.ffi.dyn_fn_lighting_get_sun_direction(instance)
	return createPointer(getPointer(instance):GetSunDirection());
end
function abi.ffi.dyn_fn_lighting_set_minutes_after_midnight(instance, p_minutes0)
	return getPointer(instance):SetMinutesAfterMidnight(p_minutes0);
end
function abi.ffi.connect_lighting_lighting_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).LightingChanged:Connect(function(p_skyChanged)
		invokeFunction(data, vtable, p_skyChanged and 1 or 0);
	end))
end
function abi.ffi.prop_get_localization_service_roblox_locale_id(output, instance)
	local value0 = getPointer(instance).RobloxLocaleId;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_localization_service_system_locale_id(output, instance)
	local value0 = getPointer(instance).SystemLocaleId;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_localization_service_get_corescript_localizations(output, instance)
	local result0 = getPointer(instance):GetCorescriptLocalizations();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_localization_service_get_translator_for_player(output, instance, p_player0)
	local value0 = getPointer(instance):GetTranslatorForPlayer(getPointer(p_player0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_localization_service_get_country_region_for_player_async(output, instance, p_player0)
	local value0 = getPointer(instance):GetCountryRegionForPlayerAsync(getPointer(p_player0));
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_localization_service_get_translator_for_locale_async(output, instance, p_locale0, p_locale1)
	local value0 = getPointer(instance):GetTranslatorForLocaleAsync(loadString(memory, p_locale0, p_locale1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_localization_service_get_translator_for_player_async(output, instance, p_player0)
	local value0 = getPointer(instance):GetTranslatorForPlayerAsync(getPointer(p_player0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_localization_table_source_locale_id(output, instance)
	local value0 = getPointer(instance).SourceLocaleId;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_localization_table_source_locale_id(instance, p_SourceLocaleId0, p_SourceLocaleId1)
	getPointer(instance).SourceLocaleId = loadString(memory, p_SourceLocaleId0, p_SourceLocaleId1);
end
function abi.ffi.dyn_fn_localization_table_get_translator(output, instance, p_localeId0, p_localeId1)
	local value0 = getPointer(instance):GetTranslator(loadString(memory, p_localeId0, p_localeId1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_localization_table_remove_entry(instance, p_key0, p_key1, p_source0, p_source1, p_context0, p_context1)
	return getPointer(instance):RemoveEntry(loadString(memory, p_key0, p_key1), loadString(memory, p_source0, p_source1), loadString(memory, p_context0, p_context1));
end
function abi.ffi.dyn_fn_localization_table_remove_entry_value(instance, p_key0, p_key1, p_source0, p_source1, p_context0, p_context1, p_localeId0, p_localeId1)
	return getPointer(instance):RemoveEntryValue(loadString(memory, p_key0, p_key1), loadString(memory, p_source0, p_source1), loadString(memory, p_context0, p_context1), loadString(memory, p_localeId0, p_localeId1));
end
function abi.ffi.dyn_fn_localization_table_remove_target_locale(instance, p_localeId0, p_localeId1)
	return getPointer(instance):RemoveTargetLocale(loadString(memory, p_localeId0, p_localeId1));
end
function abi.ffi.dyn_fn_localization_table_set_entries(instance, p_entries0)
	return getPointer(instance):SetEntries(getPointer(p_entries0));
end
function abi.ffi.dyn_fn_localization_table_set_entry_context(instance, p_key0, p_key1, p_source0, p_source1, p_context0, p_context1, p_newContext0, p_newContext1)
	return getPointer(instance):SetEntryContext(loadString(memory, p_key0, p_key1), loadString(memory, p_source0, p_source1), loadString(memory, p_context0, p_context1), loadString(memory, p_newContext0, p_newContext1));
end
function abi.ffi.dyn_fn_localization_table_set_entry_example(instance, p_key0, p_key1, p_source0, p_source1, p_context0, p_context1, p_example0, p_example1)
	return getPointer(instance):SetEntryExample(loadString(memory, p_key0, p_key1), loadString(memory, p_source0, p_source1), loadString(memory, p_context0, p_context1), loadString(memory, p_example0, p_example1));
end
function abi.ffi.dyn_fn_localization_table_set_entry_key(instance, p_key0, p_key1, p_source0, p_source1, p_context0, p_context1, p_newKey0, p_newKey1)
	return getPointer(instance):SetEntryKey(loadString(memory, p_key0, p_key1), loadString(memory, p_source0, p_source1), loadString(memory, p_context0, p_context1), loadString(memory, p_newKey0, p_newKey1));
end
function abi.ffi.dyn_fn_localization_table_set_entry_source(instance, p_key0, p_key1, p_source0, p_source1, p_context0, p_context1, p_newSource0, p_newSource1)
	return getPointer(instance):SetEntrySource(loadString(memory, p_key0, p_key1), loadString(memory, p_source0, p_source1), loadString(memory, p_context0, p_context1), loadString(memory, p_newSource0, p_newSource1));
end
function abi.ffi.dyn_fn_localization_table_set_entry_value(instance, p_key0, p_key1, p_source0, p_source1, p_context0, p_context1, p_localeId0, p_localeId1, p_text0, p_text1)
	return getPointer(instance):SetEntryValue(loadString(memory, p_key0, p_key1), loadString(memory, p_source0, p_source1), loadString(memory, p_context0, p_context1), loadString(memory, p_localeId0, p_localeId1), loadString(memory, p_text0, p_text1));
end
function abi.ffi.prop_get_lod_data_entity_entity_lod_enabled(instance)
	return getPointer(instance).EntityLodEnabled and 1 or 0;
end
function abi.ffi.prop_set_lod_data_entity_entity_lod_enabled(instance, p_EntityLodEnabled0)
	getPointer(instance).EntityLodEnabled = p_EntityLodEnabled0 == 1;
end
function abi.ffi.connect_log_service_message_out(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MessageOut:Connect(function(p_message, p_messageType)
		local value0 = p_message;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0, (p_messageType).Value);
	end))
end
function abi.ffi.prop_get_base_script_disabled(instance)
	return getPointer(instance).Disabled and 1 or 0;
end
function abi.ffi.prop_set_base_script_disabled(instance, p_Disabled0)
	getPointer(instance).Disabled = p_Disabled0 == 1;
end
function abi.ffi.prop_get_base_script_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_base_script_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_base_script_linked_source(instance)
	return createPointer(getPointer(instance).LinkedSource);
end
function abi.ffi.prop_set_base_script_linked_source(instance, p_LinkedSource0)
	getPointer(instance).LinkedSource = getPointer(p_LinkedSource0);
end
function abi.ffi.prop_get_module_script_linked_source(instance)
	return createPointer(getPointer(instance).LinkedSource);
end
function abi.ffi.prop_set_module_script_linked_source(instance, p_LinkedSource0)
	getPointer(instance).LinkedSource = getPointer(p_LinkedSource0);
end
function abi.ffi.prop_get_marker_curve_length(instance)
	return getPointer(instance).Length;
end
function abi.ffi.dyn_fn_marker_curve_get_marker_at_index(instance, p_index0)
	return createPointer(getPointer(instance):GetMarkerAtIndex(p_index0));
end
function abi.ffi.dyn_fn_marker_curve_remove_marker_at_index(instance, p_startingIndex0, p_count0)
	return getPointer(instance):RemoveMarkerAtIndex(p_startingIndex0, p_count0);
end
function abi.ffi.dyn_fn_marketplace_service_prompt_bundle_purchase(instance, p_player0, p_bundleId0)
	return getPointer(instance):PromptBundlePurchase(getPointer(p_player0), p_bundleId0);
end
function abi.ffi.dyn_fn_marketplace_service_prompt_game_pass_purchase(instance, p_player0, p_gamePassId0)
	return getPointer(instance):PromptGamePassPurchase(getPointer(p_player0), p_gamePassId0);
end
function abi.ffi.dyn_fn_marketplace_service_prompt_premium_purchase(instance, p_player0)
	return getPointer(instance):PromptPremiumPurchase(getPointer(p_player0));
end
function abi.ffi.dyn_fn_marketplace_service_prompt_product_purchase(instance, p_player0, p_productId0, p_equipIfPurchased0, p_currencyType0)
	return getPointer(instance):PromptProductPurchase(getPointer(p_player0), p_productId0, p_equipIfPurchased0 == 1, p_currencyType0);
end
function abi.ffi.dyn_fn_marketplace_service_prompt_purchase(instance, p_player0, p_assetId0, p_equipIfPurchased0, p_currencyType0)
	return getPointer(instance):PromptPurchase(getPointer(p_player0), p_assetId0, p_equipIfPurchased0 == 1, p_currencyType0);
end
function abi.ffi.dyn_fn_marketplace_service_prompt_subscription_cancellation(instance, p_player0, p_subscriptionId0)
	return getPointer(instance):PromptSubscriptionCancellation(getPointer(p_player0), p_subscriptionId0);
end
function abi.ffi.dyn_fn_marketplace_service_prompt_subscription_purchase(instance, p_player0, p_subscriptionId0)
	return getPointer(instance):PromptSubscriptionPurchase(getPointer(p_player0), p_subscriptionId0);
end
function abi.ffi.dyn_fn_marketplace_service_get_developer_products_async(output, instance)
	local value0 = getPointer(instance):GetDeveloperProductsAsync();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_marketplace_service_get_product_info(instance, p_assetId0, p_infoType0)
	return createPointer(getPointer(instance):GetProductInfo(p_assetId0, p_infoType0));
end
function abi.ffi.dyn_fn_marketplace_service_is_player_subscribed(instance, p_player0, p_subscriptionId0)
	return getPointer(instance):IsPlayerSubscribed(getPointer(p_player0), p_subscriptionId0) and 1 or 0;
end
function abi.ffi.dyn_fn_marketplace_service_player_owns_asset(instance, p_player0, p_assetId0)
	return getPointer(instance):PlayerOwnsAsset(getPointer(p_player0), p_assetId0) and 1 or 0;
end
function abi.ffi.dyn_fn_marketplace_service_player_owns_bundle(instance, p_player0, p_bundleId0)
	return getPointer(instance):PlayerOwnsBundle(getPointer(p_player0), p_bundleId0) and 1 or 0;
end
function abi.ffi.dyn_fn_marketplace_service_user_owns_game_pass_async(instance, p_userId0, p_gamePassId0)
	return getPointer(instance):UserOwnsGamePassAsync(p_userId0, p_gamePassId0) and 1 or 0;
end
function abi.ffi.connect_marketplace_service_prompt_bundle_purchase_finished(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptBundlePurchaseFinished:Connect(function(p_player, p_bundleId, p_wasPurchased)
		local value0 = p_player;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, p_bundleId, p_wasPurchased and 1 or 0);
	end))
end
function abi.ffi.connect_marketplace_service_prompt_game_pass_purchase_finished(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptGamePassPurchaseFinished:Connect(function(p_player, p_gamePassId, p_wasPurchased)
		local value0 = p_player;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, p_gamePassId, p_wasPurchased and 1 or 0);
	end))
end
function abi.ffi.connect_marketplace_service_prompt_premium_purchase_finished(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptPremiumPurchaseFinished:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_marketplace_service_prompt_purchase_finished(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptPurchaseFinished:Connect(function(p_player, p_assetId, p_isPurchased)
		local value0 = p_player;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, p_assetId, p_isPurchased and 1 or 0);
	end))
end
function abi.ffi.connect_marketplace_service_prompt_subscription_cancellation_finished(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptSubscriptionCancellationFinished:Connect(function(p_player, p_subscriptionId, p_wasCanceled)
		local value0 = p_player;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, p_subscriptionId, p_wasCanceled and 1 or 0);
	end))
end
function abi.ffi.connect_marketplace_service_prompt_subscription_purchase_finished(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptSubscriptionPurchaseFinished:Connect(function(p_player, p_subscriptionId, p_wasPurchased)
		local value0 = p_player;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, p_subscriptionId, p_wasPurchased and 1 or 0);
	end))
end
function abi.ffi.callback_set_marketplace_service_process_receipt(instance, destructor, data, vtable)
	getPointer(instance).ProcessReceipt = function(p_receiptInfo)
		local response0 = invokeFunction(data, vtable, createPointer(p_receiptInfo))
		functions.data[destructor](response0);
		return response0;
	end
end
function abi.ffi.dyn_fn_material_service_get_base_material_override(output, instance, p_material0)
	local value0 = getPointer(instance):GetBaseMaterialOverride(p_material0);
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_material_service_get_material_variant(output, instance, p_material0, p_name0, p_name1)
	local value0 = getPointer(instance):GetMaterialVariant(p_material0, loadString(memory, p_name0, p_name1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_material_service_set_base_material_override(instance, p_material0, p_name0, p_name1)
	return getPointer(instance):SetBaseMaterialOverride(p_material0, loadString(memory, p_name0, p_name1));
end
function abi.ffi.prop_get_material_variant_custom_physical_properties(instance)
	return createPointer(getPointer(instance).CustomPhysicalProperties);
end
function abi.ffi.prop_set_material_variant_custom_physical_properties(instance, p_CustomPhysicalProperties0)
	getPointer(instance).CustomPhysicalProperties = getPointer(p_CustomPhysicalProperties0);
end
function abi.ffi.prop_get_material_variant_material_pattern(instance)
	return (getPointer(instance).MaterialPattern).Value;
end
function abi.ffi.prop_set_material_variant_material_pattern(instance, p_MaterialPattern0)
	getPointer(instance).MaterialPattern = p_MaterialPattern0;
end
function abi.ffi.prop_get_material_variant_studs_per_tile(instance)
	return getPointer(instance).StudsPerTile;
end
function abi.ffi.prop_set_material_variant_studs_per_tile(instance, p_StudsPerTile0)
	getPointer(instance).StudsPerTile = p_StudsPerTile0;
end
function abi.ffi.dyn_fn_memory_store_queue_add_async(instance, p_value0, p_expiration0, p_priority0)
	return getPointer(instance):AddAsync(getPointer(p_value0), p_expiration0, p_priority0);
end
function abi.ffi.dyn_fn_memory_store_queue_remove_async(instance, p_id0, p_id1)
	return getPointer(instance):RemoveAsync(loadString(memory, p_id0, p_id1));
end
function abi.ffi.dyn_fn_memory_store_service_get_queue(output, instance, p_name0, p_name1, p_invisibilityTimeout0)
	local value0 = getPointer(instance):GetQueue(loadString(memory, p_name0, p_name1), p_invisibilityTimeout0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_memory_store_service_get_sorted_map(output, instance, p_name0, p_name1)
	local value0 = getPointer(instance):GetSortedMap(loadString(memory, p_name0, p_name1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_memory_store_sorted_map_get_async(instance, p_key0, p_key1)
	return createPointer(getPointer(instance):GetAsync(loadString(memory, p_key0, p_key1)));
end
function abi.ffi.dyn_fn_memory_store_sorted_map_remove_async(instance, p_key0, p_key1)
	return getPointer(instance):RemoveAsync(loadString(memory, p_key0, p_key1));
end
function abi.ffi.dyn_fn_memory_store_sorted_map_set_async(instance, p_key0, p_key1, p_value0, p_expiration0)
	return getPointer(instance):SetAsync(loadString(memory, p_key0, p_key1), getPointer(p_value0), p_expiration0) and 1 or 0;
end
function abi.ffi.dyn_fn_messaging_service_publish_async(instance, p_topic0, p_topic1, p_message0)
	return getPointer(instance):PublishAsync(loadString(memory, p_topic0, p_topic1), getPointer(p_message0));
end
function abi.ffi.prop_get_mouse_hit(instance)
	return createPointer(getPointer(instance).Hit);
end
function abi.ffi.prop_get_mouse_icon(instance)
	return createPointer(getPointer(instance).Icon);
end
function abi.ffi.prop_set_mouse_icon(instance, p_Icon0)
	getPointer(instance).Icon = getPointer(p_Icon0);
end
function abi.ffi.prop_get_mouse_origin(instance)
	return createPointer(getPointer(instance).Origin);
end
function abi.ffi.prop_get_mouse_target(output, instance)
	local value0 = getPointer(instance).Target;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_mouse_target_filter(output, instance)
	local value0 = getPointer(instance).TargetFilter;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_mouse_target_filter(instance, p_TargetFilter0, p_TargetFilter1)
	local value0;
	if p_TargetFilter0 == 1 then
		value0 = getPointer(p_TargetFilter1);
	end
	getPointer(instance).TargetFilter = value0;
end
function abi.ffi.prop_get_mouse_target_surface(instance)
	return (getPointer(instance).TargetSurface).Value;
end
function abi.ffi.prop_get_mouse_unit_ray(instance)
	return createPointer(getPointer(instance).UnitRay);
end
function abi.ffi.prop_get_mouse_view_size_x(instance)
	return getPointer(instance).ViewSizeX;
end
function abi.ffi.prop_get_mouse_view_size_y(instance)
	return getPointer(instance).ViewSizeY;
end
function abi.ffi.prop_get_mouse_x(instance)
	return getPointer(instance).X;
end
function abi.ffi.prop_get_mouse_y(instance)
	return getPointer(instance).Y;
end
function abi.ffi.connect_mouse_button_1_down(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Button1Down:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_mouse_button_1_up(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Button1Up:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_mouse_button_2_down(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Button2Down:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_mouse_button_2_up(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Button2Up:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_mouse_idle(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Idle:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_mouse_move(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Move:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_mouse_wheel_backward(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).WheelBackward:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_mouse_wheel_forward(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).WheelForward:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_network_marker_received(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Received:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.prop_get_no_collision_constraint_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_no_collision_constraint_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_no_collision_constraint_part_0(output, instance)
	local value0 = getPointer(instance).Part0;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_no_collision_constraint_part_0(instance, p_Part00, p_Part01)
	local value0;
	if p_Part00 == 1 then
		value0 = getPointer(p_Part01);
	end
	getPointer(instance).Part0 = value0;
end
function abi.ffi.prop_get_no_collision_constraint_part_1(output, instance)
	local value0 = getPointer(instance).Part1;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_no_collision_constraint_part_1(instance, p_Part10, p_Part11)
	local value0;
	if p_Part10 == 1 then
		value0 = getPointer(p_Part11);
	end
	getPointer(instance).Part1 = value0;
end
function abi.ffi.dyn_fn_pv_instance_get_pivot(instance)
	return createPointer(getPointer(instance):GetPivot());
end
function abi.ffi.dyn_fn_pv_instance_pivot_to(instance, p_targetCFrame0)
	return getPointer(instance):PivotTo(getPointer(p_targetCFrame0));
end
function abi.ffi.prop_get_base_part_anchored(instance)
	return getPointer(instance).Anchored and 1 or 0;
end
function abi.ffi.prop_set_base_part_anchored(instance, p_Anchored0)
	getPointer(instance).Anchored = p_Anchored0 == 1;
end
function abi.ffi.prop_get_base_part_assembly_angular_velocity(instance)
	return createPointer(getPointer(instance).AssemblyAngularVelocity);
end
function abi.ffi.prop_set_base_part_assembly_angular_velocity(instance, p_AssemblyAngularVelocity0)
	getPointer(instance).AssemblyAngularVelocity = getPointer(p_AssemblyAngularVelocity0);
end
function abi.ffi.prop_get_base_part_assembly_center_of_mass(instance)
	return createPointer(getPointer(instance).AssemblyCenterOfMass);
end
function abi.ffi.prop_get_base_part_assembly_linear_velocity(instance)
	return createPointer(getPointer(instance).AssemblyLinearVelocity);
end
function abi.ffi.prop_set_base_part_assembly_linear_velocity(instance, p_AssemblyLinearVelocity0)
	getPointer(instance).AssemblyLinearVelocity = getPointer(p_AssemblyLinearVelocity0);
end
function abi.ffi.prop_get_base_part_assembly_mass(instance)
	return getPointer(instance).AssemblyMass;
end
function abi.ffi.prop_get_base_part_assembly_root_part(output, instance)
	local value0 = getPointer(instance).AssemblyRootPart;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_base_part_back_surface(instance)
	return (getPointer(instance).BackSurface).Value;
end
function abi.ffi.prop_set_base_part_back_surface(instance, p_BackSurface0)
	getPointer(instance).BackSurface = p_BackSurface0;
end
function abi.ffi.prop_get_base_part_bottom_surface(instance)
	return (getPointer(instance).BottomSurface).Value;
end
function abi.ffi.prop_set_base_part_bottom_surface(instance, p_BottomSurface0)
	getPointer(instance).BottomSurface = p_BottomSurface0;
end
function abi.ffi.prop_get_base_part_brick_color(instance)
	return createPointer(getPointer(instance).BrickColor);
end
function abi.ffi.prop_set_base_part_brick_color(instance, p_BrickColor0)
	getPointer(instance).BrickColor = getPointer(p_BrickColor0);
end
function abi.ffi.prop_get_base_part_c_frame(instance)
	return createPointer(getPointer(instance).CFrame);
end
function abi.ffi.prop_set_base_part_c_frame(instance, p_CFrame0)
	getPointer(instance).CFrame = getPointer(p_CFrame0);
end
function abi.ffi.prop_get_base_part_can_collide(instance)
	return getPointer(instance).CanCollide and 1 or 0;
end
function abi.ffi.prop_set_base_part_can_collide(instance, p_CanCollide0)
	getPointer(instance).CanCollide = p_CanCollide0 == 1;
end
function abi.ffi.prop_get_base_part_can_query(instance)
	return getPointer(instance).CanQuery and 1 or 0;
end
function abi.ffi.prop_set_base_part_can_query(instance, p_CanQuery0)
	getPointer(instance).CanQuery = p_CanQuery0 == 1;
end
function abi.ffi.prop_get_base_part_can_touch(instance)
	return getPointer(instance).CanTouch and 1 or 0;
end
function abi.ffi.prop_set_base_part_can_touch(instance, p_CanTouch0)
	getPointer(instance).CanTouch = p_CanTouch0 == 1;
end
function abi.ffi.prop_get_base_part_cast_shadow(instance)
	return getPointer(instance).CastShadow and 1 or 0;
end
function abi.ffi.prop_set_base_part_cast_shadow(instance, p_CastShadow0)
	getPointer(instance).CastShadow = p_CastShadow0 == 1;
end
function abi.ffi.prop_get_base_part_center_of_mass(instance)
	return createPointer(getPointer(instance).CenterOfMass);
end
function abi.ffi.prop_get_base_part_collision_group(output, instance)
	local value0 = getPointer(instance).CollisionGroup;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_base_part_collision_group(instance, p_CollisionGroup0, p_CollisionGroup1)
	getPointer(instance).CollisionGroup = loadString(memory, p_CollisionGroup0, p_CollisionGroup1);
end
function abi.ffi.prop_get_base_part_collision_group_id(instance)
	return getPointer(instance).CollisionGroupId;
end
function abi.ffi.prop_set_base_part_collision_group_id(instance, p_CollisionGroupId0)
	getPointer(instance).CollisionGroupId = p_CollisionGroupId0;
end
function abi.ffi.prop_get_base_part_color(instance)
	return createPointer(getPointer(instance).Color);
end
function abi.ffi.prop_set_base_part_color(instance, p_Color0)
	getPointer(instance).Color = getPointer(p_Color0);
end
function abi.ffi.prop_get_base_part_current_physical_properties(instance)
	return createPointer(getPointer(instance).CurrentPhysicalProperties);
end
function abi.ffi.prop_get_base_part_custom_physical_properties(instance)
	return createPointer(getPointer(instance).CustomPhysicalProperties);
end
function abi.ffi.prop_set_base_part_custom_physical_properties(instance, p_CustomPhysicalProperties0)
	getPointer(instance).CustomPhysicalProperties = getPointer(p_CustomPhysicalProperties0);
end
function abi.ffi.prop_get_base_part_front_surface(instance)
	return (getPointer(instance).FrontSurface).Value;
end
function abi.ffi.prop_set_base_part_front_surface(instance, p_FrontSurface0)
	getPointer(instance).FrontSurface = p_FrontSurface0;
end
function abi.ffi.prop_get_base_part_left_surface(instance)
	return (getPointer(instance).LeftSurface).Value;
end
function abi.ffi.prop_set_base_part_left_surface(instance, p_LeftSurface0)
	getPointer(instance).LeftSurface = p_LeftSurface0;
end
function abi.ffi.prop_get_base_part_local_transparency_modifier(instance)
	return getPointer(instance).LocalTransparencyModifier;
end
function abi.ffi.prop_set_base_part_local_transparency_modifier(instance, p_LocalTransparencyModifier0)
	getPointer(instance).LocalTransparencyModifier = p_LocalTransparencyModifier0;
end
function abi.ffi.prop_get_base_part_locked(instance)
	return getPointer(instance).Locked and 1 or 0;
end
function abi.ffi.prop_set_base_part_locked(instance, p_Locked0)
	getPointer(instance).Locked = p_Locked0 == 1;
end
function abi.ffi.prop_get_base_part_mass(instance)
	return getPointer(instance).Mass;
end
function abi.ffi.prop_get_base_part_massless(instance)
	return getPointer(instance).Massless and 1 or 0;
end
function abi.ffi.prop_set_base_part_massless(instance, p_Massless0)
	getPointer(instance).Massless = p_Massless0 == 1;
end
function abi.ffi.prop_get_base_part_material(instance)
	return (getPointer(instance).Material).Value;
end
function abi.ffi.prop_set_base_part_material(instance, p_Material0)
	getPointer(instance).Material = p_Material0;
end
function abi.ffi.prop_get_base_part_material_variant(output, instance)
	local value0 = getPointer(instance).MaterialVariant;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_base_part_material_variant(instance, p_MaterialVariant0, p_MaterialVariant1)
	getPointer(instance).MaterialVariant = loadString(memory, p_MaterialVariant0, p_MaterialVariant1);
end
function abi.ffi.prop_get_base_part_orientation(instance)
	return createPointer(getPointer(instance).Orientation);
end
function abi.ffi.prop_set_base_part_orientation(instance, p_Orientation0)
	getPointer(instance).Orientation = getPointer(p_Orientation0);
end
function abi.ffi.prop_get_base_part_pivot_offset(instance)
	return createPointer(getPointer(instance).PivotOffset);
end
function abi.ffi.prop_set_base_part_pivot_offset(instance, p_PivotOffset0)
	getPointer(instance).PivotOffset = getPointer(p_PivotOffset0);
end
function abi.ffi.prop_get_base_part_position(instance)
	return createPointer(getPointer(instance).Position);
end
function abi.ffi.prop_set_base_part_position(instance, p_Position0)
	getPointer(instance).Position = getPointer(p_Position0);
end
function abi.ffi.prop_get_base_part_receive_age(instance)
	return getPointer(instance).ReceiveAge;
end
function abi.ffi.prop_get_base_part_reflectance(instance)
	return getPointer(instance).Reflectance;
end
function abi.ffi.prop_set_base_part_reflectance(instance, p_Reflectance0)
	getPointer(instance).Reflectance = p_Reflectance0;
end
function abi.ffi.prop_get_base_part_resize_increment(instance)
	return getPointer(instance).ResizeIncrement;
end
function abi.ffi.prop_get_base_part_resizeable_faces(instance)
	return createPointer(getPointer(instance).ResizeableFaces);
end
function abi.ffi.prop_get_base_part_right_surface(instance)
	return (getPointer(instance).RightSurface).Value;
end
function abi.ffi.prop_set_base_part_right_surface(instance, p_RightSurface0)
	getPointer(instance).RightSurface = p_RightSurface0;
end
function abi.ffi.prop_get_base_part_root_priority(instance)
	return getPointer(instance).RootPriority;
end
function abi.ffi.prop_set_base_part_root_priority(instance, p_RootPriority0)
	getPointer(instance).RootPriority = p_RootPriority0;
end
function abi.ffi.prop_get_base_part_rotation(instance)
	return createPointer(getPointer(instance).Rotation);
end
function abi.ffi.prop_set_base_part_rotation(instance, p_Rotation0)
	getPointer(instance).Rotation = getPointer(p_Rotation0);
end
function abi.ffi.prop_get_base_part_size(instance)
	return createPointer(getPointer(instance).Size);
end
function abi.ffi.prop_set_base_part_size(instance, p_Size0)
	getPointer(instance).Size = getPointer(p_Size0);
end
function abi.ffi.prop_get_base_part_top_surface(instance)
	return (getPointer(instance).TopSurface).Value;
end
function abi.ffi.prop_set_base_part_top_surface(instance, p_TopSurface0)
	getPointer(instance).TopSurface = p_TopSurface0;
end
function abi.ffi.prop_get_base_part_transparency(instance)
	return getPointer(instance).Transparency;
end
function abi.ffi.prop_set_base_part_transparency(instance, p_Transparency0)
	getPointer(instance).Transparency = p_Transparency0;
end
function abi.ffi.dyn_fn_base_part_apply_angular_impulse(instance, p_impulse0)
	return getPointer(instance):ApplyAngularImpulse(getPointer(p_impulse0));
end
function abi.ffi.dyn_fn_base_part_apply_impulse(instance, p_impulse0)
	return getPointer(instance):ApplyImpulse(getPointer(p_impulse0));
end
function abi.ffi.dyn_fn_base_part_apply_impulse_at_position(instance, p_impulse0, p_position0)
	return getPointer(instance):ApplyImpulseAtPosition(getPointer(p_impulse0), getPointer(p_position0));
end
function abi.ffi.dyn_fn_base_part_break_joints(instance)
	return getPointer(instance):BreakJoints();
end
function abi.ffi.dyn_fn_base_part_can_collide_with(instance, p_part0)
	return getPointer(instance):CanCollideWith(getPointer(p_part0)) and 1 or 0;
end
function abi.ffi.dyn_fn_base_part_get_connected_parts(output, instance, p_recursive0)
	local result0 = getPointer(instance):GetConnectedParts(p_recursive0 == 1);
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_base_part_get_joints(output, instance)
	local result0 = getPointer(instance):GetJoints();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_base_part_get_mass(instance)
	return getPointer(instance):GetMass();
end
function abi.ffi.dyn_fn_base_part_get_network_owner(output, instance)
	local value0 = getPointer(instance):GetNetworkOwner();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_base_part_get_network_ownership_auto(instance)
	return getPointer(instance):GetNetworkOwnershipAuto() and 1 or 0;
end
function abi.ffi.dyn_fn_base_part_get_root_part(output, instance)
	local value0 = getPointer(instance):GetRootPart();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_base_part_get_touching_parts(output, instance)
	local result0 = getPointer(instance):GetTouchingParts();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_base_part_get_velocity_at_position(instance, p_position0)
	return createPointer(getPointer(instance):GetVelocityAtPosition(getPointer(p_position0)));
end
function abi.ffi.dyn_fn_base_part_is_grounded(instance)
	return getPointer(instance):IsGrounded() and 1 or 0;
end
function abi.ffi.dyn_fn_base_part_make_joints(instance)
	return getPointer(instance):MakeJoints();
end
function abi.ffi.dyn_fn_base_part_resize(instance, p_normalId0, p_deltaAmount0)
	return getPointer(instance):Resize(p_normalId0, p_deltaAmount0) and 1 or 0;
end
function abi.ffi.dyn_fn_base_part_set_network_owner(instance, p_playerInstance0)
	return getPointer(instance):SetNetworkOwner(getPointer(p_playerInstance0));
end
function abi.ffi.dyn_fn_base_part_set_network_ownership_auto(instance)
	return getPointer(instance):SetNetworkOwnershipAuto();
end
function abi.ffi.dyn_fn_base_part_subtract_async(output, instance, p_parts0, p_parts1, p_collisionfidelity0, p_renderFidelity0)
	local result0 = table.create(p_parts1)
	for i = 1, p_parts1 do
		local value0_0 = loadU32(memory, p_parts0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	local value0 = getPointer(instance):SubtractAsync(result0, p_collisionfidelity0, p_renderFidelity0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_base_part_union_async(output, instance, p_parts0, p_parts1, p_collisionfidelity0, p_renderFidelity0)
	local result0 = table.create(p_parts1)
	for i = 1, p_parts1 do
		local value0_0 = loadU32(memory, p_parts0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	local value0 = getPointer(instance):UnionAsync(result0, p_collisionfidelity0, p_renderFidelity0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.connect_base_part_touch_ended(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TouchEnded:Connect(function(p_otherPart)
		local value0 = p_otherPart;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_base_part_touched(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Touched:Connect(function(p_otherPart)
		invokeFunction(data, vtable, createPointer(p_otherPart));
	end))
end
function abi.ffi.prop_get_part_shape(instance)
	return (getPointer(instance).Shape).Value;
end
function abi.ffi.prop_set_part_shape(instance, p_Shape0)
	getPointer(instance).Shape = p_Shape0;
end
function abi.ffi.prop_get_seat_disabled(instance)
	return getPointer(instance).Disabled and 1 or 0;
end
function abi.ffi.prop_set_seat_disabled(instance, p_Disabled0)
	getPointer(instance).Disabled = p_Disabled0 == 1;
end
function abi.ffi.prop_get_seat_occupant(output, instance)
	local value0 = getPointer(instance).Occupant;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_seat_sit(instance, p_humanoid0)
	return getPointer(instance):Sit(getPointer(p_humanoid0));
end
function abi.ffi.prop_get_spawn_location_allow_team_change_on_touch(instance)
	return getPointer(instance).AllowTeamChangeOnTouch and 1 or 0;
end
function abi.ffi.prop_set_spawn_location_allow_team_change_on_touch(instance, p_AllowTeamChangeOnTouch0)
	getPointer(instance).AllowTeamChangeOnTouch = p_AllowTeamChangeOnTouch0 == 1;
end
function abi.ffi.prop_get_spawn_location_duration(instance)
	return getPointer(instance).Duration;
end
function abi.ffi.prop_set_spawn_location_duration(instance, p_Duration0)
	getPointer(instance).Duration = p_Duration0;
end
function abi.ffi.prop_get_spawn_location_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_spawn_location_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_spawn_location_neutral(instance)
	return getPointer(instance).Neutral and 1 or 0;
end
function abi.ffi.prop_set_spawn_location_neutral(instance, p_Neutral0)
	getPointer(instance).Neutral = p_Neutral0 == 1;
end
function abi.ffi.prop_get_spawn_location_team_color(instance)
	return createPointer(getPointer(instance).TeamColor);
end
function abi.ffi.prop_set_spawn_location_team_color(instance, p_TeamColor0)
	getPointer(instance).TeamColor = getPointer(p_TeamColor0);
end
function abi.ffi.prop_get_terrain_max_extents(instance)
	return createPointer(getPointer(instance).MaxExtents);
end
function abi.ffi.prop_get_terrain_water_color(instance)
	return createPointer(getPointer(instance).WaterColor);
end
function abi.ffi.prop_set_terrain_water_color(instance, p_WaterColor0)
	getPointer(instance).WaterColor = getPointer(p_WaterColor0);
end
function abi.ffi.prop_get_terrain_water_reflectance(instance)
	return getPointer(instance).WaterReflectance;
end
function abi.ffi.prop_set_terrain_water_reflectance(instance, p_WaterReflectance0)
	getPointer(instance).WaterReflectance = p_WaterReflectance0;
end
function abi.ffi.prop_get_terrain_water_transparency(instance)
	return getPointer(instance).WaterTransparency;
end
function abi.ffi.prop_set_terrain_water_transparency(instance, p_WaterTransparency0)
	getPointer(instance).WaterTransparency = p_WaterTransparency0;
end
function abi.ffi.prop_get_terrain_water_wave_size(instance)
	return getPointer(instance).WaterWaveSize;
end
function abi.ffi.prop_set_terrain_water_wave_size(instance, p_WaterWaveSize0)
	getPointer(instance).WaterWaveSize = p_WaterWaveSize0;
end
function abi.ffi.prop_get_terrain_water_wave_speed(instance)
	return getPointer(instance).WaterWaveSpeed;
end
function abi.ffi.prop_set_terrain_water_wave_speed(instance, p_WaterWaveSpeed0)
	getPointer(instance).WaterWaveSpeed = p_WaterWaveSpeed0;
end
function abi.ffi.dyn_fn_terrain_cell_center_to_world(instance, p_x0, p_y0, p_z0)
	return createPointer(getPointer(instance):CellCenterToWorld(p_x0, p_y0, p_z0));
end
function abi.ffi.dyn_fn_terrain_cell_corner_to_world(instance, p_x0, p_y0, p_z0)
	return createPointer(getPointer(instance):CellCornerToWorld(p_x0, p_y0, p_z0));
end
function abi.ffi.dyn_fn_terrain_clear(instance)
	return getPointer(instance):Clear();
end
function abi.ffi.dyn_fn_terrain_copy_region(output, instance, p_region0)
	local value0 = getPointer(instance):CopyRegion(getPointer(p_region0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_terrain_count_cells(instance)
	return getPointer(instance):CountCells();
end
function abi.ffi.dyn_fn_terrain_fill_ball(instance, p_center0, p_radius0, p_material0)
	return getPointer(instance):FillBall(getPointer(p_center0), p_radius0, p_material0);
end
function abi.ffi.dyn_fn_terrain_fill_block(instance, p_cframe0, p_size0, p_material0)
	return getPointer(instance):FillBlock(getPointer(p_cframe0), getPointer(p_size0), p_material0);
end
function abi.ffi.dyn_fn_terrain_fill_cylinder(instance, p_cframe0, p_height0, p_radius0, p_material0)
	return getPointer(instance):FillCylinder(getPointer(p_cframe0), p_height0, p_radius0, p_material0);
end
function abi.ffi.dyn_fn_terrain_fill_region(instance, p_region0, p_resolution0, p_material0)
	return getPointer(instance):FillRegion(getPointer(p_region0), p_resolution0, p_material0);
end
function abi.ffi.dyn_fn_terrain_fill_wedge(instance, p_cframe0, p_size0, p_material0)
	return getPointer(instance):FillWedge(getPointer(p_cframe0), getPointer(p_size0), p_material0);
end
function abi.ffi.dyn_fn_terrain_get_material_color(instance, p_material0)
	return createPointer(getPointer(instance):GetMaterialColor(p_material0));
end
function abi.ffi.dyn_fn_terrain_paste_region(instance, p_region0, p_corner0, p_pasteEmptyCells0)
	return getPointer(instance):PasteRegion(getPointer(p_region0), getPointer(p_corner0), p_pasteEmptyCells0 == 1);
end
function abi.ffi.dyn_fn_terrain_replace_material(instance, p_region0, p_resolution0, p_sourceMaterial0, p_targetMaterial0)
	return getPointer(instance):ReplaceMaterial(getPointer(p_region0), p_resolution0, p_sourceMaterial0, p_targetMaterial0);
end
function abi.ffi.dyn_fn_terrain_set_material_color(instance, p_material0, p_value0)
	return getPointer(instance):SetMaterialColor(p_material0, getPointer(p_value0));
end
function abi.ffi.dyn_fn_terrain_world_to_cell(instance, p_position0)
	return createPointer(getPointer(instance):WorldToCell(getPointer(p_position0)));
end
function abi.ffi.dyn_fn_terrain_world_to_cell_prefer_empty(instance, p_position0)
	return createPointer(getPointer(instance):WorldToCellPreferEmpty(getPointer(p_position0)));
end
function abi.ffi.dyn_fn_terrain_world_to_cell_prefer_solid(instance, p_position0)
	return createPointer(getPointer(instance):WorldToCellPreferSolid(getPointer(p_position0)));
end
function abi.ffi.prop_get_triangle_mesh_part_collision_fidelity(instance)
	return (getPointer(instance).CollisionFidelity).Value;
end
function abi.ffi.prop_set_triangle_mesh_part_collision_fidelity(instance, p_CollisionFidelity0)
	getPointer(instance).CollisionFidelity = p_CollisionFidelity0;
end
function abi.ffi.prop_get_triangle_mesh_part_mesh_size(instance)
	return createPointer(getPointer(instance).MeshSize);
end
function abi.ffi.prop_get_mesh_part_double_sided(instance)
	return getPointer(instance).DoubleSided and 1 or 0;
end
function abi.ffi.prop_set_mesh_part_double_sided(instance, p_DoubleSided0)
	getPointer(instance).DoubleSided = p_DoubleSided0 == 1;
end
function abi.ffi.prop_get_mesh_part_has_joint_offset(instance)
	return getPointer(instance).HasJointOffset and 1 or 0;
end
function abi.ffi.prop_set_mesh_part_has_joint_offset(instance, p_HasJointOffset0)
	getPointer(instance).HasJointOffset = p_HasJointOffset0 == 1;
end
function abi.ffi.prop_get_mesh_part_has_skinned_mesh(instance)
	return getPointer(instance).HasSkinnedMesh and 1 or 0;
end
function abi.ffi.prop_set_mesh_part_has_skinned_mesh(instance, p_HasSkinnedMesh0)
	getPointer(instance).HasSkinnedMesh = p_HasSkinnedMesh0 == 1;
end
function abi.ffi.prop_get_mesh_part_joint_offset(instance)
	return createPointer(getPointer(instance).JointOffset);
end
function abi.ffi.prop_set_mesh_part_joint_offset(instance, p_JointOffset0)
	getPointer(instance).JointOffset = getPointer(p_JointOffset0);
end
function abi.ffi.prop_get_mesh_part_mesh_id(instance)
	return createPointer(getPointer(instance).MeshId);
end
function abi.ffi.prop_set_mesh_part_mesh_id(instance, p_MeshId0)
	getPointer(instance).MeshId = getPointer(p_MeshId0);
end
function abi.ffi.prop_get_mesh_part_render_fidelity(instance)
	return (getPointer(instance).RenderFidelity).Value;
end
function abi.ffi.prop_set_mesh_part_render_fidelity(instance, p_RenderFidelity0)
	getPointer(instance).RenderFidelity = p_RenderFidelity0;
end
function abi.ffi.prop_get_mesh_part_texture_id(instance)
	return createPointer(getPointer(instance).TextureID);
end
function abi.ffi.prop_set_mesh_part_texture_id(instance, p_TextureID0)
	getPointer(instance).TextureID = getPointer(p_TextureID0);
end
function abi.ffi.dyn_fn_mesh_part_apply_mesh(instance, p_meshPart0)
	return getPointer(instance):ApplyMesh(getPointer(p_meshPart0));
end
function abi.ffi.prop_get_part_operation_render_fidelity(instance)
	return (getPointer(instance).RenderFidelity).Value;
end
function abi.ffi.prop_set_part_operation_render_fidelity(instance, p_RenderFidelity0)
	getPointer(instance).RenderFidelity = p_RenderFidelity0;
end
function abi.ffi.prop_get_part_operation_smoothing_angle(instance)
	return getPointer(instance).SmoothingAngle;
end
function abi.ffi.prop_set_part_operation_smoothing_angle(instance, p_SmoothingAngle0)
	getPointer(instance).SmoothingAngle = p_SmoothingAngle0;
end
function abi.ffi.prop_get_part_operation_triangle_count(instance)
	return getPointer(instance).TriangleCount;
end
function abi.ffi.prop_get_part_operation_use_part_color(instance)
	return getPointer(instance).UsePartColor and 1 or 0;
end
function abi.ffi.prop_set_part_operation_use_part_color(instance, p_UsePartColor0)
	getPointer(instance).UsePartColor = p_UsePartColor0 == 1;
end
function abi.ffi.prop_get_truss_part_style(instance)
	return (getPointer(instance).Style).Value;
end
function abi.ffi.prop_set_truss_part_style(instance, p_Style0)
	getPointer(instance).Style = p_Style0;
end
function abi.ffi.prop_get_vehicle_seat_are_hinges_detected(instance)
	return getPointer(instance).AreHingesDetected;
end
function abi.ffi.prop_get_vehicle_seat_disabled(instance)
	return getPointer(instance).Disabled and 1 or 0;
end
function abi.ffi.prop_set_vehicle_seat_disabled(instance, p_Disabled0)
	getPointer(instance).Disabled = p_Disabled0 == 1;
end
function abi.ffi.prop_get_vehicle_seat_heads_up_display(instance)
	return getPointer(instance).HeadsUpDisplay and 1 or 0;
end
function abi.ffi.prop_set_vehicle_seat_heads_up_display(instance, p_HeadsUpDisplay0)
	getPointer(instance).HeadsUpDisplay = p_HeadsUpDisplay0 == 1;
end
function abi.ffi.prop_get_vehicle_seat_max_speed(instance)
	return getPointer(instance).MaxSpeed;
end
function abi.ffi.prop_set_vehicle_seat_max_speed(instance, p_MaxSpeed0)
	getPointer(instance).MaxSpeed = p_MaxSpeed0;
end
function abi.ffi.prop_get_vehicle_seat_occupant(output, instance)
	local value0 = getPointer(instance).Occupant;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_vehicle_seat_steer(instance)
	return getPointer(instance).Steer;
end
function abi.ffi.prop_set_vehicle_seat_steer(instance, p_Steer0)
	getPointer(instance).Steer = p_Steer0;
end
function abi.ffi.prop_get_vehicle_seat_steer_float(instance)
	return getPointer(instance).SteerFloat;
end
function abi.ffi.prop_set_vehicle_seat_steer_float(instance, p_SteerFloat0)
	getPointer(instance).SteerFloat = p_SteerFloat0;
end
function abi.ffi.prop_get_vehicle_seat_throttle(instance)
	return getPointer(instance).Throttle;
end
function abi.ffi.prop_set_vehicle_seat_throttle(instance, p_Throttle0)
	getPointer(instance).Throttle = p_Throttle0;
end
function abi.ffi.prop_get_vehicle_seat_throttle_float(instance)
	return getPointer(instance).ThrottleFloat;
end
function abi.ffi.prop_set_vehicle_seat_throttle_float(instance, p_ThrottleFloat0)
	getPointer(instance).ThrottleFloat = p_ThrottleFloat0;
end
function abi.ffi.prop_get_vehicle_seat_torque(instance)
	return getPointer(instance).Torque;
end
function abi.ffi.prop_set_vehicle_seat_torque(instance, p_Torque0)
	getPointer(instance).Torque = p_Torque0;
end
function abi.ffi.prop_get_vehicle_seat_turn_speed(instance)
	return getPointer(instance).TurnSpeed;
end
function abi.ffi.prop_set_vehicle_seat_turn_speed(instance, p_TurnSpeed0)
	getPointer(instance).TurnSpeed = p_TurnSpeed0;
end
function abi.ffi.dyn_fn_vehicle_seat_sit(instance, p_humanoid0)
	return getPointer(instance):Sit(getPointer(p_humanoid0));
end
function abi.ffi.prop_get_model_model_streaming_mode(instance)
	return (getPointer(instance).ModelStreamingMode).Value;
end
function abi.ffi.prop_set_model_model_streaming_mode(instance, p_ModelStreamingMode0)
	getPointer(instance).ModelStreamingMode = p_ModelStreamingMode0;
end
function abi.ffi.prop_get_model_primary_part(output, instance)
	local value0 = getPointer(instance).PrimaryPart;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_model_primary_part(instance, p_PrimaryPart0, p_PrimaryPart1)
	local value0;
	if p_PrimaryPart0 == 1 then
		value0 = getPointer(p_PrimaryPart1);
	end
	getPointer(instance).PrimaryPart = value0;
end
function abi.ffi.prop_get_model_world_pivot(instance)
	return createPointer(getPointer(instance).WorldPivot);
end
function abi.ffi.prop_set_model_world_pivot(instance, p_WorldPivot0)
	getPointer(instance).WorldPivot = getPointer(p_WorldPivot0);
end
function abi.ffi.dyn_fn_model_break_joints(instance)
	return getPointer(instance):BreakJoints();
end
function abi.ffi.dyn_fn_model_get_extents_size(instance)
	return createPointer(getPointer(instance):GetExtentsSize());
end
function abi.ffi.dyn_fn_model_make_joints(instance)
	return getPointer(instance):MakeJoints();
end
function abi.ffi.dyn_fn_model_move_to(instance, p_position0)
	return getPointer(instance):MoveTo(getPointer(p_position0));
end
function abi.ffi.dyn_fn_model_translate_by(instance, p_delta0)
	return getPointer(instance):TranslateBy(getPointer(p_delta0));
end
function abi.ffi.dyn_fn_world_root_are_parts_touching_others(instance, p_partList0, p_partList1, p_overlapIgnored0)
	local result0 = table.create(p_partList1)
	for i = 1, p_partList1 do
		local value0_0 = loadU32(memory, p_partList0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	return getPointer(instance):ArePartsTouchingOthers(result0, p_overlapIgnored0) and 1 or 0;
end
function abi.ffi.dyn_fn_world_root_bulk_move_to(instance, p_partList0, p_partList1, p_cframeList0, p_cframeList1, p_eventMode0)
	local result0 = table.create(p_partList1)
	for i = 1, p_partList1 do
		local value0_0 = loadU32(memory, p_partList0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	local result1 = table.create(p_cframeList1)
	for i = 1, p_cframeList1 do
		local value1_0 = loadU32(memory, p_cframeList0 + (i - 1) * 4 + 0);
		result1[i] = getPointer(value1_0)
	end
	return getPointer(instance):BulkMoveTo(result0, result1, p_eventMode0);
end
function abi.ffi.dyn_fn_world_root_get_part_bounds_in_box(output, instance, p_cframe0, p_size0, p_overlapParams0)
	local result0 = getPointer(instance):GetPartBoundsInBox(getPointer(p_cframe0), getPointer(p_size0), getPointer(p_overlapParams0));
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_world_root_get_part_bounds_in_radius(output, instance, p_position0, p_radius0, p_overlapParams0)
	local result0 = getPointer(instance):GetPartBoundsInRadius(getPointer(p_position0), p_radius0, getPointer(p_overlapParams0));
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_world_root_get_parts_in_part(output, instance, p_part0, p_overlapParams0)
	local result0 = getPointer(instance):GetPartsInPart(getPointer(p_part0), getPointer(p_overlapParams0));
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_world_root_raycast(instance, p_origin0, p_direction0, p_raycastParams0)
	return createPointer(getPointer(instance):Raycast(getPointer(p_origin0), getPointer(p_direction0), getPointer(p_raycastParams0)));
end
function abi.ffi.prop_get_workspace_allow_third_party_sales(instance)
	return getPointer(instance).AllowThirdPartySales and 1 or 0;
end
function abi.ffi.prop_set_workspace_allow_third_party_sales(instance, p_AllowThirdPartySales0)
	getPointer(instance).AllowThirdPartySales = p_AllowThirdPartySales0 == 1;
end
function abi.ffi.prop_get_workspace_client_animator_throttling(instance)
	return (getPointer(instance).ClientAnimatorThrottling).Value;
end
function abi.ffi.prop_set_workspace_client_animator_throttling(instance, p_ClientAnimatorThrottling0)
	getPointer(instance).ClientAnimatorThrottling = p_ClientAnimatorThrottling0;
end
function abi.ffi.prop_get_workspace_current_camera(output, instance)
	local value0 = getPointer(instance).CurrentCamera;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_workspace_current_camera(instance, p_CurrentCamera0, p_CurrentCamera1)
	local value0;
	if p_CurrentCamera0 == 1 then
		value0 = getPointer(p_CurrentCamera1);
	end
	getPointer(instance).CurrentCamera = value0;
end
function abi.ffi.prop_get_workspace_distributed_game_time(instance)
	return getPointer(instance).DistributedGameTime;
end
function abi.ffi.prop_set_workspace_distributed_game_time(instance, p_DistributedGameTime0)
	getPointer(instance).DistributedGameTime = p_DistributedGameTime0;
end
function abi.ffi.prop_get_workspace_fallen_parts_destroy_height(instance)
	return getPointer(instance).FallenPartsDestroyHeight;
end
function abi.ffi.prop_set_workspace_fallen_parts_destroy_height(instance, p_FallenPartsDestroyHeight0)
	getPointer(instance).FallenPartsDestroyHeight = p_FallenPartsDestroyHeight0;
end
function abi.ffi.prop_get_workspace_global_wind(instance)
	return createPointer(getPointer(instance).GlobalWind);
end
function abi.ffi.prop_set_workspace_global_wind(instance, p_GlobalWind0)
	getPointer(instance).GlobalWind = getPointer(p_GlobalWind0);
end
function abi.ffi.prop_get_workspace_gravity(instance)
	return getPointer(instance).Gravity;
end
function abi.ffi.prop_set_workspace_gravity(instance, p_Gravity0)
	getPointer(instance).Gravity = p_Gravity0;
end
function abi.ffi.prop_get_workspace_interpolation_throttling(instance)
	return (getPointer(instance).InterpolationThrottling).Value;
end
function abi.ffi.prop_set_workspace_interpolation_throttling(instance, p_InterpolationThrottling0)
	getPointer(instance).InterpolationThrottling = p_InterpolationThrottling0;
end
function abi.ffi.prop_get_workspace_retargeting(instance)
	return (getPointer(instance).Retargeting).Value;
end
function abi.ffi.prop_set_workspace_retargeting(instance, p_Retargeting0)
	getPointer(instance).Retargeting = p_Retargeting0;
end
function abi.ffi.prop_get_workspace_streaming_enabled(instance)
	return getPointer(instance).StreamingEnabled and 1 or 0;
end
function abi.ffi.prop_set_workspace_streaming_enabled(instance, p_StreamingEnabled0)
	getPointer(instance).StreamingEnabled = p_StreamingEnabled0 == 1;
end
function abi.ffi.prop_get_workspace_terrain(output, instance)
	local value0 = getPointer(instance).Terrain;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_workspace_get_num_awake_parts(instance)
	return getPointer(instance):GetNumAwakeParts();
end
function abi.ffi.dyn_fn_workspace_get_physics_throttling(instance)
	return getPointer(instance):GetPhysicsThrottling();
end
function abi.ffi.dyn_fn_workspace_get_real_physics_fps(instance)
	return getPointer(instance):GetRealPhysicsFPS();
end
function abi.ffi.dyn_fn_workspace_get_server_time_now(instance)
	return getPointer(instance):GetServerTimeNow();
end
function abi.ffi.dyn_fn_workspace_join_to_outsiders(instance, p_objects0, p_objects1, p_jointType0)
	local result0 = table.create(p_objects1)
	for i = 1, p_objects1 do
		local value0_0 = loadU32(memory, p_objects0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	return getPointer(instance):JoinToOutsiders(result0, p_jointType0);
end
function abi.ffi.dyn_fn_workspace_pgs_is_enabled(instance)
	return getPointer(instance):PGSIsEnabled() and 1 or 0;
end
function abi.ffi.dyn_fn_workspace_unjoin_from_outsiders(instance, p_objects0, p_objects1)
	local result0 = table.create(p_objects1)
	for i = 1, p_objects1 do
		local value0_0 = loadU32(memory, p_objects0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	return getPointer(instance):UnjoinFromOutsiders(result0);
end
function abi.ffi.connect_workspace_persistent_loaded(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PersistentLoaded:Connect(function(p_player)
		local value0 = p_player;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.prop_get_package_link_package_id(instance)
	return createPointer(getPointer(instance).PackageId);
end
function abi.ffi.prop_get_package_link_version_number(instance)
	return getPointer(instance).VersionNumber;
end
function abi.ffi.prop_set_package_link_version_number(instance, p_VersionNumber0)
	getPointer(instance).VersionNumber = p_VersionNumber0;
end
function abi.ffi.prop_get_pages_is_finished(instance)
	return getPointer(instance).IsFinished and 1 or 0;
end
function abi.ffi.dyn_fn_pages_advance_to_next_page_async(instance)
	return getPointer(instance):AdvanceToNextPageAsync();
end
function abi.ffi.prop_get_data_store_key_pages_cursor(output, instance)
	local value0 = getPointer(instance).Cursor;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_data_store_listing_pages_cursor(output, instance)
	local value0 = getPointer(instance).Cursor;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_particle_emitter_acceleration(instance)
	return createPointer(getPointer(instance).Acceleration);
end
function abi.ffi.prop_set_particle_emitter_acceleration(instance, p_Acceleration0)
	getPointer(instance).Acceleration = getPointer(p_Acceleration0);
end
function abi.ffi.prop_get_particle_emitter_brightness(instance)
	return getPointer(instance).Brightness;
end
function abi.ffi.prop_set_particle_emitter_brightness(instance, p_Brightness0)
	getPointer(instance).Brightness = p_Brightness0;
end
function abi.ffi.prop_get_particle_emitter_color(instance)
	return createPointer(getPointer(instance).Color);
end
function abi.ffi.prop_set_particle_emitter_color(instance, p_Color0)
	getPointer(instance).Color = getPointer(p_Color0);
end
function abi.ffi.prop_get_particle_emitter_drag(instance)
	return getPointer(instance).Drag;
end
function abi.ffi.prop_set_particle_emitter_drag(instance, p_Drag0)
	getPointer(instance).Drag = p_Drag0;
end
function abi.ffi.prop_get_particle_emitter_emission_direction(instance)
	return (getPointer(instance).EmissionDirection).Value;
end
function abi.ffi.prop_set_particle_emitter_emission_direction(instance, p_EmissionDirection0)
	getPointer(instance).EmissionDirection = p_EmissionDirection0;
end
function abi.ffi.prop_get_particle_emitter_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_particle_emitter_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_particle_emitter_flipbook_framerate(instance)
	return createPointer(getPointer(instance).FlipbookFramerate);
end
function abi.ffi.prop_set_particle_emitter_flipbook_framerate(instance, p_FlipbookFramerate0)
	getPointer(instance).FlipbookFramerate = getPointer(p_FlipbookFramerate0);
end
function abi.ffi.prop_get_particle_emitter_flipbook_incompatible(output, instance)
	local value0 = getPointer(instance).FlipbookIncompatible;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_particle_emitter_flipbook_incompatible(instance, p_FlipbookIncompatible0, p_FlipbookIncompatible1)
	getPointer(instance).FlipbookIncompatible = loadString(memory, p_FlipbookIncompatible0, p_FlipbookIncompatible1);
end
function abi.ffi.prop_get_particle_emitter_flipbook_layout(instance)
	return (getPointer(instance).FlipbookLayout).Value;
end
function abi.ffi.prop_set_particle_emitter_flipbook_layout(instance, p_FlipbookLayout0)
	getPointer(instance).FlipbookLayout = p_FlipbookLayout0;
end
function abi.ffi.prop_get_particle_emitter_flipbook_mode(instance)
	return (getPointer(instance).FlipbookMode).Value;
end
function abi.ffi.prop_set_particle_emitter_flipbook_mode(instance, p_FlipbookMode0)
	getPointer(instance).FlipbookMode = p_FlipbookMode0;
end
function abi.ffi.prop_get_particle_emitter_flipbook_start_random(instance)
	return getPointer(instance).FlipbookStartRandom and 1 or 0;
end
function abi.ffi.prop_set_particle_emitter_flipbook_start_random(instance, p_FlipbookStartRandom0)
	getPointer(instance).FlipbookStartRandom = p_FlipbookStartRandom0 == 1;
end
function abi.ffi.prop_get_particle_emitter_lifetime(instance)
	return createPointer(getPointer(instance).Lifetime);
end
function abi.ffi.prop_set_particle_emitter_lifetime(instance, p_Lifetime0)
	getPointer(instance).Lifetime = getPointer(p_Lifetime0);
end
function abi.ffi.prop_get_particle_emitter_light_emission(instance)
	return getPointer(instance).LightEmission;
end
function abi.ffi.prop_set_particle_emitter_light_emission(instance, p_LightEmission0)
	getPointer(instance).LightEmission = p_LightEmission0;
end
function abi.ffi.prop_get_particle_emitter_light_influence(instance)
	return getPointer(instance).LightInfluence;
end
function abi.ffi.prop_set_particle_emitter_light_influence(instance, p_LightInfluence0)
	getPointer(instance).LightInfluence = p_LightInfluence0;
end
function abi.ffi.prop_get_particle_emitter_locked_to_part(instance)
	return getPointer(instance).LockedToPart and 1 or 0;
end
function abi.ffi.prop_set_particle_emitter_locked_to_part(instance, p_LockedToPart0)
	getPointer(instance).LockedToPart = p_LockedToPart0 == 1;
end
function abi.ffi.prop_get_particle_emitter_orientation(instance)
	return (getPointer(instance).Orientation).Value;
end
function abi.ffi.prop_set_particle_emitter_orientation(instance, p_Orientation0)
	getPointer(instance).Orientation = p_Orientation0;
end
function abi.ffi.prop_get_particle_emitter_rate(instance)
	return getPointer(instance).Rate;
end
function abi.ffi.prop_set_particle_emitter_rate(instance, p_Rate0)
	getPointer(instance).Rate = p_Rate0;
end
function abi.ffi.prop_get_particle_emitter_rot_speed(instance)
	return createPointer(getPointer(instance).RotSpeed);
end
function abi.ffi.prop_set_particle_emitter_rot_speed(instance, p_RotSpeed0)
	getPointer(instance).RotSpeed = getPointer(p_RotSpeed0);
end
function abi.ffi.prop_get_particle_emitter_rotation(instance)
	return createPointer(getPointer(instance).Rotation);
end
function abi.ffi.prop_set_particle_emitter_rotation(instance, p_Rotation0)
	getPointer(instance).Rotation = getPointer(p_Rotation0);
end
function abi.ffi.prop_get_particle_emitter_shape(instance)
	return (getPointer(instance).Shape).Value;
end
function abi.ffi.prop_set_particle_emitter_shape(instance, p_Shape0)
	getPointer(instance).Shape = p_Shape0;
end
function abi.ffi.prop_get_particle_emitter_shape_in_out(instance)
	return (getPointer(instance).ShapeInOut).Value;
end
function abi.ffi.prop_set_particle_emitter_shape_in_out(instance, p_ShapeInOut0)
	getPointer(instance).ShapeInOut = p_ShapeInOut0;
end
function abi.ffi.prop_get_particle_emitter_shape_partial(instance)
	return getPointer(instance).ShapePartial;
end
function abi.ffi.prop_set_particle_emitter_shape_partial(instance, p_ShapePartial0)
	getPointer(instance).ShapePartial = p_ShapePartial0;
end
function abi.ffi.prop_get_particle_emitter_shape_style(instance)
	return (getPointer(instance).ShapeStyle).Value;
end
function abi.ffi.prop_set_particle_emitter_shape_style(instance, p_ShapeStyle0)
	getPointer(instance).ShapeStyle = p_ShapeStyle0;
end
function abi.ffi.prop_get_particle_emitter_size(instance)
	return createPointer(getPointer(instance).Size);
end
function abi.ffi.prop_set_particle_emitter_size(instance, p_Size0)
	getPointer(instance).Size = getPointer(p_Size0);
end
function abi.ffi.prop_get_particle_emitter_speed(instance)
	return createPointer(getPointer(instance).Speed);
end
function abi.ffi.prop_set_particle_emitter_speed(instance, p_Speed0)
	getPointer(instance).Speed = getPointer(p_Speed0);
end
function abi.ffi.prop_get_particle_emitter_spread_angle(instance)
	return createPointer(getPointer(instance).SpreadAngle);
end
function abi.ffi.prop_set_particle_emitter_spread_angle(instance, p_SpreadAngle0)
	getPointer(instance).SpreadAngle = getPointer(p_SpreadAngle0);
end
function abi.ffi.prop_get_particle_emitter_squash(instance)
	return createPointer(getPointer(instance).Squash);
end
function abi.ffi.prop_set_particle_emitter_squash(instance, p_Squash0)
	getPointer(instance).Squash = getPointer(p_Squash0);
end
function abi.ffi.prop_get_particle_emitter_texture(instance)
	return createPointer(getPointer(instance).Texture);
end
function abi.ffi.prop_set_particle_emitter_texture(instance, p_Texture0)
	getPointer(instance).Texture = getPointer(p_Texture0);
end
function abi.ffi.prop_get_particle_emitter_time_scale(instance)
	return getPointer(instance).TimeScale;
end
function abi.ffi.prop_set_particle_emitter_time_scale(instance, p_TimeScale0)
	getPointer(instance).TimeScale = p_TimeScale0;
end
function abi.ffi.prop_get_particle_emitter_transparency(instance)
	return createPointer(getPointer(instance).Transparency);
end
function abi.ffi.prop_set_particle_emitter_transparency(instance, p_Transparency0)
	getPointer(instance).Transparency = getPointer(p_Transparency0);
end
function abi.ffi.prop_get_particle_emitter_velocity_inheritance(instance)
	return getPointer(instance).VelocityInheritance;
end
function abi.ffi.prop_set_particle_emitter_velocity_inheritance(instance, p_VelocityInheritance0)
	getPointer(instance).VelocityInheritance = p_VelocityInheritance0;
end
function abi.ffi.prop_get_particle_emitter_z_offset(instance)
	return getPointer(instance).ZOffset;
end
function abi.ffi.prop_set_particle_emitter_z_offset(instance, p_ZOffset0)
	getPointer(instance).ZOffset = p_ZOffset0;
end
function abi.ffi.dyn_fn_particle_emitter_clear(instance)
	return getPointer(instance):Clear();
end
function abi.ffi.dyn_fn_particle_emitter_emit(instance, p_particleCount0)
	return getPointer(instance):Emit(p_particleCount0);
end
function abi.ffi.prop_get_path_status(instance)
	return (getPointer(instance).Status).Value;
end
function abi.ffi.dyn_fn_path_check_occlusion_async(instance, p_start0)
	return getPointer(instance):CheckOcclusionAsync(p_start0);
end
function abi.ffi.dyn_fn_path_compute_async(instance, p_start0, p_finish0)
	return getPointer(instance):ComputeAsync(getPointer(p_start0), getPointer(p_finish0));
end
function abi.ffi.connect_path_blocked(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Blocked:Connect(function(p_blockedWaypointIdx)
		invokeFunction(data, vtable, p_blockedWaypointIdx);
	end))
end
function abi.ffi.connect_path_unblocked(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Unblocked:Connect(function(p_unblockedWaypointIdx)
		invokeFunction(data, vtable, p_unblockedWaypointIdx);
	end))
end
function abi.ffi.prop_get_pathfinding_link_attachment_0(output, instance)
	local value0 = getPointer(instance).Attachment0;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_pathfinding_link_attachment_0(instance, p_Attachment00, p_Attachment01)
	local value0;
	if p_Attachment00 == 1 then
		value0 = getPointer(p_Attachment01);
	end
	getPointer(instance).Attachment0 = value0;
end
function abi.ffi.prop_get_pathfinding_link_attachment_1(output, instance)
	local value0 = getPointer(instance).Attachment1;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_pathfinding_link_attachment_1(instance, p_Attachment10, p_Attachment11)
	local value0;
	if p_Attachment10 == 1 then
		value0 = getPointer(p_Attachment11);
	end
	getPointer(instance).Attachment1 = value0;
end
function abi.ffi.prop_get_pathfinding_link_is_bidirectional(instance)
	return getPointer(instance).IsBidirectional and 1 or 0;
end
function abi.ffi.prop_set_pathfinding_link_is_bidirectional(instance, p_IsBidirectional0)
	getPointer(instance).IsBidirectional = p_IsBidirectional0 == 1;
end
function abi.ffi.prop_get_pathfinding_link_label(output, instance)
	local value0 = getPointer(instance).Label;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_pathfinding_link_label(instance, p_Label0, p_Label1)
	getPointer(instance).Label = loadString(memory, p_Label0, p_Label1);
end
function abi.ffi.prop_get_pathfinding_modifier_label(output, instance)
	local value0 = getPointer(instance).Label;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_pathfinding_modifier_label(instance, p_Label0, p_Label1)
	getPointer(instance).Label = loadString(memory, p_Label0, p_Label1);
end
function abi.ffi.prop_get_pathfinding_modifier_pass_through(instance)
	return getPointer(instance).PassThrough and 1 or 0;
end
function abi.ffi.prop_set_pathfinding_modifier_pass_through(instance, p_PassThrough0)
	getPointer(instance).PassThrough = p_PassThrough0 == 1;
end
function abi.ffi.dyn_fn_pathfinding_service_create_path(output, instance, p_agentParameters0)
	local value0 = getPointer(instance):CreatePath(getPointer(p_agentParameters0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_pathfinding_service_find_path_async(output, instance, p_start0, p_finish0)
	local value0 = getPointer(instance):FindPathAsync(getPointer(p_start0), getPointer(p_finish0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_physics_service_collision_group_contains_part(instance, p_name0, p_name1, p_part0)
	return getPointer(instance):CollisionGroupContainsPart(loadString(memory, p_name0, p_name1), getPointer(p_part0)) and 1 or 0;
end
function abi.ffi.dyn_fn_physics_service_collision_group_set_collidable(instance, p_name10, p_name11, p_name20, p_name21, p_collidable0)
	return getPointer(instance):CollisionGroupSetCollidable(loadString(memory, p_name10, p_name11), loadString(memory, p_name20, p_name21), p_collidable0 == 1);
end
function abi.ffi.dyn_fn_physics_service_collision_groups_are_collidable(instance, p_name10, p_name11, p_name20, p_name21)
	return getPointer(instance):CollisionGroupsAreCollidable(loadString(memory, p_name10, p_name11), loadString(memory, p_name20, p_name21)) and 1 or 0;
end
function abi.ffi.dyn_fn_physics_service_create_collision_group(instance, p_name0, p_name1)
	return getPointer(instance):CreateCollisionGroup(loadString(memory, p_name0, p_name1));
end
function abi.ffi.dyn_fn_physics_service_get_collision_group_id(instance, p_name0, p_name1)
	return getPointer(instance):GetCollisionGroupId(loadString(memory, p_name0, p_name1));
end
function abi.ffi.dyn_fn_physics_service_get_collision_group_name(output, instance, p_name0)
	local value0 = getPointer(instance):GetCollisionGroupName(p_name0);
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_physics_service_get_max_collision_groups(instance)
	return getPointer(instance):GetMaxCollisionGroups();
end
function abi.ffi.dyn_fn_physics_service_is_collision_group_registered(instance, p_name0, p_name1)
	return getPointer(instance):IsCollisionGroupRegistered(loadString(memory, p_name0, p_name1)) and 1 or 0;
end
function abi.ffi.dyn_fn_physics_service_register_collision_group(instance, p_name0, p_name1)
	return getPointer(instance):RegisterCollisionGroup(loadString(memory, p_name0, p_name1));
end
function abi.ffi.dyn_fn_physics_service_remove_collision_group(instance, p_name0, p_name1)
	return getPointer(instance):RemoveCollisionGroup(loadString(memory, p_name0, p_name1));
end
function abi.ffi.dyn_fn_physics_service_rename_collision_group(instance, p_from0, p_from1, p_to0, p_to1)
	return getPointer(instance):RenameCollisionGroup(loadString(memory, p_from0, p_from1), loadString(memory, p_to0, p_to1));
end
function abi.ffi.dyn_fn_physics_service_set_part_collision_group(instance, p_part0, p_name0, p_name1)
	return getPointer(instance):SetPartCollisionGroup(getPointer(p_part0), loadString(memory, p_name0, p_name1));
end
function abi.ffi.dyn_fn_physics_service_unregister_collision_group(instance, p_name0, p_name1)
	return getPointer(instance):UnregisterCollisionGroup(loadString(memory, p_name0, p_name1));
end
function abi.ffi.prop_get_player_account_age(instance)
	return getPointer(instance).AccountAge;
end
function abi.ffi.prop_get_player_auto_jump_enabled(instance)
	return getPointer(instance).AutoJumpEnabled and 1 or 0;
end
function abi.ffi.prop_set_player_auto_jump_enabled(instance, p_AutoJumpEnabled0)
	getPointer(instance).AutoJumpEnabled = p_AutoJumpEnabled0 == 1;
end
function abi.ffi.prop_get_player_camera_max_zoom_distance(instance)
	return getPointer(instance).CameraMaxZoomDistance;
end
function abi.ffi.prop_set_player_camera_max_zoom_distance(instance, p_CameraMaxZoomDistance0)
	getPointer(instance).CameraMaxZoomDistance = p_CameraMaxZoomDistance0;
end
function abi.ffi.prop_get_player_camera_min_zoom_distance(instance)
	return getPointer(instance).CameraMinZoomDistance;
end
function abi.ffi.prop_set_player_camera_min_zoom_distance(instance, p_CameraMinZoomDistance0)
	getPointer(instance).CameraMinZoomDistance = p_CameraMinZoomDistance0;
end
function abi.ffi.prop_get_player_camera_mode(instance)
	return (getPointer(instance).CameraMode).Value;
end
function abi.ffi.prop_set_player_camera_mode(instance, p_CameraMode0)
	getPointer(instance).CameraMode = p_CameraMode0;
end
function abi.ffi.prop_get_player_can_load_character_appearance(instance)
	return getPointer(instance).CanLoadCharacterAppearance and 1 or 0;
end
function abi.ffi.prop_set_player_can_load_character_appearance(instance, p_CanLoadCharacterAppearance0)
	getPointer(instance).CanLoadCharacterAppearance = p_CanLoadCharacterAppearance0 == 1;
end
function abi.ffi.prop_get_player_character(output, instance)
	local value0 = getPointer(instance).Character;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_player_character(instance, p_Character0, p_Character1)
	local value0;
	if p_Character0 == 1 then
		value0 = getPointer(p_Character1);
	end
	getPointer(instance).Character = value0;
end
function abi.ffi.prop_get_player_character_appearance_id(instance)
	return getPointer(instance).CharacterAppearanceId;
end
function abi.ffi.prop_set_player_character_appearance_id(instance, p_CharacterAppearanceId0)
	getPointer(instance).CharacterAppearanceId = p_CharacterAppearanceId0;
end
function abi.ffi.prop_get_player_dev_camera_occlusion_mode(instance)
	return (getPointer(instance).DevCameraOcclusionMode).Value;
end
function abi.ffi.prop_set_player_dev_camera_occlusion_mode(instance, p_DevCameraOcclusionMode0)
	getPointer(instance).DevCameraOcclusionMode = p_DevCameraOcclusionMode0;
end
function abi.ffi.prop_get_player_dev_computer_camera_mode(instance)
	return (getPointer(instance).DevComputerCameraMode).Value;
end
function abi.ffi.prop_set_player_dev_computer_camera_mode(instance, p_DevComputerCameraMode0)
	getPointer(instance).DevComputerCameraMode = p_DevComputerCameraMode0;
end
function abi.ffi.prop_get_player_dev_computer_movement_mode(instance)
	return (getPointer(instance).DevComputerMovementMode).Value;
end
function abi.ffi.prop_set_player_dev_computer_movement_mode(instance, p_DevComputerMovementMode0)
	getPointer(instance).DevComputerMovementMode = p_DevComputerMovementMode0;
end
function abi.ffi.prop_get_player_dev_enable_mouse_lock(instance)
	return getPointer(instance).DevEnableMouseLock and 1 or 0;
end
function abi.ffi.prop_set_player_dev_enable_mouse_lock(instance, p_DevEnableMouseLock0)
	getPointer(instance).DevEnableMouseLock = p_DevEnableMouseLock0 == 1;
end
function abi.ffi.prop_get_player_dev_touch_camera_mode(instance)
	return (getPointer(instance).DevTouchCameraMode).Value;
end
function abi.ffi.prop_set_player_dev_touch_camera_mode(instance, p_DevTouchCameraMode0)
	getPointer(instance).DevTouchCameraMode = p_DevTouchCameraMode0;
end
function abi.ffi.prop_get_player_dev_touch_movement_mode(instance)
	return (getPointer(instance).DevTouchMovementMode).Value;
end
function abi.ffi.prop_set_player_dev_touch_movement_mode(instance, p_DevTouchMovementMode0)
	getPointer(instance).DevTouchMovementMode = p_DevTouchMovementMode0;
end
function abi.ffi.prop_get_player_display_name(output, instance)
	local value0 = getPointer(instance).DisplayName;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_player_display_name(instance, p_DisplayName0, p_DisplayName1)
	getPointer(instance).DisplayName = loadString(memory, p_DisplayName0, p_DisplayName1);
end
function abi.ffi.prop_get_player_follow_user_id(instance)
	return getPointer(instance).FollowUserId;
end
function abi.ffi.prop_get_player_gameplay_paused(instance)
	return getPointer(instance).GameplayPaused and 1 or 0;
end
function abi.ffi.prop_set_player_gameplay_paused(instance, p_GameplayPaused0)
	getPointer(instance).GameplayPaused = p_GameplayPaused0 == 1;
end
function abi.ffi.prop_get_player_health_display_distance(instance)
	return getPointer(instance).HealthDisplayDistance;
end
function abi.ffi.prop_set_player_health_display_distance(instance, p_HealthDisplayDistance0)
	getPointer(instance).HealthDisplayDistance = p_HealthDisplayDistance0;
end
function abi.ffi.prop_get_player_locale_id(output, instance)
	local value0 = getPointer(instance).LocaleId;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_player_membership_type(instance)
	return (getPointer(instance).MembershipType).Value;
end
function abi.ffi.prop_get_player_name_display_distance(instance)
	return getPointer(instance).NameDisplayDistance;
end
function abi.ffi.prop_set_player_name_display_distance(instance, p_NameDisplayDistance0)
	getPointer(instance).NameDisplayDistance = p_NameDisplayDistance0;
end
function abi.ffi.prop_get_player_neutral(instance)
	return getPointer(instance).Neutral and 1 or 0;
end
function abi.ffi.prop_set_player_neutral(instance, p_Neutral0)
	getPointer(instance).Neutral = p_Neutral0 == 1;
end
function abi.ffi.prop_get_player_replication_focus(output, instance)
	local value0 = getPointer(instance).ReplicationFocus;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_player_replication_focus(instance, p_ReplicationFocus0, p_ReplicationFocus1)
	local value0;
	if p_ReplicationFocus0 == 1 then
		value0 = getPointer(p_ReplicationFocus1);
	end
	getPointer(instance).ReplicationFocus = value0;
end
function abi.ffi.prop_get_player_respawn_location(output, instance)
	local value0 = getPointer(instance).RespawnLocation;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_player_respawn_location(instance, p_RespawnLocation0, p_RespawnLocation1)
	local value0;
	if p_RespawnLocation0 == 1 then
		value0 = getPointer(p_RespawnLocation1);
	end
	getPointer(instance).RespawnLocation = value0;
end
function abi.ffi.prop_get_player_team(output, instance)
	local value0 = getPointer(instance).Team;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_player_team(instance, p_Team0, p_Team1)
	local value0;
	if p_Team0 == 1 then
		value0 = getPointer(p_Team1);
	end
	getPointer(instance).Team = value0;
end
function abi.ffi.prop_get_player_team_color(instance)
	return createPointer(getPointer(instance).TeamColor);
end
function abi.ffi.prop_set_player_team_color(instance, p_TeamColor0)
	getPointer(instance).TeamColor = getPointer(p_TeamColor0);
end
function abi.ffi.prop_get_player_user_id(instance)
	return getPointer(instance).UserId;
end
function abi.ffi.prop_set_player_user_id(instance, p_UserId0)
	getPointer(instance).UserId = p_UserId0;
end
function abi.ffi.dyn_fn_player_clear_character_appearance(instance)
	return getPointer(instance):ClearCharacterAppearance();
end
function abi.ffi.dyn_fn_player_distance_from_character(instance, p_point0)
	return getPointer(instance):DistanceFromCharacter(getPointer(p_point0));
end
function abi.ffi.dyn_fn_player_get_join_data(instance)
	return createPointer(getPointer(instance):GetJoinData());
end
function abi.ffi.dyn_fn_player_get_mouse(output, instance)
	local value0 = getPointer(instance):GetMouse();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_player_get_network_ping(instance)
	return getPointer(instance):GetNetworkPing();
end
function abi.ffi.dyn_fn_player_has_appearance_loaded(instance)
	return getPointer(instance):HasAppearanceLoaded() and 1 or 0;
end
function abi.ffi.dyn_fn_player_kick(instance, p_message0, p_message1)
	return getPointer(instance):Kick(loadString(memory, p_message0, p_message1));
end
function abi.ffi.dyn_fn_player_fn_move(instance, p_walkDirection0, p_relativeToCamera0)
	return getPointer(instance):FnMove(getPointer(p_walkDirection0), p_relativeToCamera0 == 1);
end
function abi.ffi.dyn_fn_player_get_rank_in_group(instance, p_groupId0)
	return getPointer(instance):GetRankInGroup(p_groupId0);
end
function abi.ffi.dyn_fn_player_get_role_in_group(output, instance, p_groupId0)
	local value0 = getPointer(instance):GetRoleInGroup(p_groupId0);
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_player_is_friends_with(instance, p_userId0)
	return getPointer(instance):IsFriendsWith(p_userId0) and 1 or 0;
end
function abi.ffi.dyn_fn_player_is_in_group(instance, p_groupId0)
	return getPointer(instance):IsInGroup(p_groupId0) and 1 or 0;
end
function abi.ffi.dyn_fn_player_load_character(instance)
	return getPointer(instance):LoadCharacter();
end
function abi.ffi.dyn_fn_player_load_character_with_humanoid_description(instance, p_humanoidDescription0)
	return getPointer(instance):LoadCharacterWithHumanoidDescription(getPointer(p_humanoidDescription0));
end
function abi.ffi.dyn_fn_player_request_stream_around_async(instance, p_position0, p_timeOut0)
	return getPointer(instance):RequestStreamAroundAsync(getPointer(p_position0), p_timeOut0);
end
function abi.ffi.connect_player_character_added(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).CharacterAdded:Connect(function(p_character)
		local value0 = p_character;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_player_character_appearance_loaded(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).CharacterAppearanceLoaded:Connect(function(p_character)
		local value0 = p_character;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_player_character_removing(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).CharacterRemoving:Connect(function(p_character)
		local value0 = p_character;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_player_chatted(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Chatted:Connect(function(p_message, p_recipient)
		local value0 = p_message;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		local value1 = p_recipient;
		invokeFunction(data, vtable, stringContent0, stringLength0, value1 and 1 or 0, value1 and createPointer(value1) or 0);
	end))
end
function abi.ffi.connect_player_idled(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Idled:Connect(function(p_time)
		invokeFunction(data, vtable, p_time);
	end))
end
function abi.ffi.connect_player_teleport(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).OnTeleport:Connect(function(p_teleportState, p_placeId, p_spawnName)
		local value0 = p_spawnName;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, (p_teleportState).Value, p_placeId, stringContent0, stringLength0);
	end))
end
function abi.ffi.dyn_fn_player_scripts_clear_computer_camera_movement_modes(instance)
	return getPointer(instance):ClearComputerCameraMovementModes();
end
function abi.ffi.dyn_fn_player_scripts_clear_computer_movement_modes(instance)
	return getPointer(instance):ClearComputerMovementModes();
end
function abi.ffi.dyn_fn_player_scripts_clear_touch_camera_movement_modes(instance)
	return getPointer(instance):ClearTouchCameraMovementModes();
end
function abi.ffi.dyn_fn_player_scripts_clear_touch_movement_modes(instance)
	return getPointer(instance):ClearTouchMovementModes();
end
function abi.ffi.dyn_fn_player_scripts_register_computer_camera_movement_mode(instance, p_cameraMovementMode0)
	return getPointer(instance):RegisterComputerCameraMovementMode(p_cameraMovementMode0);
end
function abi.ffi.dyn_fn_player_scripts_register_computer_movement_mode(instance, p_movementMode0)
	return getPointer(instance):RegisterComputerMovementMode(p_movementMode0);
end
function abi.ffi.dyn_fn_player_scripts_register_touch_camera_movement_mode(instance, p_cameraMovementMode0)
	return getPointer(instance):RegisterTouchCameraMovementMode(p_cameraMovementMode0);
end
function abi.ffi.dyn_fn_player_scripts_register_touch_movement_mode(instance, p_movementMode0)
	return getPointer(instance):RegisterTouchMovementMode(p_movementMode0);
end
function abi.ffi.prop_get_players_bubble_chat(instance)
	return getPointer(instance).BubbleChat and 1 or 0;
end
function abi.ffi.prop_get_players_character_auto_loads(instance)
	return getPointer(instance).CharacterAutoLoads and 1 or 0;
end
function abi.ffi.prop_set_players_character_auto_loads(instance, p_CharacterAutoLoads0)
	getPointer(instance).CharacterAutoLoads = p_CharacterAutoLoads0 == 1;
end
function abi.ffi.prop_get_players_classic_chat(instance)
	return getPointer(instance).ClassicChat and 1 or 0;
end
function abi.ffi.prop_get_players_local_player(output, instance)
	local value0 = getPointer(instance).LocalPlayer;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_players_max_players(instance)
	return getPointer(instance).MaxPlayers;
end
function abi.ffi.prop_get_players_preferred_players(instance)
	return getPointer(instance).PreferredPlayers;
end
function abi.ffi.prop_get_players_respawn_time(instance)
	return getPointer(instance).RespawnTime;
end
function abi.ffi.prop_set_players_respawn_time(instance, p_RespawnTime0)
	getPointer(instance).RespawnTime = p_RespawnTime0;
end
function abi.ffi.dyn_fn_players_get_player_by_user_id(output, instance, p_userId0)
	local value0 = getPointer(instance):GetPlayerByUserId(p_userId0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_players_get_player_from_character(output, instance, p_character0)
	local value0 = getPointer(instance):GetPlayerFromCharacter(getPointer(p_character0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_players_get_players(output, instance)
	local result0 = getPointer(instance):GetPlayers();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_players_create_humanoid_model_from_description(output, instance, p_description0, p_rigType0, p_assetTypeVerification0)
	local value0 = getPointer(instance):CreateHumanoidModelFromDescription(getPointer(p_description0), p_rigType0, p_assetTypeVerification0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_players_create_humanoid_model_from_user_id(output, instance, p_userId0)
	local value0 = getPointer(instance):CreateHumanoidModelFromUserId(p_userId0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_players_get_character_appearance_info_async(instance, p_userId0)
	return createPointer(getPointer(instance):GetCharacterAppearanceInfoAsync(p_userId0));
end
function abi.ffi.dyn_fn_players_get_friends_async(output, instance, p_userId0)
	local value0 = getPointer(instance):GetFriendsAsync(p_userId0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_players_get_humanoid_description_from_outfit_id(output, instance, p_outfitId0)
	local value0 = getPointer(instance):GetHumanoidDescriptionFromOutfitId(p_outfitId0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_players_get_humanoid_description_from_user_id(output, instance, p_userId0)
	local value0 = getPointer(instance):GetHumanoidDescriptionFromUserId(p_userId0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_players_get_name_from_user_id_async(output, instance, p_userId0)
	local value0 = getPointer(instance):GetNameFromUserIdAsync(p_userId0);
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_players_get_user_id_from_name_async(instance, p_userName0, p_userName1)
	return getPointer(instance):GetUserIdFromNameAsync(loadString(memory, p_userName0, p_userName1));
end
function abi.ffi.connect_players_player_added(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PlayerAdded:Connect(function(p_player)
		local value0 = p_player;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_players_player_membership_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PlayerMembershipChanged:Connect(function(p_player)
		local value0 = p_player;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_players_player_removing(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PlayerRemoving:Connect(function(p_player)
		local value0 = p_player;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.dyn_fn_policy_service_get_policy_info_for_player_async(instance, p_player0)
	return createPointer(getPointer(instance):GetPolicyInfoForPlayerAsync(getPointer(p_player0)));
end
function abi.ffi.prop_get_pose_base_easing_direction(instance)
	return (getPointer(instance).EasingDirection).Value;
end
function abi.ffi.prop_set_pose_base_easing_direction(instance, p_EasingDirection0)
	getPointer(instance).EasingDirection = p_EasingDirection0;
end
function abi.ffi.prop_get_pose_base_easing_style(instance)
	return (getPointer(instance).EasingStyle).Value;
end
function abi.ffi.prop_set_pose_base_easing_style(instance, p_EasingStyle0)
	getPointer(instance).EasingStyle = p_EasingStyle0;
end
function abi.ffi.prop_get_pose_base_weight(instance)
	return getPointer(instance).Weight;
end
function abi.ffi.prop_set_pose_base_weight(instance, p_Weight0)
	getPointer(instance).Weight = p_Weight0;
end
function abi.ffi.prop_get_number_pose_value(instance)
	return getPointer(instance).Value;
end
function abi.ffi.prop_set_number_pose_value(instance, p_Value0)
	getPointer(instance).Value = p_Value0;
end
function abi.ffi.prop_get_pose_c_frame(instance)
	return createPointer(getPointer(instance).CFrame);
end
function abi.ffi.prop_set_pose_c_frame(instance, p_CFrame0)
	getPointer(instance).CFrame = getPointer(p_CFrame0);
end
function abi.ffi.dyn_fn_pose_add_sub_pose(instance, p_pose0)
	return getPointer(instance):AddSubPose(getPointer(p_pose0));
end
function abi.ffi.dyn_fn_pose_get_sub_poses(output, instance)
	local result0 = getPointer(instance):GetSubPoses();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_pose_remove_sub_pose(instance, p_pose0)
	return getPointer(instance):RemoveSubPose(getPointer(p_pose0));
end
function abi.ffi.prop_get_post_effect_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_post_effect_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_bloom_effect_intensity(instance)
	return getPointer(instance).Intensity;
end
function abi.ffi.prop_set_bloom_effect_intensity(instance, p_Intensity0)
	getPointer(instance).Intensity = p_Intensity0;
end
function abi.ffi.prop_get_bloom_effect_size(instance)
	return getPointer(instance).Size;
end
function abi.ffi.prop_set_bloom_effect_size(instance, p_Size0)
	getPointer(instance).Size = p_Size0;
end
function abi.ffi.prop_get_bloom_effect_threshold(instance)
	return getPointer(instance).Threshold;
end
function abi.ffi.prop_set_bloom_effect_threshold(instance, p_Threshold0)
	getPointer(instance).Threshold = p_Threshold0;
end
function abi.ffi.prop_get_blur_effect_size(instance)
	return getPointer(instance).Size;
end
function abi.ffi.prop_set_blur_effect_size(instance, p_Size0)
	getPointer(instance).Size = p_Size0;
end
function abi.ffi.prop_get_color_correction_effect_brightness(instance)
	return getPointer(instance).Brightness;
end
function abi.ffi.prop_set_color_correction_effect_brightness(instance, p_Brightness0)
	getPointer(instance).Brightness = p_Brightness0;
end
function abi.ffi.prop_get_color_correction_effect_contrast(instance)
	return getPointer(instance).Contrast;
end
function abi.ffi.prop_set_color_correction_effect_contrast(instance, p_Contrast0)
	getPointer(instance).Contrast = p_Contrast0;
end
function abi.ffi.prop_get_color_correction_effect_saturation(instance)
	return getPointer(instance).Saturation;
end
function abi.ffi.prop_set_color_correction_effect_saturation(instance, p_Saturation0)
	getPointer(instance).Saturation = p_Saturation0;
end
function abi.ffi.prop_get_color_correction_effect_tint_color(instance)
	return createPointer(getPointer(instance).TintColor);
end
function abi.ffi.prop_set_color_correction_effect_tint_color(instance, p_TintColor0)
	getPointer(instance).TintColor = getPointer(p_TintColor0);
end
function abi.ffi.prop_get_depth_of_field_effect_far_intensity(instance)
	return getPointer(instance).FarIntensity;
end
function abi.ffi.prop_set_depth_of_field_effect_far_intensity(instance, p_FarIntensity0)
	getPointer(instance).FarIntensity = p_FarIntensity0;
end
function abi.ffi.prop_get_depth_of_field_effect_focus_distance(instance)
	return getPointer(instance).FocusDistance;
end
function abi.ffi.prop_set_depth_of_field_effect_focus_distance(instance, p_FocusDistance0)
	getPointer(instance).FocusDistance = p_FocusDistance0;
end
function abi.ffi.prop_get_depth_of_field_effect_in_focus_radius(instance)
	return getPointer(instance).InFocusRadius;
end
function abi.ffi.prop_set_depth_of_field_effect_in_focus_radius(instance, p_InFocusRadius0)
	getPointer(instance).InFocusRadius = p_InFocusRadius0;
end
function abi.ffi.prop_get_depth_of_field_effect_near_intensity(instance)
	return getPointer(instance).NearIntensity;
end
function abi.ffi.prop_set_depth_of_field_effect_near_intensity(instance, p_NearIntensity0)
	getPointer(instance).NearIntensity = p_NearIntensity0;
end
function abi.ffi.prop_get_sun_rays_effect_intensity(instance)
	return getPointer(instance).Intensity;
end
function abi.ffi.prop_set_sun_rays_effect_intensity(instance, p_Intensity0)
	getPointer(instance).Intensity = p_Intensity0;
end
function abi.ffi.prop_get_sun_rays_effect_spread(instance)
	return getPointer(instance).Spread;
end
function abi.ffi.prop_set_sun_rays_effect_spread(instance, p_Spread0)
	getPointer(instance).Spread = p_Spread0;
end
function abi.ffi.prop_get_proximity_prompt_action_text(output, instance)
	local value0 = getPointer(instance).ActionText;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_proximity_prompt_action_text(instance, p_ActionText0, p_ActionText1)
	getPointer(instance).ActionText = loadString(memory, p_ActionText0, p_ActionText1);
end
function abi.ffi.prop_get_proximity_prompt_auto_localize(instance)
	return getPointer(instance).AutoLocalize and 1 or 0;
end
function abi.ffi.prop_set_proximity_prompt_auto_localize(instance, p_AutoLocalize0)
	getPointer(instance).AutoLocalize = p_AutoLocalize0 == 1;
end
function abi.ffi.prop_get_proximity_prompt_clickable_prompt(instance)
	return getPointer(instance).ClickablePrompt and 1 or 0;
end
function abi.ffi.prop_set_proximity_prompt_clickable_prompt(instance, p_ClickablePrompt0)
	getPointer(instance).ClickablePrompt = p_ClickablePrompt0 == 1;
end
function abi.ffi.prop_get_proximity_prompt_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_proximity_prompt_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_proximity_prompt_exclusivity(instance)
	return (getPointer(instance).Exclusivity).Value;
end
function abi.ffi.prop_set_proximity_prompt_exclusivity(instance, p_Exclusivity0)
	getPointer(instance).Exclusivity = p_Exclusivity0;
end
function abi.ffi.prop_get_proximity_prompt_gamepad_key_code(instance)
	return (getPointer(instance).GamepadKeyCode).Value;
end
function abi.ffi.prop_set_proximity_prompt_gamepad_key_code(instance, p_GamepadKeyCode0)
	getPointer(instance).GamepadKeyCode = p_GamepadKeyCode0;
end
function abi.ffi.prop_get_proximity_prompt_hold_duration(instance)
	return getPointer(instance).HoldDuration;
end
function abi.ffi.prop_set_proximity_prompt_hold_duration(instance, p_HoldDuration0)
	getPointer(instance).HoldDuration = p_HoldDuration0;
end
function abi.ffi.prop_get_proximity_prompt_keyboard_key_code(instance)
	return (getPointer(instance).KeyboardKeyCode).Value;
end
function abi.ffi.prop_set_proximity_prompt_keyboard_key_code(instance, p_KeyboardKeyCode0)
	getPointer(instance).KeyboardKeyCode = p_KeyboardKeyCode0;
end
function abi.ffi.prop_get_proximity_prompt_max_activation_distance(instance)
	return getPointer(instance).MaxActivationDistance;
end
function abi.ffi.prop_set_proximity_prompt_max_activation_distance(instance, p_MaxActivationDistance0)
	getPointer(instance).MaxActivationDistance = p_MaxActivationDistance0;
end
function abi.ffi.prop_get_proximity_prompt_object_text(output, instance)
	local value0 = getPointer(instance).ObjectText;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_proximity_prompt_object_text(instance, p_ObjectText0, p_ObjectText1)
	getPointer(instance).ObjectText = loadString(memory, p_ObjectText0, p_ObjectText1);
end
function abi.ffi.prop_get_proximity_prompt_requires_line_of_sight(instance)
	return getPointer(instance).RequiresLineOfSight and 1 or 0;
end
function abi.ffi.prop_set_proximity_prompt_requires_line_of_sight(instance, p_RequiresLineOfSight0)
	getPointer(instance).RequiresLineOfSight = p_RequiresLineOfSight0 == 1;
end
function abi.ffi.prop_get_proximity_prompt_root_localization_table(output, instance)
	local value0 = getPointer(instance).RootLocalizationTable;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_proximity_prompt_root_localization_table(instance, p_RootLocalizationTable0, p_RootLocalizationTable1)
	local value0;
	if p_RootLocalizationTable0 == 1 then
		value0 = getPointer(p_RootLocalizationTable1);
	end
	getPointer(instance).RootLocalizationTable = value0;
end
function abi.ffi.prop_get_proximity_prompt_style(instance)
	return (getPointer(instance).Style).Value;
end
function abi.ffi.prop_set_proximity_prompt_style(instance, p_Style0)
	getPointer(instance).Style = p_Style0;
end
function abi.ffi.prop_get_proximity_prompt_ui_offset(instance)
	return createPointer(getPointer(instance).UIOffset);
end
function abi.ffi.prop_set_proximity_prompt_ui_offset(instance, p_UIOffset0)
	getPointer(instance).UIOffset = getPointer(p_UIOffset0);
end
function abi.ffi.dyn_fn_proximity_prompt_input_hold_begin(instance)
	return getPointer(instance):InputHoldBegin();
end
function abi.ffi.dyn_fn_proximity_prompt_input_hold_end(instance)
	return getPointer(instance):InputHoldEnd();
end
function abi.ffi.connect_proximity_prompt_prompt_button_hold_began(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptButtonHoldBegan:Connect(function(p_playerWhoTriggered)
		local value0 = p_playerWhoTriggered;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_proximity_prompt_prompt_button_hold_ended(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptButtonHoldEnded:Connect(function(p_playerWhoTriggered)
		local value0 = p_playerWhoTriggered;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_proximity_prompt_prompt_hidden(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptHidden:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_proximity_prompt_prompt_shown(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptShown:Connect(function(p_inputType)
		invokeFunction(data, vtable, (p_inputType).Value);
	end))
end
function abi.ffi.connect_proximity_prompt_trigger_ended(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TriggerEnded:Connect(function(p_playerWhoTriggered)
		local value0 = p_playerWhoTriggered;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_proximity_prompt_triggered(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Triggered:Connect(function(p_playerWhoTriggered)
		local value0 = p_playerWhoTriggered;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.prop_get_proximity_prompt_service_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_proximity_prompt_service_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_proximity_prompt_service_max_prompts_visible(instance)
	return getPointer(instance).MaxPromptsVisible;
end
function abi.ffi.prop_set_proximity_prompt_service_max_prompts_visible(instance, p_MaxPromptsVisible0)
	getPointer(instance).MaxPromptsVisible = p_MaxPromptsVisible0;
end
function abi.ffi.connect_proximity_prompt_service_prompt_button_hold_began(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptButtonHoldBegan:Connect(function(p_prompt, p_playerWhoTriggered)
		local value0 = p_prompt;
		local value1 = p_playerWhoTriggered;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, value1 and 1 or 0, value1 and createPointer(value1) or 0);
	end))
end
function abi.ffi.connect_proximity_prompt_service_prompt_button_hold_ended(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptButtonHoldEnded:Connect(function(p_prompt, p_playerWhoTriggered)
		local value0 = p_prompt;
		local value1 = p_playerWhoTriggered;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, value1 and 1 or 0, value1 and createPointer(value1) or 0);
	end))
end
function abi.ffi.connect_proximity_prompt_service_prompt_hidden(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptHidden:Connect(function(p_prompt)
		local value0 = p_prompt;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_proximity_prompt_service_prompt_shown(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptShown:Connect(function(p_prompt, p_inputType)
		local value0 = p_prompt;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, (p_inputType).Value);
	end))
end
function abi.ffi.connect_proximity_prompt_service_prompt_trigger_ended(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptTriggerEnded:Connect(function(p_prompt, p_playerWhoTriggered)
		local value0 = p_prompt;
		local value1 = p_playerWhoTriggered;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, value1 and 1 or 0, value1 and createPointer(value1) or 0);
	end))
end
function abi.ffi.connect_proximity_prompt_service_prompt_triggered(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PromptTriggered:Connect(function(p_prompt, p_playerWhoTriggered)
		local value0 = p_prompt;
		local value1 = p_playerWhoTriggered;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, value1 and 1 or 0, value1 and createPointer(value1) or 0);
	end))
end
function abi.ffi.dyn_fn_remote_event_fire_all_clients(instance, p_arguments0, p_arguments1)
	local result0 = table.create(p_arguments1)
	for i = 1, p_arguments1 do
		local value0_0 = loadU32(memory, p_arguments0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	return getPointer(instance):FireAllClients(unpack(result0, 1, p_arguments1));
end
function abi.ffi.dyn_fn_remote_event_fire_client(instance, p_player0, p_arguments0, p_arguments1)
	local result0 = table.create(p_arguments1)
	for i = 1, p_arguments1 do
		local value0_0 = loadU32(memory, p_arguments0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	return getPointer(instance):FireClient(getPointer(p_player0), unpack(result0, 1, p_arguments1));
end
function abi.ffi.dyn_fn_remote_event_fire_server(instance, p_arguments0, p_arguments1)
	local result0 = table.create(p_arguments1)
	for i = 1, p_arguments1 do
		local value0_0 = loadU32(memory, p_arguments0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	return getPointer(instance):FireServer(unpack(result0, 1, p_arguments1));
end
function abi.ffi.connect_remote_event_client_event(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).OnClientEvent:Connect(function(...)
		local length0 = select('#', ...);
		local vec0 = allocVec(length0 * 1);
		for i = 1, length0 do
			storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(select(i, ...)))
		end
		invokeFunction(data, vtable, vec0, length0);
	end))
end
function abi.ffi.connect_remote_event_server_event(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).OnServerEvent:Connect(function(p_player, ...)
		local length0 = select('#', ...);
		local vec0 = allocVec(length0 * 1);
		for i = 1, length0 do
			storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(select(i, ...)))
		end
		invokeFunction(data, vtable, createPointer(p_player), vec0, length0);
	end))
end
function abi.ffi.dyn_fn_remote_function_invoke_client(output, instance, p_player0, p_arguments0, p_arguments1)
	local result0 = table.create(p_arguments1)
	for i = 1, p_arguments1 do
		local value0_0 = loadU32(memory, p_arguments0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	local value0 = { getPointer(instance):InvokeClient(getPointer(p_player0), unpack(result0, 1, p_arguments1)) };
	local length0 = #value0;
	local vec0 = allocVec(length0 * 1);
	for i = 1, length0 do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(value0[i]))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, length0)
end
function abi.ffi.dyn_fn_remote_function_invoke_server(output, instance, p_arguments0, p_arguments1)
	local result0 = table.create(p_arguments1)
	for i = 1, p_arguments1 do
		local value0_0 = loadU32(memory, p_arguments0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	local value0 = { getPointer(instance):InvokeServer(unpack(result0, 1, p_arguments1)) };
	local length0 = #value0;
	local vec0 = allocVec(length0 * 1);
	for i = 1, length0 do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(value0[i]))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, length0)
end
function abi.ffi.callback_set_remote_function_on_client_invoke(instance, destructor, data, vtable)
	getPointer(instance).OnClientInvoke = function(...)
		local length0 = select('#', ...);
		local vec0 = allocVec(length0 * 1);
		for i = 1, length0 do
			storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(select(i, ...)))
		end
		local response1, response2 = invokeFunction(data, vtable, vec0, length0)
		local result3 = table.create(response2)
		for i = 1, response2 do
			local value3_0 = loadU32(memory, response1 + (i - 1) * 4 + 0);
			result3[i] = getPointer(value3_0)
		end
		functions.data[destructor](response1, response2);
		return unpack(result3, 1, response2);
	end
end
function abi.ffi.callback_set_remote_function_on_server_invoke(instance, destructor, data, vtable)
	getPointer(instance).OnServerInvoke = function(p_player, ...)
		local length0 = select('#', ...);
		local vec0 = allocVec(length0 * 1);
		for i = 1, length0 do
			storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(select(i, ...)))
		end
		local response1, response2 = invokeFunction(data, vtable, createPointer(p_player), vec0, length0)
		local result3 = table.create(response2)
		for i = 1, response2 do
			local value3_0 = loadU32(memory, response1 + (i - 1) * 4 + 0);
			result3[i] = getPointer(value3_0)
		end
		functions.data[destructor](response1, response2);
		return unpack(result3, 1, response2);
	end
end
function abi.ffi.dyn_fn_replicated_first_remove_default_loading_screen(instance)
	return getPointer(instance):RemoveDefaultLoadingScreen();
end
function abi.ffi.prop_get_rotation_curve_length(instance)
	return getPointer(instance).Length;
end
function abi.ffi.dyn_fn_rotation_curve_get_key_at_index(instance, p_index0)
	return createPointer(getPointer(instance):GetKeyAtIndex(p_index0));
end
function abi.ffi.dyn_fn_rotation_curve_get_value_at_time(output, instance, p_time0)
	local value0 = getPointer(instance):GetValueAtTime(p_time0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_rotation_curve_remove_key_at_index(instance, p_startingIndex0, p_count0)
	return getPointer(instance):RemoveKeyAtIndex(p_startingIndex0, p_count0);
end
function abi.ffi.dyn_fn_run_service_is_client(instance)
	return getPointer(instance):IsClient() and 1 or 0;
end
function abi.ffi.dyn_fn_run_service_is_run_mode(instance)
	return getPointer(instance):IsRunMode() and 1 or 0;
end
function abi.ffi.dyn_fn_run_service_is_running(instance)
	return getPointer(instance):IsRunning() and 1 or 0;
end
function abi.ffi.dyn_fn_run_service_is_server(instance)
	return getPointer(instance):IsServer() and 1 or 0;
end
function abi.ffi.dyn_fn_run_service_is_studio(instance)
	return getPointer(instance):IsStudio() and 1 or 0;
end
function abi.ffi.dyn_fn_run_service_unbind_from_render_step(instance, p_name0, p_name1)
	return getPointer(instance):UnbindFromRenderStep(loadString(memory, p_name0, p_name1));
end
function abi.ffi.connect_run_service_heartbeat(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Heartbeat:Connect(function(p_deltaTime)
		invokeFunction(data, vtable, p_deltaTime);
	end))
end
function abi.ffi.connect_run_service_post_simulation(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PostSimulation:Connect(function(p_deltaTimeSim)
		invokeFunction(data, vtable, p_deltaTimeSim);
	end))
end
function abi.ffi.connect_run_service_pre_animation(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PreAnimation:Connect(function(p_deltaTimeSim)
		invokeFunction(data, vtable, p_deltaTimeSim);
	end))
end
function abi.ffi.connect_run_service_pre_render(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PreRender:Connect(function(p_deltaTimeRender)
		invokeFunction(data, vtable, p_deltaTimeRender);
	end))
end
function abi.ffi.connect_run_service_pre_simulation(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PreSimulation:Connect(function(p_deltaTimeSim)
		invokeFunction(data, vtable, p_deltaTimeSim);
	end))
end
function abi.ffi.connect_run_service_render_stepped(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).RenderStepped:Connect(function(p_deltaTime)
		invokeFunction(data, vtable, p_deltaTime);
	end))
end
function abi.ffi.connect_run_service_stepped(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Stepped:Connect(function(p_time, p_deltaTime)
		invokeFunction(data, vtable, p_time, p_deltaTime);
	end))
end
function abi.ffi.prop_get_screenshot_hud_camera_button_icon(instance)
	return createPointer(getPointer(instance).CameraButtonIcon);
end
function abi.ffi.prop_set_screenshot_hud_camera_button_icon(instance, p_CameraButtonIcon0)
	getPointer(instance).CameraButtonIcon = getPointer(p_CameraButtonIcon0);
end
function abi.ffi.prop_get_screenshot_hud_camera_button_position(instance)
	return createPointer(getPointer(instance).CameraButtonPosition);
end
function abi.ffi.prop_set_screenshot_hud_camera_button_position(instance, p_CameraButtonPosition0)
	getPointer(instance).CameraButtonPosition = getPointer(p_CameraButtonPosition0);
end
function abi.ffi.prop_get_screenshot_hud_close_button_position(instance)
	return createPointer(getPointer(instance).CloseButtonPosition);
end
function abi.ffi.prop_set_screenshot_hud_close_button_position(instance, p_CloseButtonPosition0)
	getPointer(instance).CloseButtonPosition = getPointer(p_CloseButtonPosition0);
end
function abi.ffi.prop_get_screenshot_hud_close_when_screenshot_taken(instance)
	return getPointer(instance).CloseWhenScreenshotTaken and 1 or 0;
end
function abi.ffi.prop_set_screenshot_hud_close_when_screenshot_taken(instance, p_CloseWhenScreenshotTaken0)
	getPointer(instance).CloseWhenScreenshotTaken = p_CloseWhenScreenshotTaken0 == 1;
end
function abi.ffi.prop_get_screenshot_hud_experience_name_overlay_enabled(instance)
	return getPointer(instance).ExperienceNameOverlayEnabled and 1 or 0;
end
function abi.ffi.prop_set_screenshot_hud_experience_name_overlay_enabled(instance, p_ExperienceNameOverlayEnabled0)
	getPointer(instance).ExperienceNameOverlayEnabled = p_ExperienceNameOverlayEnabled0 == 1;
end
function abi.ffi.prop_get_screenshot_hud_overlay_font(instance)
	return (getPointer(instance).OverlayFont).Value;
end
function abi.ffi.prop_set_screenshot_hud_overlay_font(instance, p_OverlayFont0)
	getPointer(instance).OverlayFont = p_OverlayFont0;
end
function abi.ffi.prop_get_screenshot_hud_username_overlay_enabled(instance)
	return getPointer(instance).UsernameOverlayEnabled and 1 or 0;
end
function abi.ffi.prop_set_screenshot_hud_username_overlay_enabled(instance, p_UsernameOverlayEnabled0)
	getPointer(instance).UsernameOverlayEnabled = p_UsernameOverlayEnabled0 == 1;
end
function abi.ffi.prop_get_screenshot_hud_visible(instance)
	return getPointer(instance).Visible and 1 or 0;
end
function abi.ffi.prop_set_screenshot_hud_visible(instance, p_Visible0)
	getPointer(instance).Visible = p_Visible0 == 1;
end
function abi.ffi.connect_script_context_error(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Error:Connect(function(p_message, p_stackTrace, p_script)
		local value0 = p_message;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		local value1 = p_stackTrace;
		local stringContent1, stringLength1 = allocString(#value1), #value1;
		for i = 1, stringLength1 do
			storeU8(memory, stringContent1 + (i - 1), string.byte(value1:sub(i, i)));
		end
		local value2 = p_script;
		invokeFunction(data, vtable, stringContent0, stringLength0, stringContent1, stringLength1, value2 and 1 or 0, value2 and createPointer(value2) or 0);
	end))
end
function abi.ffi.dyn_fn_service_provider_find_service(output, instance, p_className0, p_className1)
	local value0 = getPointer(instance):FindService(loadString(memory, p_className0, p_className1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_service_provider_get_service(output, instance, p_className0, p_className1)
	local value0 = getPointer(instance):GetService(loadString(memory, p_className0, p_className1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.connect_service_provider_close(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Close:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_service_provider_service_added(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).ServiceAdded:Connect(function(p_service)
		local value0 = p_service;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_service_provider_service_removing(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).ServiceRemoving:Connect(function(p_service)
		local value0 = p_service;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.prop_get_data_model_creator_id(instance)
	return getPointer(instance).CreatorId;
end
function abi.ffi.prop_get_data_model_creator_type(instance)
	return (getPointer(instance).CreatorType).Value;
end
function abi.ffi.prop_get_data_model_game_id(instance)
	return getPointer(instance).GameId;
end
function abi.ffi.prop_get_data_model_genre(instance)
	return (getPointer(instance).Genre).Value;
end
function abi.ffi.prop_get_data_model_job_id(output, instance)
	local value0 = getPointer(instance).JobId;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_data_model_place_id(instance)
	return getPointer(instance).PlaceId;
end
function abi.ffi.prop_get_data_model_place_version(instance)
	return getPointer(instance).PlaceVersion;
end
function abi.ffi.prop_get_data_model_private_server_id(output, instance)
	local value0 = getPointer(instance).PrivateServerId;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_data_model_private_server_owner_id(instance)
	return getPointer(instance).PrivateServerOwnerId;
end
function abi.ffi.prop_get_data_model_workspace(output, instance)
	local value0 = getPointer(instance).Workspace;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_data_model_is_loaded(instance)
	return getPointer(instance):IsLoaded() and 1 or 0;
end
function abi.ffi.connect_data_model_graphics_quality_change_request(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).GraphicsQualityChangeRequest:Connect(function(p_betterQuality)
		invokeFunction(data, vtable, p_betterQuality and 1 or 0);
	end))
end
function abi.ffi.connect_data_model_loaded(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Loaded:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.dyn_fn_user_settings_is_user_feature_enabled(instance, p_name0, p_name1)
	return getPointer(instance):IsUserFeatureEnabled(loadString(memory, p_name0, p_name1)) and 1 or 0;
end
function abi.ffi.dyn_fn_user_settings_reset(instance)
	return getPointer(instance):Reset();
end
function abi.ffi.prop_get_sky_celestial_bodies_shown(instance)
	return getPointer(instance).CelestialBodiesShown and 1 or 0;
end
function abi.ffi.prop_set_sky_celestial_bodies_shown(instance, p_CelestialBodiesShown0)
	getPointer(instance).CelestialBodiesShown = p_CelestialBodiesShown0 == 1;
end
function abi.ffi.prop_get_sky_moon_angular_size(instance)
	return getPointer(instance).MoonAngularSize;
end
function abi.ffi.prop_set_sky_moon_angular_size(instance, p_MoonAngularSize0)
	getPointer(instance).MoonAngularSize = p_MoonAngularSize0;
end
function abi.ffi.prop_get_sky_moon_texture_id(instance)
	return createPointer(getPointer(instance).MoonTextureId);
end
function abi.ffi.prop_set_sky_moon_texture_id(instance, p_MoonTextureId0)
	getPointer(instance).MoonTextureId = getPointer(p_MoonTextureId0);
end
function abi.ffi.prop_get_sky_skybox_bk(instance)
	return createPointer(getPointer(instance).SkyboxBk);
end
function abi.ffi.prop_set_sky_skybox_bk(instance, p_SkyboxBk0)
	getPointer(instance).SkyboxBk = getPointer(p_SkyboxBk0);
end
function abi.ffi.prop_get_sky_skybox_dn(instance)
	return createPointer(getPointer(instance).SkyboxDn);
end
function abi.ffi.prop_set_sky_skybox_dn(instance, p_SkyboxDn0)
	getPointer(instance).SkyboxDn = getPointer(p_SkyboxDn0);
end
function abi.ffi.prop_get_sky_skybox_ft(instance)
	return createPointer(getPointer(instance).SkyboxFt);
end
function abi.ffi.prop_set_sky_skybox_ft(instance, p_SkyboxFt0)
	getPointer(instance).SkyboxFt = getPointer(p_SkyboxFt0);
end
function abi.ffi.prop_get_sky_skybox_lf(instance)
	return createPointer(getPointer(instance).SkyboxLf);
end
function abi.ffi.prop_set_sky_skybox_lf(instance, p_SkyboxLf0)
	getPointer(instance).SkyboxLf = getPointer(p_SkyboxLf0);
end
function abi.ffi.prop_get_sky_skybox_rt(instance)
	return createPointer(getPointer(instance).SkyboxRt);
end
function abi.ffi.prop_set_sky_skybox_rt(instance, p_SkyboxRt0)
	getPointer(instance).SkyboxRt = getPointer(p_SkyboxRt0);
end
function abi.ffi.prop_get_sky_skybox_up(instance)
	return createPointer(getPointer(instance).SkyboxUp);
end
function abi.ffi.prop_set_sky_skybox_up(instance, p_SkyboxUp0)
	getPointer(instance).SkyboxUp = getPointer(p_SkyboxUp0);
end
function abi.ffi.prop_get_sky_star_count(instance)
	return getPointer(instance).StarCount;
end
function abi.ffi.prop_set_sky_star_count(instance, p_StarCount0)
	getPointer(instance).StarCount = p_StarCount0;
end
function abi.ffi.prop_get_sky_sun_angular_size(instance)
	return getPointer(instance).SunAngularSize;
end
function abi.ffi.prop_set_sky_sun_angular_size(instance, p_SunAngularSize0)
	getPointer(instance).SunAngularSize = p_SunAngularSize0;
end
function abi.ffi.prop_get_sky_sun_texture_id(instance)
	return createPointer(getPointer(instance).SunTextureId);
end
function abi.ffi.prop_set_sky_sun_texture_id(instance, p_SunTextureId0)
	getPointer(instance).SunTextureId = getPointer(p_SunTextureId0);
end
function abi.ffi.prop_get_smoke_color(instance)
	return createPointer(getPointer(instance).Color);
end
function abi.ffi.prop_set_smoke_color(instance, p_Color0)
	getPointer(instance).Color = getPointer(p_Color0);
end
function abi.ffi.prop_get_smoke_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_smoke_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_smoke_opacity(instance)
	return getPointer(instance).Opacity;
end
function abi.ffi.prop_set_smoke_opacity(instance, p_Opacity0)
	getPointer(instance).Opacity = p_Opacity0;
end
function abi.ffi.prop_get_smoke_rise_velocity(instance)
	return getPointer(instance).RiseVelocity;
end
function abi.ffi.prop_set_smoke_rise_velocity(instance, p_RiseVelocity0)
	getPointer(instance).RiseVelocity = p_RiseVelocity0;
end
function abi.ffi.prop_get_smoke_size(instance)
	return getPointer(instance).Size;
end
function abi.ffi.prop_set_smoke_size(instance, p_Size0)
	getPointer(instance).Size = p_Size0;
end
function abi.ffi.prop_get_smoke_time_scale(instance)
	return getPointer(instance).TimeScale;
end
function abi.ffi.prop_set_smoke_time_scale(instance, p_TimeScale0)
	getPointer(instance).TimeScale = p_TimeScale0;
end
function abi.ffi.dyn_fn_social_service_prompt_game_invite(instance, p_player0)
	return getPointer(instance):PromptGameInvite(getPointer(p_player0));
end
function abi.ffi.dyn_fn_social_service_can_send_game_invite_async(instance, p_player0, p_recipientId0)
	return getPointer(instance):CanSendGameInviteAsync(getPointer(p_player0), p_recipientId0) and 1 or 0;
end
function abi.ffi.prop_get_sound_is_loaded(instance)
	return getPointer(instance).IsLoaded and 1 or 0;
end
function abi.ffi.prop_get_sound_is_paused(instance)
	return getPointer(instance).IsPaused and 1 or 0;
end
function abi.ffi.prop_get_sound_is_playing(instance)
	return getPointer(instance).IsPlaying and 1 or 0;
end
function abi.ffi.prop_get_sound_loop_region(instance)
	return createPointer(getPointer(instance).LoopRegion);
end
function abi.ffi.prop_set_sound_loop_region(instance, p_LoopRegion0)
	getPointer(instance).LoopRegion = getPointer(p_LoopRegion0);
end
function abi.ffi.prop_get_sound_looped(instance)
	return getPointer(instance).Looped and 1 or 0;
end
function abi.ffi.prop_set_sound_looped(instance, p_Looped0)
	getPointer(instance).Looped = p_Looped0 == 1;
end
function abi.ffi.prop_get_sound_play_on_remove(instance)
	return getPointer(instance).PlayOnRemove and 1 or 0;
end
function abi.ffi.prop_set_sound_play_on_remove(instance, p_PlayOnRemove0)
	getPointer(instance).PlayOnRemove = p_PlayOnRemove0 == 1;
end
function abi.ffi.prop_get_sound_playback_loudness(instance)
	return getPointer(instance).PlaybackLoudness;
end
function abi.ffi.prop_get_sound_playback_region(instance)
	return createPointer(getPointer(instance).PlaybackRegion);
end
function abi.ffi.prop_set_sound_playback_region(instance, p_PlaybackRegion0)
	getPointer(instance).PlaybackRegion = getPointer(p_PlaybackRegion0);
end
function abi.ffi.prop_get_sound_playback_regions_enabled(instance)
	return getPointer(instance).PlaybackRegionsEnabled and 1 or 0;
end
function abi.ffi.prop_set_sound_playback_regions_enabled(instance, p_PlaybackRegionsEnabled0)
	getPointer(instance).PlaybackRegionsEnabled = p_PlaybackRegionsEnabled0 == 1;
end
function abi.ffi.prop_get_sound_playback_speed(instance)
	return getPointer(instance).PlaybackSpeed;
end
function abi.ffi.prop_set_sound_playback_speed(instance, p_PlaybackSpeed0)
	getPointer(instance).PlaybackSpeed = p_PlaybackSpeed0;
end
function abi.ffi.prop_get_sound_playing(instance)
	return getPointer(instance).Playing and 1 or 0;
end
function abi.ffi.prop_set_sound_playing(instance, p_Playing0)
	getPointer(instance).Playing = p_Playing0 == 1;
end
function abi.ffi.prop_get_sound_roll_off_max_distance(instance)
	return getPointer(instance).RollOffMaxDistance;
end
function abi.ffi.prop_set_sound_roll_off_max_distance(instance, p_RollOffMaxDistance0)
	getPointer(instance).RollOffMaxDistance = p_RollOffMaxDistance0;
end
function abi.ffi.prop_get_sound_roll_off_min_distance(instance)
	return getPointer(instance).RollOffMinDistance;
end
function abi.ffi.prop_set_sound_roll_off_min_distance(instance, p_RollOffMinDistance0)
	getPointer(instance).RollOffMinDistance = p_RollOffMinDistance0;
end
function abi.ffi.prop_get_sound_roll_off_mode(instance)
	return (getPointer(instance).RollOffMode).Value;
end
function abi.ffi.prop_set_sound_roll_off_mode(instance, p_RollOffMode0)
	getPointer(instance).RollOffMode = p_RollOffMode0;
end
function abi.ffi.prop_get_sound_sound_group(output, instance)
	local value0 = getPointer(instance).SoundGroup;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_sound_sound_group(instance, p_SoundGroup0, p_SoundGroup1)
	local value0;
	if p_SoundGroup0 == 1 then
		value0 = getPointer(p_SoundGroup1);
	end
	getPointer(instance).SoundGroup = value0;
end
function abi.ffi.prop_get_sound_sound_id(instance)
	return createPointer(getPointer(instance).SoundId);
end
function abi.ffi.prop_set_sound_sound_id(instance, p_SoundId0)
	getPointer(instance).SoundId = getPointer(p_SoundId0);
end
function abi.ffi.prop_get_sound_time_length(instance)
	return getPointer(instance).TimeLength;
end
function abi.ffi.prop_get_sound_time_position(instance)
	return getPointer(instance).TimePosition;
end
function abi.ffi.prop_set_sound_time_position(instance, p_TimePosition0)
	getPointer(instance).TimePosition = p_TimePosition0;
end
function abi.ffi.prop_get_sound_volume(instance)
	return getPointer(instance).Volume;
end
function abi.ffi.prop_set_sound_volume(instance, p_Volume0)
	getPointer(instance).Volume = p_Volume0;
end
function abi.ffi.dyn_fn_sound_pause(instance)
	return getPointer(instance):Pause();
end
function abi.ffi.dyn_fn_sound_play(instance)
	return getPointer(instance):Play();
end
function abi.ffi.dyn_fn_sound_resume(instance)
	return getPointer(instance):Resume();
end
function abi.ffi.dyn_fn_sound_stop(instance)
	return getPointer(instance):Stop();
end
function abi.ffi.connect_sound_did_loop(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).DidLoop:Connect(function(p_soundId, p_numOfTimesLooped)
		local value0 = p_soundId;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0, p_numOfTimesLooped);
	end))
end
function abi.ffi.connect_sound_ended(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Ended:Connect(function(p_soundId)
		local value0 = p_soundId;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.connect_sound_loaded(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Loaded:Connect(function(p_soundId)
		local value0 = p_soundId;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.connect_sound_paused(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Paused:Connect(function(p_soundId)
		local value0 = p_soundId;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.connect_sound_played(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Played:Connect(function(p_soundId)
		local value0 = p_soundId;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.connect_sound_resumed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Resumed:Connect(function(p_soundId)
		local value0 = p_soundId;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.connect_sound_stopped(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Stopped:Connect(function(p_soundId)
		local value0 = p_soundId;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.prop_get_sound_effect_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_sound_effect_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_sound_effect_priority(instance)
	return getPointer(instance).Priority;
end
function abi.ffi.prop_set_sound_effect_priority(instance, p_Priority0)
	getPointer(instance).Priority = p_Priority0;
end
function abi.ffi.prop_get_chorus_sound_effect_depth(instance)
	return getPointer(instance).Depth;
end
function abi.ffi.prop_set_chorus_sound_effect_depth(instance, p_Depth0)
	getPointer(instance).Depth = p_Depth0;
end
function abi.ffi.prop_get_chorus_sound_effect_mix(instance)
	return getPointer(instance).Mix;
end
function abi.ffi.prop_set_chorus_sound_effect_mix(instance, p_Mix0)
	getPointer(instance).Mix = p_Mix0;
end
function abi.ffi.prop_get_chorus_sound_effect_rate(instance)
	return getPointer(instance).Rate;
end
function abi.ffi.prop_set_chorus_sound_effect_rate(instance, p_Rate0)
	getPointer(instance).Rate = p_Rate0;
end
function abi.ffi.prop_get_compressor_sound_effect_attack(instance)
	return getPointer(instance).Attack;
end
function abi.ffi.prop_set_compressor_sound_effect_attack(instance, p_Attack0)
	getPointer(instance).Attack = p_Attack0;
end
function abi.ffi.prop_get_compressor_sound_effect_gain_makeup(instance)
	return getPointer(instance).GainMakeup;
end
function abi.ffi.prop_set_compressor_sound_effect_gain_makeup(instance, p_GainMakeup0)
	getPointer(instance).GainMakeup = p_GainMakeup0;
end
function abi.ffi.prop_get_compressor_sound_effect_ratio(instance)
	return getPointer(instance).Ratio;
end
function abi.ffi.prop_set_compressor_sound_effect_ratio(instance, p_Ratio0)
	getPointer(instance).Ratio = p_Ratio0;
end
function abi.ffi.prop_get_compressor_sound_effect_release(instance)
	return getPointer(instance).Release;
end
function abi.ffi.prop_set_compressor_sound_effect_release(instance, p_Release0)
	getPointer(instance).Release = p_Release0;
end
function abi.ffi.prop_get_compressor_sound_effect_side_chain(output, instance)
	local value0 = getPointer(instance).SideChain;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_compressor_sound_effect_side_chain(instance, p_SideChain0, p_SideChain1)
	local value0;
	if p_SideChain0 == 1 then
		value0 = getPointer(p_SideChain1);
	end
	getPointer(instance).SideChain = value0;
end
function abi.ffi.prop_get_compressor_sound_effect_threshold(instance)
	return getPointer(instance).Threshold;
end
function abi.ffi.prop_set_compressor_sound_effect_threshold(instance, p_Threshold0)
	getPointer(instance).Threshold = p_Threshold0;
end
function abi.ffi.prop_get_channel_selector_sound_effect_channel(instance)
	return getPointer(instance).Channel;
end
function abi.ffi.prop_set_channel_selector_sound_effect_channel(instance, p_Channel0)
	getPointer(instance).Channel = p_Channel0;
end
function abi.ffi.prop_get_distortion_sound_effect_level(instance)
	return getPointer(instance).Level;
end
function abi.ffi.prop_set_distortion_sound_effect_level(instance, p_Level0)
	getPointer(instance).Level = p_Level0;
end
function abi.ffi.prop_get_echo_sound_effect_delay(instance)
	return getPointer(instance).Delay;
end
function abi.ffi.prop_set_echo_sound_effect_delay(instance, p_Delay0)
	getPointer(instance).Delay = p_Delay0;
end
function abi.ffi.prop_get_echo_sound_effect_dry_level(instance)
	return getPointer(instance).DryLevel;
end
function abi.ffi.prop_set_echo_sound_effect_dry_level(instance, p_DryLevel0)
	getPointer(instance).DryLevel = p_DryLevel0;
end
function abi.ffi.prop_get_echo_sound_effect_feedback(instance)
	return getPointer(instance).Feedback;
end
function abi.ffi.prop_set_echo_sound_effect_feedback(instance, p_Feedback0)
	getPointer(instance).Feedback = p_Feedback0;
end
function abi.ffi.prop_get_echo_sound_effect_wet_level(instance)
	return getPointer(instance).WetLevel;
end
function abi.ffi.prop_set_echo_sound_effect_wet_level(instance, p_WetLevel0)
	getPointer(instance).WetLevel = p_WetLevel0;
end
function abi.ffi.prop_get_equalizer_sound_effect_high_gain(instance)
	return getPointer(instance).HighGain;
end
function abi.ffi.prop_set_equalizer_sound_effect_high_gain(instance, p_HighGain0)
	getPointer(instance).HighGain = p_HighGain0;
end
function abi.ffi.prop_get_equalizer_sound_effect_low_gain(instance)
	return getPointer(instance).LowGain;
end
function abi.ffi.prop_set_equalizer_sound_effect_low_gain(instance, p_LowGain0)
	getPointer(instance).LowGain = p_LowGain0;
end
function abi.ffi.prop_get_equalizer_sound_effect_mid_gain(instance)
	return getPointer(instance).MidGain;
end
function abi.ffi.prop_set_equalizer_sound_effect_mid_gain(instance, p_MidGain0)
	getPointer(instance).MidGain = p_MidGain0;
end
function abi.ffi.prop_get_flange_sound_effect_depth(instance)
	return getPointer(instance).Depth;
end
function abi.ffi.prop_set_flange_sound_effect_depth(instance, p_Depth0)
	getPointer(instance).Depth = p_Depth0;
end
function abi.ffi.prop_get_flange_sound_effect_mix(instance)
	return getPointer(instance).Mix;
end
function abi.ffi.prop_set_flange_sound_effect_mix(instance, p_Mix0)
	getPointer(instance).Mix = p_Mix0;
end
function abi.ffi.prop_get_flange_sound_effect_rate(instance)
	return getPointer(instance).Rate;
end
function abi.ffi.prop_set_flange_sound_effect_rate(instance, p_Rate0)
	getPointer(instance).Rate = p_Rate0;
end
function abi.ffi.prop_get_pitch_shift_sound_effect_octave(instance)
	return getPointer(instance).Octave;
end
function abi.ffi.prop_set_pitch_shift_sound_effect_octave(instance, p_Octave0)
	getPointer(instance).Octave = p_Octave0;
end
function abi.ffi.prop_get_reverb_sound_effect_decay_time(instance)
	return getPointer(instance).DecayTime;
end
function abi.ffi.prop_set_reverb_sound_effect_decay_time(instance, p_DecayTime0)
	getPointer(instance).DecayTime = p_DecayTime0;
end
function abi.ffi.prop_get_reverb_sound_effect_density(instance)
	return getPointer(instance).Density;
end
function abi.ffi.prop_set_reverb_sound_effect_density(instance, p_Density0)
	getPointer(instance).Density = p_Density0;
end
function abi.ffi.prop_get_reverb_sound_effect_diffusion(instance)
	return getPointer(instance).Diffusion;
end
function abi.ffi.prop_set_reverb_sound_effect_diffusion(instance, p_Diffusion0)
	getPointer(instance).Diffusion = p_Diffusion0;
end
function abi.ffi.prop_get_reverb_sound_effect_dry_level(instance)
	return getPointer(instance).DryLevel;
end
function abi.ffi.prop_set_reverb_sound_effect_dry_level(instance, p_DryLevel0)
	getPointer(instance).DryLevel = p_DryLevel0;
end
function abi.ffi.prop_get_reverb_sound_effect_wet_level(instance)
	return getPointer(instance).WetLevel;
end
function abi.ffi.prop_set_reverb_sound_effect_wet_level(instance, p_WetLevel0)
	getPointer(instance).WetLevel = p_WetLevel0;
end
function abi.ffi.prop_get_tremolo_sound_effect_depth(instance)
	return getPointer(instance).Depth;
end
function abi.ffi.prop_set_tremolo_sound_effect_depth(instance, p_Depth0)
	getPointer(instance).Depth = p_Depth0;
end
function abi.ffi.prop_get_tremolo_sound_effect_duty(instance)
	return getPointer(instance).Duty;
end
function abi.ffi.prop_set_tremolo_sound_effect_duty(instance, p_Duty0)
	getPointer(instance).Duty = p_Duty0;
end
function abi.ffi.prop_get_tremolo_sound_effect_frequency(instance)
	return getPointer(instance).Frequency;
end
function abi.ffi.prop_set_tremolo_sound_effect_frequency(instance, p_Frequency0)
	getPointer(instance).Frequency = p_Frequency0;
end
function abi.ffi.prop_get_sound_group_volume(instance)
	return getPointer(instance).Volume;
end
function abi.ffi.prop_set_sound_group_volume(instance, p_Volume0)
	getPointer(instance).Volume = p_Volume0;
end
function abi.ffi.prop_get_sound_service_ambient_reverb(instance)
	return (getPointer(instance).AmbientReverb).Value;
end
function abi.ffi.prop_set_sound_service_ambient_reverb(instance, p_AmbientReverb0)
	getPointer(instance).AmbientReverb = p_AmbientReverb0;
end
function abi.ffi.prop_get_sound_service_distance_factor(instance)
	return getPointer(instance).DistanceFactor;
end
function abi.ffi.prop_set_sound_service_distance_factor(instance, p_DistanceFactor0)
	getPointer(instance).DistanceFactor = p_DistanceFactor0;
end
function abi.ffi.prop_get_sound_service_doppler_scale(instance)
	return getPointer(instance).DopplerScale;
end
function abi.ffi.prop_set_sound_service_doppler_scale(instance, p_DopplerScale0)
	getPointer(instance).DopplerScale = p_DopplerScale0;
end
function abi.ffi.prop_get_sound_service_respect_filtering_enabled(instance)
	return getPointer(instance).RespectFilteringEnabled and 1 or 0;
end
function abi.ffi.prop_set_sound_service_respect_filtering_enabled(instance, p_RespectFilteringEnabled0)
	getPointer(instance).RespectFilteringEnabled = p_RespectFilteringEnabled0 == 1;
end
function abi.ffi.prop_get_sound_service_rolloff_scale(instance)
	return getPointer(instance).RolloffScale;
end
function abi.ffi.prop_set_sound_service_rolloff_scale(instance, p_RolloffScale0)
	getPointer(instance).RolloffScale = p_RolloffScale0;
end
function abi.ffi.dyn_fn_sound_service_play_local_sound(instance, p_sound0)
	return getPointer(instance):PlayLocalSound(getPointer(p_sound0));
end
function abi.ffi.prop_get_sparkles_color(instance)
	return createPointer(getPointer(instance).Color);
end
function abi.ffi.prop_set_sparkles_color(instance, p_Color0)
	getPointer(instance).Color = getPointer(p_Color0);
end
function abi.ffi.prop_get_sparkles_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_sparkles_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_sparkles_sparkle_color(instance)
	return createPointer(getPointer(instance).SparkleColor);
end
function abi.ffi.prop_set_sparkles_sparkle_color(instance, p_SparkleColor0)
	getPointer(instance).SparkleColor = getPointer(p_SparkleColor0);
end
function abi.ffi.prop_get_sparkles_time_scale(instance)
	return getPointer(instance).TimeScale;
end
function abi.ffi.prop_set_sparkles_time_scale(instance, p_TimeScale0)
	getPointer(instance).TimeScale = p_TimeScale0;
end
function abi.ffi.prop_get_speaker_channel_count(instance)
	return getPointer(instance).ChannelCount;
end
function abi.ffi.prop_get_speaker_playback_loudness(instance)
	return getPointer(instance).PlaybackLoudness;
end
function abi.ffi.prop_get_speaker_roll_off_max_distance(instance)
	return getPointer(instance).RollOffMaxDistance;
end
function abi.ffi.prop_set_speaker_roll_off_max_distance(instance, p_RollOffMaxDistance0)
	getPointer(instance).RollOffMaxDistance = p_RollOffMaxDistance0;
end
function abi.ffi.prop_get_speaker_roll_off_min_distance(instance)
	return getPointer(instance).RollOffMinDistance;
end
function abi.ffi.prop_set_speaker_roll_off_min_distance(instance, p_RollOffMinDistance0)
	getPointer(instance).RollOffMinDistance = p_RollOffMinDistance0;
end
function abi.ffi.prop_get_speaker_roll_off_mode(instance)
	return (getPointer(instance).RollOffMode).Value;
end
function abi.ffi.prop_set_speaker_roll_off_mode(instance, p_RollOffMode0)
	getPointer(instance).RollOffMode = p_RollOffMode0;
end
function abi.ffi.prop_get_speaker_sound_group(output, instance)
	local value0 = getPointer(instance).SoundGroup;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_speaker_sound_group(instance, p_SoundGroup0, p_SoundGroup1)
	local value0;
	if p_SoundGroup0 == 1 then
		value0 = getPointer(p_SoundGroup1);
	end
	getPointer(instance).SoundGroup = value0;
end
function abi.ffi.prop_get_speaker_source(output, instance)
	local value0 = getPointer(instance).Source;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_speaker_source(instance, p_Source0, p_Source1)
	local value0;
	if p_Source0 == 1 then
		value0 = getPointer(p_Source1);
	end
	getPointer(instance).Source = value0;
end
function abi.ffi.prop_get_speaker_volume(instance)
	return getPointer(instance).Volume;
end
function abi.ffi.prop_set_speaker_volume(instance, p_Volume0)
	getPointer(instance).Volume = p_Volume0;
end
function abi.ffi.prop_get_starter_player_allow_custom_animations(instance)
	return getPointer(instance).AllowCustomAnimations and 1 or 0;
end
function abi.ffi.prop_set_starter_player_allow_custom_animations(instance, p_AllowCustomAnimations0)
	getPointer(instance).AllowCustomAnimations = p_AllowCustomAnimations0 == 1;
end
function abi.ffi.prop_get_starter_player_auto_jump_enabled(instance)
	return getPointer(instance).AutoJumpEnabled and 1 or 0;
end
function abi.ffi.prop_set_starter_player_auto_jump_enabled(instance, p_AutoJumpEnabled0)
	getPointer(instance).AutoJumpEnabled = p_AutoJumpEnabled0 == 1;
end
function abi.ffi.prop_get_starter_player_camera_max_zoom_distance(instance)
	return getPointer(instance).CameraMaxZoomDistance;
end
function abi.ffi.prop_set_starter_player_camera_max_zoom_distance(instance, p_CameraMaxZoomDistance0)
	getPointer(instance).CameraMaxZoomDistance = p_CameraMaxZoomDistance0;
end
function abi.ffi.prop_get_starter_player_camera_min_zoom_distance(instance)
	return getPointer(instance).CameraMinZoomDistance;
end
function abi.ffi.prop_set_starter_player_camera_min_zoom_distance(instance, p_CameraMinZoomDistance0)
	getPointer(instance).CameraMinZoomDistance = p_CameraMinZoomDistance0;
end
function abi.ffi.prop_get_starter_player_camera_mode(instance)
	return (getPointer(instance).CameraMode).Value;
end
function abi.ffi.prop_set_starter_player_camera_mode(instance, p_CameraMode0)
	getPointer(instance).CameraMode = p_CameraMode0;
end
function abi.ffi.prop_get_starter_player_character_jump_height(instance)
	return getPointer(instance).CharacterJumpHeight;
end
function abi.ffi.prop_set_starter_player_character_jump_height(instance, p_CharacterJumpHeight0)
	getPointer(instance).CharacterJumpHeight = p_CharacterJumpHeight0;
end
function abi.ffi.prop_get_starter_player_character_jump_power(instance)
	return getPointer(instance).CharacterJumpPower;
end
function abi.ffi.prop_set_starter_player_character_jump_power(instance, p_CharacterJumpPower0)
	getPointer(instance).CharacterJumpPower = p_CharacterJumpPower0;
end
function abi.ffi.prop_get_starter_player_character_max_slope_angle(instance)
	return getPointer(instance).CharacterMaxSlopeAngle;
end
function abi.ffi.prop_set_starter_player_character_max_slope_angle(instance, p_CharacterMaxSlopeAngle0)
	getPointer(instance).CharacterMaxSlopeAngle = p_CharacterMaxSlopeAngle0;
end
function abi.ffi.prop_get_starter_player_character_use_jump_power(instance)
	return getPointer(instance).CharacterUseJumpPower and 1 or 0;
end
function abi.ffi.prop_set_starter_player_character_use_jump_power(instance, p_CharacterUseJumpPower0)
	getPointer(instance).CharacterUseJumpPower = p_CharacterUseJumpPower0 == 1;
end
function abi.ffi.prop_get_starter_player_character_walk_speed(instance)
	return getPointer(instance).CharacterWalkSpeed;
end
function abi.ffi.prop_set_starter_player_character_walk_speed(instance, p_CharacterWalkSpeed0)
	getPointer(instance).CharacterWalkSpeed = p_CharacterWalkSpeed0;
end
function abi.ffi.prop_get_starter_player_dev_camera_occlusion_mode(instance)
	return (getPointer(instance).DevCameraOcclusionMode).Value;
end
function abi.ffi.prop_set_starter_player_dev_camera_occlusion_mode(instance, p_DevCameraOcclusionMode0)
	getPointer(instance).DevCameraOcclusionMode = p_DevCameraOcclusionMode0;
end
function abi.ffi.prop_get_starter_player_dev_computer_camera_movement_mode(instance)
	return (getPointer(instance).DevComputerCameraMovementMode).Value;
end
function abi.ffi.prop_set_starter_player_dev_computer_camera_movement_mode(instance, p_DevComputerCameraMovementMode0)
	getPointer(instance).DevComputerCameraMovementMode = p_DevComputerCameraMovementMode0;
end
function abi.ffi.prop_get_starter_player_dev_computer_movement_mode(instance)
	return (getPointer(instance).DevComputerMovementMode).Value;
end
function abi.ffi.prop_set_starter_player_dev_computer_movement_mode(instance, p_DevComputerMovementMode0)
	getPointer(instance).DevComputerMovementMode = p_DevComputerMovementMode0;
end
function abi.ffi.prop_get_starter_player_dev_touch_camera_movement_mode(instance)
	return (getPointer(instance).DevTouchCameraMovementMode).Value;
end
function abi.ffi.prop_set_starter_player_dev_touch_camera_movement_mode(instance, p_DevTouchCameraMovementMode0)
	getPointer(instance).DevTouchCameraMovementMode = p_DevTouchCameraMovementMode0;
end
function abi.ffi.prop_get_starter_player_dev_touch_movement_mode(instance)
	return (getPointer(instance).DevTouchMovementMode).Value;
end
function abi.ffi.prop_set_starter_player_dev_touch_movement_mode(instance, p_DevTouchMovementMode0)
	getPointer(instance).DevTouchMovementMode = p_DevTouchMovementMode0;
end
function abi.ffi.prop_get_starter_player_enable_mouse_lock_option(instance)
	return getPointer(instance).EnableMouseLockOption and 1 or 0;
end
function abi.ffi.prop_set_starter_player_enable_mouse_lock_option(instance, p_EnableMouseLockOption0)
	getPointer(instance).EnableMouseLockOption = p_EnableMouseLockOption0 == 1;
end
function abi.ffi.prop_get_starter_player_health_display_distance(instance)
	return getPointer(instance).HealthDisplayDistance;
end
function abi.ffi.prop_set_starter_player_health_display_distance(instance, p_HealthDisplayDistance0)
	getPointer(instance).HealthDisplayDistance = p_HealthDisplayDistance0;
end
function abi.ffi.prop_get_starter_player_humanoid_state_machine_mode(instance)
	return (getPointer(instance).HumanoidStateMachineMode).Value;
end
function abi.ffi.prop_set_starter_player_humanoid_state_machine_mode(instance, p_HumanoidStateMachineMode0)
	getPointer(instance).HumanoidStateMachineMode = p_HumanoidStateMachineMode0;
end
function abi.ffi.prop_get_starter_player_load_character_appearance(instance)
	return getPointer(instance).LoadCharacterAppearance and 1 or 0;
end
function abi.ffi.prop_set_starter_player_load_character_appearance(instance, p_LoadCharacterAppearance0)
	getPointer(instance).LoadCharacterAppearance = p_LoadCharacterAppearance0 == 1;
end
function abi.ffi.prop_get_starter_player_name_display_distance(instance)
	return getPointer(instance).NameDisplayDistance;
end
function abi.ffi.prop_set_starter_player_name_display_distance(instance, p_NameDisplayDistance0)
	getPointer(instance).NameDisplayDistance = p_NameDisplayDistance0;
end
function abi.ffi.prop_get_starter_player_user_emotes_enabled(instance)
	return getPointer(instance).UserEmotesEnabled and 1 or 0;
end
function abi.ffi.prop_set_starter_player_user_emotes_enabled(instance, p_UserEmotesEnabled0)
	getPointer(instance).UserEmotesEnabled = p_UserEmotesEnabled0 == 1;
end
function abi.ffi.prop_get_stats_contacts_count(instance)
	return getPointer(instance).ContactsCount;
end
function abi.ffi.prop_get_stats_data_receive_kbps(instance)
	return getPointer(instance).DataReceiveKbps;
end
function abi.ffi.prop_get_stats_data_send_kbps(instance)
	return getPointer(instance).DataSendKbps;
end
function abi.ffi.prop_get_stats_heartbeat_time_ms(instance)
	return getPointer(instance).HeartbeatTimeMs;
end
function abi.ffi.prop_get_stats_instance_count(instance)
	return getPointer(instance).InstanceCount;
end
function abi.ffi.prop_get_stats_moving_primitives_count(instance)
	return getPointer(instance).MovingPrimitivesCount;
end
function abi.ffi.prop_get_stats_physics_receive_kbps(instance)
	return getPointer(instance).PhysicsReceiveKbps;
end
function abi.ffi.prop_get_stats_physics_send_kbps(instance)
	return getPointer(instance).PhysicsSendKbps;
end
function abi.ffi.prop_get_stats_physics_step_time_ms(instance)
	return getPointer(instance).PhysicsStepTimeMs;
end
function abi.ffi.prop_get_stats_primitives_count(instance)
	return getPointer(instance).PrimitivesCount;
end
function abi.ffi.dyn_fn_stats_get_memory_usage_mb_for_tag(instance, p_tag0)
	return getPointer(instance):GetMemoryUsageMbForTag(p_tag0);
end
function abi.ffi.dyn_fn_stats_get_total_memory_usage_mb(instance)
	return getPointer(instance):GetTotalMemoryUsageMb();
end
function abi.ffi.prop_get_team_auto_assignable(instance)
	return getPointer(instance).AutoAssignable and 1 or 0;
end
function abi.ffi.prop_set_team_auto_assignable(instance, p_AutoAssignable0)
	getPointer(instance).AutoAssignable = p_AutoAssignable0 == 1;
end
function abi.ffi.prop_get_team_team_color(instance)
	return createPointer(getPointer(instance).TeamColor);
end
function abi.ffi.prop_set_team_team_color(instance, p_TeamColor0)
	getPointer(instance).TeamColor = getPointer(p_TeamColor0);
end
function abi.ffi.dyn_fn_team_get_players(output, instance)
	local result0 = getPointer(instance):GetPlayers();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.connect_team_player_added(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PlayerAdded:Connect(function(p_player)
		local value0 = p_player;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_team_player_removed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PlayerRemoved:Connect(function(p_player)
		local value0 = p_player;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.dyn_fn_teams_get_teams(output, instance)
	local result0 = getPointer(instance):GetTeams();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.prop_get_teleport_async_result_private_server_id(output, instance)
	local value0 = getPointer(instance).PrivateServerId;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_teleport_async_result_reserved_server_access_code(output, instance)
	local value0 = getPointer(instance).ReservedServerAccessCode;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_teleport_options_reserved_server_access_code(output, instance)
	local value0 = getPointer(instance).ReservedServerAccessCode;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_teleport_options_reserved_server_access_code(instance, p_ReservedServerAccessCode0, p_ReservedServerAccessCode1)
	getPointer(instance).ReservedServerAccessCode = loadString(memory, p_ReservedServerAccessCode0, p_ReservedServerAccessCode1);
end
function abi.ffi.prop_get_teleport_options_server_instance_id(output, instance)
	local value0 = getPointer(instance).ServerInstanceId;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_teleport_options_server_instance_id(instance, p_ServerInstanceId0, p_ServerInstanceId1)
	getPointer(instance).ServerInstanceId = loadString(memory, p_ServerInstanceId0, p_ServerInstanceId1);
end
function abi.ffi.prop_get_teleport_options_should_reserve_server(instance)
	return getPointer(instance).ShouldReserveServer and 1 or 0;
end
function abi.ffi.prop_set_teleport_options_should_reserve_server(instance, p_ShouldReserveServer0)
	getPointer(instance).ShouldReserveServer = p_ShouldReserveServer0 == 1;
end
function abi.ffi.dyn_fn_teleport_options_get_teleport_data(instance)
	return createPointer(getPointer(instance):GetTeleportData());
end
function abi.ffi.dyn_fn_teleport_options_set_teleport_data(instance, p_teleportData0)
	return getPointer(instance):SetTeleportData(getPointer(p_teleportData0));
end
function abi.ffi.dyn_fn_teleport_service_get_arriving_teleport_gui(output, instance)
	local value0 = getPointer(instance):GetArrivingTeleportGui();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_teleport_service_get_local_player_teleport_data(instance)
	return createPointer(getPointer(instance):GetLocalPlayerTeleportData());
end
function abi.ffi.dyn_fn_teleport_service_get_teleport_setting(instance, p_setting0, p_setting1)
	return createPointer(getPointer(instance):GetTeleportSetting(loadString(memory, p_setting0, p_setting1)));
end
function abi.ffi.dyn_fn_teleport_service_set_teleport_gui(instance, p_gui0)
	return getPointer(instance):SetTeleportGui(getPointer(p_gui0));
end
function abi.ffi.dyn_fn_teleport_service_set_teleport_setting(instance, p_setting0, p_setting1, p_value0)
	return getPointer(instance):SetTeleportSetting(loadString(memory, p_setting0, p_setting1), getPointer(p_value0));
end
function abi.ffi.dyn_fn_teleport_service_teleport(instance, p_placeId0, p_player0, p_teleportData0, p_customLoadingScreen0)
	return getPointer(instance):Teleport(p_placeId0, getPointer(p_player0), getPointer(p_teleportData0), getPointer(p_customLoadingScreen0));
end
function abi.ffi.dyn_fn_teleport_service_teleport_to_place_instance(instance, p_placeId0, p_instanceId0, p_instanceId1, p_player0, p_spawnName0, p_spawnName1, p_teleportData0, p_customLoadingScreen0)
	return getPointer(instance):TeleportToPlaceInstance(p_placeId0, loadString(memory, p_instanceId0, p_instanceId1), getPointer(p_player0), loadString(memory, p_spawnName0, p_spawnName1), getPointer(p_teleportData0), getPointer(p_customLoadingScreen0));
end
function abi.ffi.dyn_fn_teleport_service_teleport_to_private_server(instance, p_placeId0, p_reservedServerAccessCode0, p_reservedServerAccessCode1, p_players0, p_players1, p_spawnName0, p_spawnName1, p_teleportData0, p_customLoadingScreen0)
	local result0 = table.create(p_players1)
	for i = 1, p_players1 do
		local value0_0 = loadU32(memory, p_players0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	return getPointer(instance):TeleportToPrivateServer(p_placeId0, loadString(memory, p_reservedServerAccessCode0, p_reservedServerAccessCode1), result0, loadString(memory, p_spawnName0, p_spawnName1), getPointer(p_teleportData0), getPointer(p_customLoadingScreen0));
end
function abi.ffi.dyn_fn_teleport_service_teleport_to_spawn_by_name(instance, p_placeId0, p_spawnName0, p_spawnName1, p_player0, p_teleportData0, p_customLoadingScreen0)
	return getPointer(instance):TeleportToSpawnByName(p_placeId0, loadString(memory, p_spawnName0, p_spawnName1), getPointer(p_player0), getPointer(p_teleportData0), getPointer(p_customLoadingScreen0));
end
function abi.ffi.dyn_fn_teleport_service_teleport_async(output, instance, p_placeId0, p_players0, p_players1, p_teleportOptions0)
	local result0 = table.create(p_players1)
	for i = 1, p_players1 do
		local value0_0 = loadU32(memory, p_players0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	local value0 = getPointer(instance):TeleportAsync(p_placeId0, result0, getPointer(p_teleportOptions0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_teleport_service_teleport_party_async(output, instance, p_placeId0, p_players0, p_players1, p_teleportData0, p_customLoadingScreen0)
	local result0 = table.create(p_players1)
	for i = 1, p_players1 do
		local value0_0 = loadU32(memory, p_players0 + (i - 1) * 4 + 0);
		result0[i] = getPointer(value0_0)
	end
	local value0 = getPointer(instance):TeleportPartyAsync(p_placeId0, result0, getPointer(p_teleportData0), getPointer(p_customLoadingScreen0));
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.connect_teleport_service_local_player_arrived_from_teleport(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).LocalPlayerArrivedFromTeleport:Connect(function(p_loadingGui, p_dataTable)
		local value0 = p_loadingGui;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, createPointer(p_dataTable));
	end))
end
function abi.ffi.connect_teleport_service_teleport_init_failed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TeleportInitFailed:Connect(function(p_player, p_teleportResult, p_errorMessage, p_placeId, p_teleportOptions)
		local value0 = p_player;
		local value1 = p_errorMessage;
		local stringContent1, stringLength1 = allocString(#value1), #value1;
		for i = 1, stringLength1 do
			storeU8(memory, stringContent1 + (i - 1), string.byte(value1:sub(i, i)));
		end
		local value2 = p_teleportOptions;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, (p_teleportResult).Value, stringContent1, stringLength1, p_placeId, value2 and 1 or 0, value2 and createPointer(value2) or 0);
	end))
end
function abi.ffi.prop_get_terrain_detail_face(instance)
	return (getPointer(instance).Face).Value;
end
function abi.ffi.prop_set_terrain_detail_face(instance, p_Face0)
	getPointer(instance).Face = p_Face0;
end
function abi.ffi.prop_get_terrain_detail_material_pattern(instance)
	return (getPointer(instance).MaterialPattern).Value;
end
function abi.ffi.prop_set_terrain_detail_material_pattern(instance, p_MaterialPattern0)
	getPointer(instance).MaterialPattern = p_MaterialPattern0;
end
function abi.ffi.prop_get_terrain_detail_studs_per_tile(instance)
	return getPointer(instance).StudsPerTile;
end
function abi.ffi.prop_set_terrain_detail_studs_per_tile(instance, p_StudsPerTile0)
	getPointer(instance).StudsPerTile = p_StudsPerTile0;
end
function abi.ffi.prop_get_terrain_region_size_in_cells(instance)
	return createPointer(getPointer(instance).SizeInCells);
end
function abi.ffi.dyn_fn_text_channel_display_system_message(output, instance, p_systemMessage0, p_systemMessage1, p_metadata0, p_metadata1)
	local value0 = getPointer(instance):DisplaySystemMessage(loadString(memory, p_systemMessage0, p_systemMessage1), loadString(memory, p_metadata0, p_metadata1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_text_channel_send_async(output, instance, p_message0, p_message1, p_metadata0, p_metadata1)
	local value0 = getPointer(instance):SendAsync(loadString(memory, p_message0, p_message1), loadString(memory, p_metadata0, p_metadata1));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.connect_text_channel_message_received(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MessageReceived:Connect(function(p_incomingMessage)
		local value0 = p_incomingMessage;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.prop_get_text_chat_command_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_text_chat_command_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_text_chat_command_primary_alias(output, instance)
	local value0 = getPointer(instance).PrimaryAlias;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_text_chat_command_primary_alias(instance, p_PrimaryAlias0, p_PrimaryAlias1)
	getPointer(instance).PrimaryAlias = loadString(memory, p_PrimaryAlias0, p_PrimaryAlias1);
end
function abi.ffi.prop_get_text_chat_command_secondary_alias(output, instance)
	local value0 = getPointer(instance).SecondaryAlias;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_text_chat_command_secondary_alias(instance, p_SecondaryAlias0, p_SecondaryAlias1)
	getPointer(instance).SecondaryAlias = loadString(memory, p_SecondaryAlias0, p_SecondaryAlias1);
end
function abi.ffi.connect_text_chat_command_triggered(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Triggered:Connect(function(p_originTextSource, p_unfilteredText)
		local value0 = p_originTextSource;
		local value1 = p_unfilteredText;
		local stringContent1, stringLength1 = allocString(#value1), #value1;
		for i = 1, stringLength1 do
			storeU8(memory, stringContent1 + (i - 1), string.byte(value1:sub(i, i)));
		end
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, stringContent1, stringLength1);
	end))
end
function abi.ffi.prop_get_bubble_chat_configuration_adornee_name(output, instance)
	local value0 = getPointer(instance).AdorneeName;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_bubble_chat_configuration_adornee_name(instance, p_AdorneeName0, p_AdorneeName1)
	getPointer(instance).AdorneeName = loadString(memory, p_AdorneeName0, p_AdorneeName1);
end
function abi.ffi.prop_get_bubble_chat_configuration_background_color_3(instance)
	return createPointer(getPointer(instance).BackgroundColor3);
end
function abi.ffi.prop_set_bubble_chat_configuration_background_color_3(instance, p_BackgroundColor30)
	getPointer(instance).BackgroundColor3 = getPointer(p_BackgroundColor30);
end
function abi.ffi.prop_get_bubble_chat_configuration_bubble_duration(instance)
	return getPointer(instance).BubbleDuration;
end
function abi.ffi.prop_set_bubble_chat_configuration_bubble_duration(instance, p_BubbleDuration0)
	getPointer(instance).BubbleDuration = p_BubbleDuration0;
end
function abi.ffi.prop_get_bubble_chat_configuration_bubbles_spacing(instance)
	return getPointer(instance).BubblesSpacing;
end
function abi.ffi.prop_set_bubble_chat_configuration_bubbles_spacing(instance, p_BubblesSpacing0)
	getPointer(instance).BubblesSpacing = p_BubblesSpacing0;
end
function abi.ffi.prop_get_bubble_chat_configuration_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_bubble_chat_configuration_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_bubble_chat_configuration_font(instance)
	return (getPointer(instance).Font).Value;
end
function abi.ffi.prop_set_bubble_chat_configuration_font(instance, p_Font0)
	getPointer(instance).Font = p_Font0;
end
function abi.ffi.prop_get_bubble_chat_configuration_local_player_studs_offset(instance)
	return createPointer(getPointer(instance).LocalPlayerStudsOffset);
end
function abi.ffi.prop_set_bubble_chat_configuration_local_player_studs_offset(instance, p_LocalPlayerStudsOffset0)
	getPointer(instance).LocalPlayerStudsOffset = getPointer(p_LocalPlayerStudsOffset0);
end
function abi.ffi.prop_get_bubble_chat_configuration_max_distance(instance)
	return getPointer(instance).MaxDistance;
end
function abi.ffi.prop_set_bubble_chat_configuration_max_distance(instance, p_MaxDistance0)
	getPointer(instance).MaxDistance = p_MaxDistance0;
end
function abi.ffi.prop_get_bubble_chat_configuration_minimize_distance(instance)
	return getPointer(instance).MinimizeDistance;
end
function abi.ffi.prop_set_bubble_chat_configuration_minimize_distance(instance, p_MinimizeDistance0)
	getPointer(instance).MinimizeDistance = p_MinimizeDistance0;
end
function abi.ffi.prop_get_bubble_chat_configuration_text_color_3(instance)
	return createPointer(getPointer(instance).TextColor3);
end
function abi.ffi.prop_set_bubble_chat_configuration_text_color_3(instance, p_TextColor30)
	getPointer(instance).TextColor3 = getPointer(p_TextColor30);
end
function abi.ffi.prop_get_bubble_chat_configuration_text_size(instance)
	return getPointer(instance).TextSize;
end
function abi.ffi.prop_set_bubble_chat_configuration_text_size(instance, p_TextSize0)
	getPointer(instance).TextSize = p_TextSize0;
end
function abi.ffi.prop_get_bubble_chat_configuration_vertical_studs_offset(instance)
	return getPointer(instance).VerticalStudsOffset;
end
function abi.ffi.prop_set_bubble_chat_configuration_vertical_studs_offset(instance, p_VerticalStudsOffset0)
	getPointer(instance).VerticalStudsOffset = p_VerticalStudsOffset0;
end
function abi.ffi.prop_get_chat_input_bar_configuration_absolute_position(instance)
	return createPointer(getPointer(instance).AbsolutePosition);
end
function abi.ffi.prop_get_chat_input_bar_configuration_absolute_size(instance)
	return createPointer(getPointer(instance).AbsoluteSize);
end
function abi.ffi.prop_get_chat_input_bar_configuration_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_chat_input_bar_configuration_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_chat_input_bar_configuration_target_text_channel(output, instance)
	local value0 = getPointer(instance).TargetTextChannel;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_chat_input_bar_configuration_target_text_channel(instance, p_TargetTextChannel0, p_TargetTextChannel1)
	local value0;
	if p_TargetTextChannel0 == 1 then
		value0 = getPointer(p_TargetTextChannel1);
	end
	getPointer(instance).TargetTextChannel = value0;
end
function abi.ffi.prop_get_chat_window_configuration_absolute_position(instance)
	return createPointer(getPointer(instance).AbsolutePosition);
end
function abi.ffi.prop_get_chat_window_configuration_absolute_size(instance)
	return createPointer(getPointer(instance).AbsoluteSize);
end
function abi.ffi.prop_get_chat_window_configuration_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_chat_window_configuration_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_chat_window_configuration_horizontal_alignment(instance)
	return (getPointer(instance).HorizontalAlignment).Value;
end
function abi.ffi.prop_set_chat_window_configuration_horizontal_alignment(instance, p_HorizontalAlignment0)
	getPointer(instance).HorizontalAlignment = p_HorizontalAlignment0;
end
function abi.ffi.prop_get_chat_window_configuration_vertical_alignment(instance)
	return (getPointer(instance).VerticalAlignment).Value;
end
function abi.ffi.prop_set_chat_window_configuration_vertical_alignment(instance, p_VerticalAlignment0)
	getPointer(instance).VerticalAlignment = p_VerticalAlignment0;
end
function abi.ffi.prop_get_text_chat_message_message_id(output, instance)
	local value0 = getPointer(instance).MessageId;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_text_chat_message_message_id(instance, p_MessageId0, p_MessageId1)
	getPointer(instance).MessageId = loadString(memory, p_MessageId0, p_MessageId1);
end
function abi.ffi.prop_get_text_chat_message_metadata(output, instance)
	local value0 = getPointer(instance).Metadata;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_text_chat_message_metadata(instance, p_Metadata0, p_Metadata1)
	getPointer(instance).Metadata = loadString(memory, p_Metadata0, p_Metadata1);
end
function abi.ffi.prop_get_text_chat_message_prefix_text(output, instance)
	local value0 = getPointer(instance).PrefixText;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_text_chat_message_prefix_text(instance, p_PrefixText0, p_PrefixText1)
	getPointer(instance).PrefixText = loadString(memory, p_PrefixText0, p_PrefixText1);
end
function abi.ffi.prop_get_text_chat_message_status(instance)
	return (getPointer(instance).Status).Value;
end
function abi.ffi.prop_set_text_chat_message_status(instance, p_Status0)
	getPointer(instance).Status = p_Status0;
end
function abi.ffi.prop_get_text_chat_message_text(output, instance)
	local value0 = getPointer(instance).Text;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_text_chat_message_text(instance, p_Text0, p_Text1)
	getPointer(instance).Text = loadString(memory, p_Text0, p_Text1);
end
function abi.ffi.prop_get_text_chat_message_text_channel(output, instance)
	local value0 = getPointer(instance).TextChannel;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_text_chat_message_text_channel(instance, p_TextChannel0, p_TextChannel1)
	local value0;
	if p_TextChannel0 == 1 then
		value0 = getPointer(p_TextChannel1);
	end
	getPointer(instance).TextChannel = value0;
end
function abi.ffi.prop_get_text_chat_message_text_source(output, instance)
	local value0 = getPointer(instance).TextSource;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_text_chat_message_text_source(instance, p_TextSource0, p_TextSource1)
	local value0;
	if p_TextSource0 == 1 then
		value0 = getPointer(p_TextSource1);
	end
	getPointer(instance).TextSource = value0;
end
function abi.ffi.prop_get_text_chat_message_timestamp(instance)
	return createPointer(getPointer(instance).Timestamp);
end
function abi.ffi.prop_set_text_chat_message_timestamp(instance, p_Timestamp0)
	getPointer(instance).Timestamp = getPointer(p_Timestamp0);
end
function abi.ffi.prop_get_text_chat_message_properties_prefix_text(output, instance)
	local value0 = getPointer(instance).PrefixText;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_text_chat_message_properties_prefix_text(instance, p_PrefixText0, p_PrefixText1)
	getPointer(instance).PrefixText = loadString(memory, p_PrefixText0, p_PrefixText1);
end
function abi.ffi.prop_get_text_chat_message_properties_text(output, instance)
	local value0 = getPointer(instance).Text;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_text_chat_message_properties_text(instance, p_Text0, p_Text1)
	getPointer(instance).Text = loadString(memory, p_Text0, p_Text1);
end
function abi.ffi.prop_get_text_chat_service_chat_version(instance)
	return (getPointer(instance).ChatVersion).Value;
end
function abi.ffi.prop_set_text_chat_service_chat_version(instance, p_ChatVersion0)
	getPointer(instance).ChatVersion = p_ChatVersion0;
end
function abi.ffi.prop_get_text_chat_service_create_default_commands(instance)
	return getPointer(instance).CreateDefaultCommands and 1 or 0;
end
function abi.ffi.prop_set_text_chat_service_create_default_commands(instance, p_CreateDefaultCommands0)
	getPointer(instance).CreateDefaultCommands = p_CreateDefaultCommands0 == 1;
end
function abi.ffi.prop_get_text_chat_service_create_default_text_channels(instance)
	return getPointer(instance).CreateDefaultTextChannels and 1 or 0;
end
function abi.ffi.prop_set_text_chat_service_create_default_text_channels(instance, p_CreateDefaultTextChannels0)
	getPointer(instance).CreateDefaultTextChannels = p_CreateDefaultTextChannels0 == 1;
end
function abi.ffi.connect_text_chat_service_message_received(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).MessageReceived:Connect(function(p_textChatMessage)
		local value0 = p_textChatMessage;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_text_chat_service_sending_message(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).SendingMessage:Connect(function(p_textChatMessage)
		local value0 = p_textChatMessage;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.dyn_fn_text_filter_result_get_chat_for_user_async(output, instance, p_toUserId0)
	local value0 = getPointer(instance):GetChatForUserAsync(p_toUserId0);
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_text_filter_result_get_non_chat_string_for_broadcast_async(output, instance)
	local value0 = getPointer(instance):GetNonChatStringForBroadcastAsync();
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_text_filter_result_get_non_chat_string_for_user_async(output, instance, p_toUserId0)
	local value0 = getPointer(instance):GetNonChatStringForUserAsync(p_toUserId0);
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_text_service_get_text_size(instance, p_string0, p_string1, p_fontSize0, p_font0, p_frameSize0)
	return createPointer(getPointer(instance):GetTextSize(loadString(memory, p_string0, p_string1), p_fontSize0, p_font0, getPointer(p_frameSize0)));
end
function abi.ffi.dyn_fn_text_service_filter_string_async(output, instance, p_stringToFilter0, p_stringToFilter1, p_fromUserId0, p_textContext0)
	local value0 = getPointer(instance):FilterStringAsync(loadString(memory, p_stringToFilter0, p_stringToFilter1), p_fromUserId0, p_textContext0);
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_text_service_get_family_info_async(instance, p_assetId0)
	return createPointer(getPointer(instance):GetFamilyInfoAsync(getPointer(p_assetId0)));
end
function abi.ffi.dyn_fn_text_service_get_text_bounds_async(instance, p_params0)
	return createPointer(getPointer(instance):GetTextBoundsAsync(getPointer(p_params0)));
end
function abi.ffi.prop_get_text_source_can_send(instance)
	return getPointer(instance).CanSend and 1 or 0;
end
function abi.ffi.prop_set_text_source_can_send(instance, p_CanSend0)
	getPointer(instance).CanSend = p_CanSend0 == 1;
end
function abi.ffi.prop_get_text_source_user_id(instance)
	return getPointer(instance).UserId;
end
function abi.ffi.prop_get_tracker_lod_controller_audio_mode(instance)
	return (getPointer(instance).AudioMode).Value;
end
function abi.ffi.prop_set_tracker_lod_controller_audio_mode(instance, p_AudioMode0)
	getPointer(instance).AudioMode = p_AudioMode0;
end
function abi.ffi.prop_get_tracker_lod_controller_video_extrapolation_mode(instance)
	return (getPointer(instance).VideoExtrapolationMode).Value;
end
function abi.ffi.prop_set_tracker_lod_controller_video_extrapolation_mode(instance, p_VideoExtrapolationMode0)
	getPointer(instance).VideoExtrapolationMode = p_VideoExtrapolationMode0;
end
function abi.ffi.prop_get_tracker_lod_controller_video_lod_mode(instance)
	return (getPointer(instance).VideoLodMode).Value;
end
function abi.ffi.prop_set_tracker_lod_controller_video_lod_mode(instance, p_VideoLodMode0)
	getPointer(instance).VideoLodMode = p_VideoLodMode0;
end
function abi.ffi.prop_get_tracker_lod_controller_video_mode(instance)
	return (getPointer(instance).VideoMode).Value;
end
function abi.ffi.prop_set_tracker_lod_controller_video_mode(instance, p_VideoMode0)
	getPointer(instance).VideoMode = p_VideoMode0;
end
function abi.ffi.prop_get_trail_attachment_0(output, instance)
	local value0 = getPointer(instance).Attachment0;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_trail_attachment_0(instance, p_Attachment00, p_Attachment01)
	local value0;
	if p_Attachment00 == 1 then
		value0 = getPointer(p_Attachment01);
	end
	getPointer(instance).Attachment0 = value0;
end
function abi.ffi.prop_get_trail_attachment_1(output, instance)
	local value0 = getPointer(instance).Attachment1;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_trail_attachment_1(instance, p_Attachment10, p_Attachment11)
	local value0;
	if p_Attachment10 == 1 then
		value0 = getPointer(p_Attachment11);
	end
	getPointer(instance).Attachment1 = value0;
end
function abi.ffi.prop_get_trail_brightness(instance)
	return getPointer(instance).Brightness;
end
function abi.ffi.prop_set_trail_brightness(instance, p_Brightness0)
	getPointer(instance).Brightness = p_Brightness0;
end
function abi.ffi.prop_get_trail_color(instance)
	return createPointer(getPointer(instance).Color);
end
function abi.ffi.prop_set_trail_color(instance, p_Color0)
	getPointer(instance).Color = getPointer(p_Color0);
end
function abi.ffi.prop_get_trail_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_trail_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_trail_face_camera(instance)
	return getPointer(instance).FaceCamera and 1 or 0;
end
function abi.ffi.prop_set_trail_face_camera(instance, p_FaceCamera0)
	getPointer(instance).FaceCamera = p_FaceCamera0 == 1;
end
function abi.ffi.prop_get_trail_lifetime(instance)
	return getPointer(instance).Lifetime;
end
function abi.ffi.prop_set_trail_lifetime(instance, p_Lifetime0)
	getPointer(instance).Lifetime = p_Lifetime0;
end
function abi.ffi.prop_get_trail_light_emission(instance)
	return getPointer(instance).LightEmission;
end
function abi.ffi.prop_set_trail_light_emission(instance, p_LightEmission0)
	getPointer(instance).LightEmission = p_LightEmission0;
end
function abi.ffi.prop_get_trail_light_influence(instance)
	return getPointer(instance).LightInfluence;
end
function abi.ffi.prop_set_trail_light_influence(instance, p_LightInfluence0)
	getPointer(instance).LightInfluence = p_LightInfluence0;
end
function abi.ffi.prop_get_trail_max_length(instance)
	return getPointer(instance).MaxLength;
end
function abi.ffi.prop_set_trail_max_length(instance, p_MaxLength0)
	getPointer(instance).MaxLength = p_MaxLength0;
end
function abi.ffi.prop_get_trail_min_length(instance)
	return getPointer(instance).MinLength;
end
function abi.ffi.prop_set_trail_min_length(instance, p_MinLength0)
	getPointer(instance).MinLength = p_MinLength0;
end
function abi.ffi.prop_get_trail_texture(instance)
	return createPointer(getPointer(instance).Texture);
end
function abi.ffi.prop_set_trail_texture(instance, p_Texture0)
	getPointer(instance).Texture = getPointer(p_Texture0);
end
function abi.ffi.prop_get_trail_texture_length(instance)
	return getPointer(instance).TextureLength;
end
function abi.ffi.prop_set_trail_texture_length(instance, p_TextureLength0)
	getPointer(instance).TextureLength = p_TextureLength0;
end
function abi.ffi.prop_get_trail_texture_mode(instance)
	return (getPointer(instance).TextureMode).Value;
end
function abi.ffi.prop_set_trail_texture_mode(instance, p_TextureMode0)
	getPointer(instance).TextureMode = p_TextureMode0;
end
function abi.ffi.prop_get_trail_transparency(instance)
	return createPointer(getPointer(instance).Transparency);
end
function abi.ffi.prop_set_trail_transparency(instance, p_Transparency0)
	getPointer(instance).Transparency = getPointer(p_Transparency0);
end
function abi.ffi.prop_get_trail_width_scale(instance)
	return createPointer(getPointer(instance).WidthScale);
end
function abi.ffi.prop_set_trail_width_scale(instance, p_WidthScale0)
	getPointer(instance).WidthScale = getPointer(p_WidthScale0);
end
function abi.ffi.dyn_fn_trail_clear(instance)
	return getPointer(instance):Clear();
end
function abi.ffi.prop_get_translator_locale_id(output, instance)
	local value0 = getPointer(instance).LocaleId;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_translator_format_by_key(output, instance, p_key0, p_key1, p_args0)
	local value0 = getPointer(instance):FormatByKey(loadString(memory, p_key0, p_key1), getPointer(p_args0));
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_translator_translate(output, instance, p_context0, p_text0, p_text1)
	local value0 = getPointer(instance):Translate(getPointer(p_context0), loadString(memory, p_text0, p_text1));
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_get_tween_base_playback_state(instance)
	return (getPointer(instance).PlaybackState).Value;
end
function abi.ffi.dyn_fn_tween_base_cancel(instance)
	return getPointer(instance):Cancel();
end
function abi.ffi.dyn_fn_tween_base_pause(instance)
	return getPointer(instance):Pause();
end
function abi.ffi.dyn_fn_tween_base_play(instance)
	return getPointer(instance):Play();
end
function abi.ffi.connect_tween_base_completed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Completed:Connect(function(p_playbackState)
		invokeFunction(data, vtable, (p_playbackState).Value);
	end))
end
function abi.ffi.prop_get_tween_instance(output, instance)
	local value0 = getPointer(instance).Instance;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_tween_tween_info(instance)
	return createPointer(getPointer(instance).TweenInfo);
end
function abi.ffi.dyn_fn_tween_service_create(output, instance, p_instance0, p_tweenInfo0, p_propertyTable0)
	local value0 = getPointer(instance):Create(getPointer(p_instance0), getPointer(p_tweenInfo0), getPointer(p_propertyTable0));
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_tween_service_get_value(instance, p_alpha0, p_easingStyle0, p_easingDirection0)
	return getPointer(instance):GetValue(p_alpha0, p_easingStyle0, p_easingDirection0);
end
function abi.ffi.prop_get_ui_aspect_ratio_constraint_aspect_ratio(instance)
	return getPointer(instance).AspectRatio;
end
function abi.ffi.prop_set_ui_aspect_ratio_constraint_aspect_ratio(instance, p_AspectRatio0)
	getPointer(instance).AspectRatio = p_AspectRatio0;
end
function abi.ffi.prop_get_ui_aspect_ratio_constraint_aspect_type(instance)
	return (getPointer(instance).AspectType).Value;
end
function abi.ffi.prop_set_ui_aspect_ratio_constraint_aspect_type(instance, p_AspectType0)
	getPointer(instance).AspectType = p_AspectType0;
end
function abi.ffi.prop_get_ui_aspect_ratio_constraint_dominant_axis(instance)
	return (getPointer(instance).DominantAxis).Value;
end
function abi.ffi.prop_set_ui_aspect_ratio_constraint_dominant_axis(instance, p_DominantAxis0)
	getPointer(instance).DominantAxis = p_DominantAxis0;
end
function abi.ffi.prop_get_ui_size_constraint_max_size(instance)
	return createPointer(getPointer(instance).MaxSize);
end
function abi.ffi.prop_set_ui_size_constraint_max_size(instance, p_MaxSize0)
	getPointer(instance).MaxSize = getPointer(p_MaxSize0);
end
function abi.ffi.prop_get_ui_size_constraint_min_size(instance)
	return createPointer(getPointer(instance).MinSize);
end
function abi.ffi.prop_set_ui_size_constraint_min_size(instance, p_MinSize0)
	getPointer(instance).MinSize = getPointer(p_MinSize0);
end
function abi.ffi.prop_get_ui_text_size_constraint_max_text_size(instance)
	return getPointer(instance).MaxTextSize;
end
function abi.ffi.prop_set_ui_text_size_constraint_max_text_size(instance, p_MaxTextSize0)
	getPointer(instance).MaxTextSize = p_MaxTextSize0;
end
function abi.ffi.prop_get_ui_text_size_constraint_min_text_size(instance)
	return getPointer(instance).MinTextSize;
end
function abi.ffi.prop_set_ui_text_size_constraint_min_text_size(instance, p_MinTextSize0)
	getPointer(instance).MinTextSize = p_MinTextSize0;
end
function abi.ffi.prop_get_ui_corner_corner_radius(instance)
	return createPointer(getPointer(instance).CornerRadius);
end
function abi.ffi.prop_set_ui_corner_corner_radius(instance, p_CornerRadius0)
	getPointer(instance).CornerRadius = getPointer(p_CornerRadius0);
end
function abi.ffi.prop_get_ui_gradient_color(instance)
	return createPointer(getPointer(instance).Color);
end
function abi.ffi.prop_set_ui_gradient_color(instance, p_Color0)
	getPointer(instance).Color = getPointer(p_Color0);
end
function abi.ffi.prop_get_ui_gradient_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_ui_gradient_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_ui_gradient_offset(instance)
	return createPointer(getPointer(instance).Offset);
end
function abi.ffi.prop_set_ui_gradient_offset(instance, p_Offset0)
	getPointer(instance).Offset = getPointer(p_Offset0);
end
function abi.ffi.prop_get_ui_gradient_rotation(instance)
	return getPointer(instance).Rotation;
end
function abi.ffi.prop_set_ui_gradient_rotation(instance, p_Rotation0)
	getPointer(instance).Rotation = p_Rotation0;
end
function abi.ffi.prop_get_ui_gradient_transparency(instance)
	return createPointer(getPointer(instance).Transparency);
end
function abi.ffi.prop_set_ui_gradient_transparency(instance, p_Transparency0)
	getPointer(instance).Transparency = getPointer(p_Transparency0);
end
function abi.ffi.prop_get_ui_grid_style_layout_absolute_content_size(instance)
	return createPointer(getPointer(instance).AbsoluteContentSize);
end
function abi.ffi.prop_get_ui_grid_style_layout_fill_direction(instance)
	return (getPointer(instance).FillDirection).Value;
end
function abi.ffi.prop_set_ui_grid_style_layout_fill_direction(instance, p_FillDirection0)
	getPointer(instance).FillDirection = p_FillDirection0;
end
function abi.ffi.prop_get_ui_grid_style_layout_horizontal_alignment(instance)
	return (getPointer(instance).HorizontalAlignment).Value;
end
function abi.ffi.prop_set_ui_grid_style_layout_horizontal_alignment(instance, p_HorizontalAlignment0)
	getPointer(instance).HorizontalAlignment = p_HorizontalAlignment0;
end
function abi.ffi.prop_get_ui_grid_style_layout_sort_order(instance)
	return (getPointer(instance).SortOrder).Value;
end
function abi.ffi.prop_set_ui_grid_style_layout_sort_order(instance, p_SortOrder0)
	getPointer(instance).SortOrder = p_SortOrder0;
end
function abi.ffi.prop_get_ui_grid_style_layout_vertical_alignment(instance)
	return (getPointer(instance).VerticalAlignment).Value;
end
function abi.ffi.prop_set_ui_grid_style_layout_vertical_alignment(instance, p_VerticalAlignment0)
	getPointer(instance).VerticalAlignment = p_VerticalAlignment0;
end
function abi.ffi.prop_get_ui_grid_layout_absolute_cell_count(instance)
	return createPointer(getPointer(instance).AbsoluteCellCount);
end
function abi.ffi.prop_get_ui_grid_layout_absolute_cell_size(instance)
	return createPointer(getPointer(instance).AbsoluteCellSize);
end
function abi.ffi.prop_get_ui_grid_layout_cell_padding(instance)
	return createPointer(getPointer(instance).CellPadding);
end
function abi.ffi.prop_set_ui_grid_layout_cell_padding(instance, p_CellPadding0)
	getPointer(instance).CellPadding = getPointer(p_CellPadding0);
end
function abi.ffi.prop_get_ui_grid_layout_cell_size(instance)
	return createPointer(getPointer(instance).CellSize);
end
function abi.ffi.prop_set_ui_grid_layout_cell_size(instance, p_CellSize0)
	getPointer(instance).CellSize = getPointer(p_CellSize0);
end
function abi.ffi.prop_get_ui_grid_layout_fill_direction_max_cells(instance)
	return getPointer(instance).FillDirectionMaxCells;
end
function abi.ffi.prop_set_ui_grid_layout_fill_direction_max_cells(instance, p_FillDirectionMaxCells0)
	getPointer(instance).FillDirectionMaxCells = p_FillDirectionMaxCells0;
end
function abi.ffi.prop_get_ui_grid_layout_start_corner(instance)
	return (getPointer(instance).StartCorner).Value;
end
function abi.ffi.prop_set_ui_grid_layout_start_corner(instance, p_StartCorner0)
	getPointer(instance).StartCorner = p_StartCorner0;
end
function abi.ffi.prop_get_ui_list_layout_padding(instance)
	return createPointer(getPointer(instance).Padding);
end
function abi.ffi.prop_set_ui_list_layout_padding(instance, p_Padding0)
	getPointer(instance).Padding = getPointer(p_Padding0);
end
function abi.ffi.prop_get_ui_page_layout_animated(instance)
	return getPointer(instance).Animated and 1 or 0;
end
function abi.ffi.prop_set_ui_page_layout_animated(instance, p_Animated0)
	getPointer(instance).Animated = p_Animated0 == 1;
end
function abi.ffi.prop_get_ui_page_layout_circular(instance)
	return getPointer(instance).Circular and 1 or 0;
end
function abi.ffi.prop_set_ui_page_layout_circular(instance, p_Circular0)
	getPointer(instance).Circular = p_Circular0 == 1;
end
function abi.ffi.prop_get_ui_page_layout_current_page(output, instance)
	local value0 = getPointer(instance).CurrentPage;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_get_ui_page_layout_easing_direction(instance)
	return (getPointer(instance).EasingDirection).Value;
end
function abi.ffi.prop_set_ui_page_layout_easing_direction(instance, p_EasingDirection0)
	getPointer(instance).EasingDirection = p_EasingDirection0;
end
function abi.ffi.prop_get_ui_page_layout_easing_style(instance)
	return (getPointer(instance).EasingStyle).Value;
end
function abi.ffi.prop_set_ui_page_layout_easing_style(instance, p_EasingStyle0)
	getPointer(instance).EasingStyle = p_EasingStyle0;
end
function abi.ffi.prop_get_ui_page_layout_gamepad_input_enabled(instance)
	return getPointer(instance).GamepadInputEnabled and 1 or 0;
end
function abi.ffi.prop_set_ui_page_layout_gamepad_input_enabled(instance, p_GamepadInputEnabled0)
	getPointer(instance).GamepadInputEnabled = p_GamepadInputEnabled0 == 1;
end
function abi.ffi.prop_get_ui_page_layout_padding(instance)
	return createPointer(getPointer(instance).Padding);
end
function abi.ffi.prop_set_ui_page_layout_padding(instance, p_Padding0)
	getPointer(instance).Padding = getPointer(p_Padding0);
end
function abi.ffi.prop_get_ui_page_layout_scroll_wheel_input_enabled(instance)
	return getPointer(instance).ScrollWheelInputEnabled and 1 or 0;
end
function abi.ffi.prop_set_ui_page_layout_scroll_wheel_input_enabled(instance, p_ScrollWheelInputEnabled0)
	getPointer(instance).ScrollWheelInputEnabled = p_ScrollWheelInputEnabled0 == 1;
end
function abi.ffi.prop_get_ui_page_layout_touch_input_enabled(instance)
	return getPointer(instance).TouchInputEnabled and 1 or 0;
end
function abi.ffi.prop_set_ui_page_layout_touch_input_enabled(instance, p_TouchInputEnabled0)
	getPointer(instance).TouchInputEnabled = p_TouchInputEnabled0 == 1;
end
function abi.ffi.prop_get_ui_page_layout_tween_time(instance)
	return getPointer(instance).TweenTime;
end
function abi.ffi.prop_set_ui_page_layout_tween_time(instance, p_TweenTime0)
	getPointer(instance).TweenTime = p_TweenTime0;
end
function abi.ffi.dyn_fn_ui_page_layout_jump_to(instance, p_page0)
	return getPointer(instance):JumpTo(getPointer(p_page0));
end
function abi.ffi.dyn_fn_ui_page_layout_jump_to_index(instance, p_index0)
	return getPointer(instance):JumpToIndex(p_index0);
end
function abi.ffi.dyn_fn_ui_page_layout_next(instance)
	return getPointer(instance):Next();
end
function abi.ffi.dyn_fn_ui_page_layout_previous(instance)
	return getPointer(instance):Previous();
end
function abi.ffi.connect_ui_page_layout_page_enter(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PageEnter:Connect(function(p_page)
		local value0 = p_page;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_ui_page_layout_page_leave(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PageLeave:Connect(function(p_page)
		local value0 = p_page;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_ui_page_layout_stopped(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Stopped:Connect(function(p_currentPage)
		local value0 = p_currentPage;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.prop_get_ui_table_layout_fill_empty_space_columns(instance)
	return getPointer(instance).FillEmptySpaceColumns and 1 or 0;
end
function abi.ffi.prop_set_ui_table_layout_fill_empty_space_columns(instance, p_FillEmptySpaceColumns0)
	getPointer(instance).FillEmptySpaceColumns = p_FillEmptySpaceColumns0 == 1;
end
function abi.ffi.prop_get_ui_table_layout_fill_empty_space_rows(instance)
	return getPointer(instance).FillEmptySpaceRows and 1 or 0;
end
function abi.ffi.prop_set_ui_table_layout_fill_empty_space_rows(instance, p_FillEmptySpaceRows0)
	getPointer(instance).FillEmptySpaceRows = p_FillEmptySpaceRows0 == 1;
end
function abi.ffi.prop_get_ui_table_layout_major_axis(instance)
	return (getPointer(instance).MajorAxis).Value;
end
function abi.ffi.prop_set_ui_table_layout_major_axis(instance, p_MajorAxis0)
	getPointer(instance).MajorAxis = p_MajorAxis0;
end
function abi.ffi.prop_get_ui_table_layout_padding(instance)
	return createPointer(getPointer(instance).Padding);
end
function abi.ffi.prop_set_ui_table_layout_padding(instance, p_Padding0)
	getPointer(instance).Padding = getPointer(p_Padding0);
end
function abi.ffi.prop_get_ui_padding_padding_bottom(instance)
	return createPointer(getPointer(instance).PaddingBottom);
end
function abi.ffi.prop_set_ui_padding_padding_bottom(instance, p_PaddingBottom0)
	getPointer(instance).PaddingBottom = getPointer(p_PaddingBottom0);
end
function abi.ffi.prop_get_ui_padding_padding_left(instance)
	return createPointer(getPointer(instance).PaddingLeft);
end
function abi.ffi.prop_set_ui_padding_padding_left(instance, p_PaddingLeft0)
	getPointer(instance).PaddingLeft = getPointer(p_PaddingLeft0);
end
function abi.ffi.prop_get_ui_padding_padding_right(instance)
	return createPointer(getPointer(instance).PaddingRight);
end
function abi.ffi.prop_set_ui_padding_padding_right(instance, p_PaddingRight0)
	getPointer(instance).PaddingRight = getPointer(p_PaddingRight0);
end
function abi.ffi.prop_get_ui_padding_padding_top(instance)
	return createPointer(getPointer(instance).PaddingTop);
end
function abi.ffi.prop_set_ui_padding_padding_top(instance, p_PaddingTop0)
	getPointer(instance).PaddingTop = getPointer(p_PaddingTop0);
end
function abi.ffi.prop_get_ui_scale_scale(instance)
	return getPointer(instance).Scale;
end
function abi.ffi.prop_set_ui_scale_scale(instance, p_Scale0)
	getPointer(instance).Scale = p_Scale0;
end
function abi.ffi.prop_get_ui_stroke_apply_stroke_mode(instance)
	return (getPointer(instance).ApplyStrokeMode).Value;
end
function abi.ffi.prop_set_ui_stroke_apply_stroke_mode(instance, p_ApplyStrokeMode0)
	getPointer(instance).ApplyStrokeMode = p_ApplyStrokeMode0;
end
function abi.ffi.prop_get_ui_stroke_color(instance)
	return createPointer(getPointer(instance).Color);
end
function abi.ffi.prop_set_ui_stroke_color(instance, p_Color0)
	getPointer(instance).Color = getPointer(p_Color0);
end
function abi.ffi.prop_get_ui_stroke_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_ui_stroke_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_ui_stroke_line_join_mode(instance)
	return (getPointer(instance).LineJoinMode).Value;
end
function abi.ffi.prop_set_ui_stroke_line_join_mode(instance, p_LineJoinMode0)
	getPointer(instance).LineJoinMode = p_LineJoinMode0;
end
function abi.ffi.prop_get_ui_stroke_thickness(instance)
	return getPointer(instance).Thickness;
end
function abi.ffi.prop_set_ui_stroke_thickness(instance, p_Thickness0)
	getPointer(instance).Thickness = p_Thickness0;
end
function abi.ffi.prop_get_ui_stroke_transparency(instance)
	return getPointer(instance).Transparency;
end
function abi.ffi.prop_set_ui_stroke_transparency(instance, p_Transparency0)
	getPointer(instance).Transparency = p_Transparency0;
end
function abi.ffi.prop_get_user_game_settings_computer_camera_movement_mode(instance)
	return (getPointer(instance).ComputerCameraMovementMode).Value;
end
function abi.ffi.prop_set_user_game_settings_computer_camera_movement_mode(instance, p_ComputerCameraMovementMode0)
	getPointer(instance).ComputerCameraMovementMode = p_ComputerCameraMovementMode0;
end
function abi.ffi.prop_get_user_game_settings_computer_movement_mode(instance)
	return (getPointer(instance).ComputerMovementMode).Value;
end
function abi.ffi.prop_set_user_game_settings_computer_movement_mode(instance, p_ComputerMovementMode0)
	getPointer(instance).ComputerMovementMode = p_ComputerMovementMode0;
end
function abi.ffi.prop_get_user_game_settings_control_mode(instance)
	return (getPointer(instance).ControlMode).Value;
end
function abi.ffi.prop_set_user_game_settings_control_mode(instance, p_ControlMode0)
	getPointer(instance).ControlMode = p_ControlMode0;
end
function abi.ffi.prop_get_user_game_settings_gamepad_camera_sensitivity(instance)
	return getPointer(instance).GamepadCameraSensitivity;
end
function abi.ffi.prop_set_user_game_settings_gamepad_camera_sensitivity(instance, p_GamepadCameraSensitivity0)
	getPointer(instance).GamepadCameraSensitivity = p_GamepadCameraSensitivity0;
end
function abi.ffi.prop_get_user_game_settings_mouse_sensitivity(instance)
	return getPointer(instance).MouseSensitivity;
end
function abi.ffi.prop_set_user_game_settings_mouse_sensitivity(instance, p_MouseSensitivity0)
	getPointer(instance).MouseSensitivity = p_MouseSensitivity0;
end
function abi.ffi.prop_get_user_game_settings_rcc_profiler_record_frame_rate(instance)
	return getPointer(instance).RCCProfilerRecordFrameRate;
end
function abi.ffi.prop_set_user_game_settings_rcc_profiler_record_frame_rate(instance, p_RCCProfilerRecordFrameRate0)
	getPointer(instance).RCCProfilerRecordFrameRate = p_RCCProfilerRecordFrameRate0;
end
function abi.ffi.prop_get_user_game_settings_rcc_profiler_record_time_frame(instance)
	return getPointer(instance).RCCProfilerRecordTimeFrame;
end
function abi.ffi.prop_set_user_game_settings_rcc_profiler_record_time_frame(instance, p_RCCProfilerRecordTimeFrame0)
	getPointer(instance).RCCProfilerRecordTimeFrame = p_RCCProfilerRecordTimeFrame0;
end
function abi.ffi.prop_get_user_game_settings_rotation_type(instance)
	return (getPointer(instance).RotationType).Value;
end
function abi.ffi.prop_set_user_game_settings_rotation_type(instance, p_RotationType0)
	getPointer(instance).RotationType = p_RotationType0;
end
function abi.ffi.prop_get_user_game_settings_saved_quality_level(instance)
	return (getPointer(instance).SavedQualityLevel).Value;
end
function abi.ffi.prop_set_user_game_settings_saved_quality_level(instance, p_SavedQualityLevel0)
	getPointer(instance).SavedQualityLevel = p_SavedQualityLevel0;
end
function abi.ffi.prop_get_user_game_settings_touch_camera_movement_mode(instance)
	return (getPointer(instance).TouchCameraMovementMode).Value;
end
function abi.ffi.prop_set_user_game_settings_touch_camera_movement_mode(instance, p_TouchCameraMovementMode0)
	getPointer(instance).TouchCameraMovementMode = p_TouchCameraMovementMode0;
end
function abi.ffi.prop_get_user_game_settings_touch_movement_mode(instance)
	return (getPointer(instance).TouchMovementMode).Value;
end
function abi.ffi.prop_set_user_game_settings_touch_movement_mode(instance, p_TouchMovementMode0)
	getPointer(instance).TouchMovementMode = p_TouchMovementMode0;
end
function abi.ffi.prop_get_user_game_settings_vr_smooth_rotation_enabled(instance)
	return getPointer(instance).VRSmoothRotationEnabled and 1 or 0;
end
function abi.ffi.prop_set_user_game_settings_vr_smooth_rotation_enabled(instance, p_VRSmoothRotationEnabled0)
	getPointer(instance).VRSmoothRotationEnabled = p_VRSmoothRotationEnabled0 == 1;
end
function abi.ffi.prop_get_user_game_settings_vignette_enabled(instance)
	return getPointer(instance).VignetteEnabled and 1 or 0;
end
function abi.ffi.prop_set_user_game_settings_vignette_enabled(instance, p_VignetteEnabled0)
	getPointer(instance).VignetteEnabled = p_VignetteEnabled0 == 1;
end
function abi.ffi.dyn_fn_user_game_settings_get_camera_y_invert_value(instance)
	return getPointer(instance):GetCameraYInvertValue();
end
function abi.ffi.dyn_fn_user_game_settings_get_onboarding_completed(instance, p_onboardingId0, p_onboardingId1)
	return getPointer(instance):GetOnboardingCompleted(loadString(memory, p_onboardingId0, p_onboardingId1)) and 1 or 0;
end
function abi.ffi.dyn_fn_user_game_settings_in_full_screen(instance)
	return getPointer(instance):InFullScreen() and 1 or 0;
end
function abi.ffi.dyn_fn_user_game_settings_in_studio_mode(instance)
	return getPointer(instance):InStudioMode() and 1 or 0;
end
function abi.ffi.dyn_fn_user_game_settings_set_camera_y_invert_visible(instance)
	return getPointer(instance):SetCameraYInvertVisible();
end
function abi.ffi.dyn_fn_user_game_settings_set_gamepad_camera_sensitivity_visible(instance)
	return getPointer(instance):SetGamepadCameraSensitivityVisible();
end
function abi.ffi.dyn_fn_user_game_settings_set_onboarding_completed(instance, p_onboardingId0, p_onboardingId1)
	return getPointer(instance):SetOnboardingCompleted(loadString(memory, p_onboardingId0, p_onboardingId1));
end
function abi.ffi.connect_user_game_settings_fullscreen_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).FullscreenChanged:Connect(function(p_isFullscreen)
		invokeFunction(data, vtable, p_isFullscreen and 1 or 0);
	end))
end
function abi.ffi.connect_user_game_settings_studio_mode_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).StudioModeChanged:Connect(function(p_isStudioMode)
		invokeFunction(data, vtable, p_isStudioMode and 1 or 0);
	end))
end
function abi.ffi.prop_get_user_input_service_accelerometer_enabled(instance)
	return getPointer(instance).AccelerometerEnabled and 1 or 0;
end
function abi.ffi.prop_get_user_input_service_gamepad_enabled(instance)
	return getPointer(instance).GamepadEnabled and 1 or 0;
end
function abi.ffi.prop_get_user_input_service_gyroscope_enabled(instance)
	return getPointer(instance).GyroscopeEnabled and 1 or 0;
end
function abi.ffi.prop_get_user_input_service_keyboard_enabled(instance)
	return getPointer(instance).KeyboardEnabled and 1 or 0;
end
function abi.ffi.prop_get_user_input_service_mouse_behavior(instance)
	return (getPointer(instance).MouseBehavior).Value;
end
function abi.ffi.prop_set_user_input_service_mouse_behavior(instance, p_MouseBehavior0)
	getPointer(instance).MouseBehavior = p_MouseBehavior0;
end
function abi.ffi.prop_get_user_input_service_mouse_delta_sensitivity(instance)
	return getPointer(instance).MouseDeltaSensitivity;
end
function abi.ffi.prop_set_user_input_service_mouse_delta_sensitivity(instance, p_MouseDeltaSensitivity0)
	getPointer(instance).MouseDeltaSensitivity = p_MouseDeltaSensitivity0;
end
function abi.ffi.prop_get_user_input_service_mouse_enabled(instance)
	return getPointer(instance).MouseEnabled and 1 or 0;
end
function abi.ffi.prop_get_user_input_service_mouse_icon_enabled(instance)
	return getPointer(instance).MouseIconEnabled and 1 or 0;
end
function abi.ffi.prop_set_user_input_service_mouse_icon_enabled(instance, p_MouseIconEnabled0)
	getPointer(instance).MouseIconEnabled = p_MouseIconEnabled0 == 1;
end
function abi.ffi.prop_get_user_input_service_on_screen_keyboard_position(instance)
	return createPointer(getPointer(instance).OnScreenKeyboardPosition);
end
function abi.ffi.prop_get_user_input_service_on_screen_keyboard_size(instance)
	return createPointer(getPointer(instance).OnScreenKeyboardSize);
end
function abi.ffi.prop_get_user_input_service_on_screen_keyboard_visible(instance)
	return getPointer(instance).OnScreenKeyboardVisible and 1 or 0;
end
function abi.ffi.prop_get_user_input_service_touch_enabled(instance)
	return getPointer(instance).TouchEnabled and 1 or 0;
end
function abi.ffi.prop_get_user_input_service_vr_enabled(instance)
	return getPointer(instance).VREnabled and 1 or 0;
end
function abi.ffi.dyn_fn_user_input_service_gamepad_supports(instance, p_gamepadNum0, p_gamepadKeyCode0)
	return getPointer(instance):GamepadSupports(p_gamepadNum0, p_gamepadKeyCode0) and 1 or 0;
end
function abi.ffi.dyn_fn_user_input_service_get_connected_gamepads(output, instance)
	local result0 = getPointer(instance):GetConnectedGamepads();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, (v).Value)
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_user_input_service_get_device_acceleration(output, instance)
	local value0 = getPointer(instance):GetDeviceAcceleration();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_user_input_service_get_device_gravity(output, instance)
	local value0 = getPointer(instance):GetDeviceGravity();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_user_input_service_get_focused_text_box(output, instance)
	local value0 = getPointer(instance):GetFocusedTextBox();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_user_input_service_get_gamepad_connected(instance, p_gamepadNum0)
	return getPointer(instance):GetGamepadConnected(p_gamepadNum0) and 1 or 0;
end
function abi.ffi.dyn_fn_user_input_service_get_gamepad_state(output, instance, p_gamepadNum0)
	local result0 = getPointer(instance):GetGamepadState(p_gamepadNum0);
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_user_input_service_get_keys_pressed(output, instance)
	local result0 = getPointer(instance):GetKeysPressed();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_user_input_service_get_last_input_type(instance)
	return (getPointer(instance):GetLastInputType()).Value;
end
function abi.ffi.dyn_fn_user_input_service_get_mouse_buttons_pressed(output, instance)
	local result0 = getPointer(instance):GetMouseButtonsPressed();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_user_input_service_get_mouse_delta(instance)
	return createPointer(getPointer(instance):GetMouseDelta());
end
function abi.ffi.dyn_fn_user_input_service_get_mouse_location(instance)
	return createPointer(getPointer(instance):GetMouseLocation());
end
function abi.ffi.dyn_fn_user_input_service_get_navigation_gamepads(output, instance)
	local result0 = getPointer(instance):GetNavigationGamepads();
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, (v).Value)
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_user_input_service_get_string_for_key_code(output, instance, p_keyCode0)
	local value0 = getPointer(instance):GetStringForKeyCode(p_keyCode0);
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.dyn_fn_user_input_service_get_supported_gamepad_key_codes(output, instance, p_gamepadNum0)
	local result0 = getPointer(instance):GetSupportedGamepadKeyCodes(p_gamepadNum0);
	local vec0 = allocVec(#result0 * 4);
	for i, v in ipairs(result0) do
		storeU32(memory, vec0 + (i - 1) * 4 + 0, (v).Value)
	end
	storeU32(memory, output + 0, vec0)
	storeU32(memory, output + 4, #result0)
end
function abi.ffi.dyn_fn_user_input_service_get_user_c_frame(instance, p_type0)
	return createPointer(getPointer(instance):GetUserCFrame(p_type0));
end
function abi.ffi.dyn_fn_user_input_service_is_gamepad_button_down(instance, p_gamepadNum0, p_gamepadKeyCode0)
	return getPointer(instance):IsGamepadButtonDown(p_gamepadNum0, p_gamepadKeyCode0) and 1 or 0;
end
function abi.ffi.dyn_fn_user_input_service_is_key_down(instance, p_keyCode0)
	return getPointer(instance):IsKeyDown(p_keyCode0) and 1 or 0;
end
function abi.ffi.dyn_fn_user_input_service_is_mouse_button_pressed(instance, p_mouseButton0)
	return getPointer(instance):IsMouseButtonPressed(p_mouseButton0) and 1 or 0;
end
function abi.ffi.dyn_fn_user_input_service_is_navigation_gamepad(instance, p_gamepadEnum0)
	return getPointer(instance):IsNavigationGamepad(p_gamepadEnum0) and 1 or 0;
end
function abi.ffi.dyn_fn_user_input_service_recenter_user_head_c_frame(instance)
	return getPointer(instance):RecenterUserHeadCFrame();
end
function abi.ffi.dyn_fn_user_input_service_set_navigation_gamepad(instance, p_gamepadEnum0, p_enabled0)
	return getPointer(instance):SetNavigationGamepad(p_gamepadEnum0, p_enabled0 == 1);
end
function abi.ffi.connect_user_input_service_device_acceleration_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).DeviceAccelerationChanged:Connect(function(p_acceleration)
		local value0 = p_acceleration;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_user_input_service_device_gravity_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).DeviceGravityChanged:Connect(function(p_gravity)
		local value0 = p_gravity;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_user_input_service_device_rotation_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).DeviceRotationChanged:Connect(function(p_rotation, p_cframe)
		local value0 = p_rotation;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, createPointer(p_cframe));
	end))
end
function abi.ffi.connect_user_input_service_gamepad_connected(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).GamepadConnected:Connect(function(p_gamepadNum)
		invokeFunction(data, vtable, (p_gamepadNum).Value);
	end))
end
function abi.ffi.connect_user_input_service_gamepad_disconnected(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).GamepadDisconnected:Connect(function(p_gamepadNum)
		invokeFunction(data, vtable, (p_gamepadNum).Value);
	end))
end
function abi.ffi.connect_user_input_service_input_began(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).InputBegan:Connect(function(p_input, p_gameProcessedEvent)
		local value0 = p_input;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, p_gameProcessedEvent and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_input_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).InputChanged:Connect(function(p_input, p_gameProcessedEvent)
		local value0 = p_input;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, p_gameProcessedEvent and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_input_ended(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).InputEnded:Connect(function(p_input, p_gameProcessedEvent)
		local value0 = p_input;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, p_gameProcessedEvent and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_jump_request(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).JumpRequest:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_user_input_service_last_input_type_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).LastInputTypeChanged:Connect(function(p_lastInputType)
		invokeFunction(data, vtable, (p_lastInputType).Value);
	end))
end
function abi.ffi.connect_user_input_service_pointer_action(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).PointerAction:Connect(function(p_wheel, p_pan, p_pinch, p_gameProcessedEvent)
		invokeFunction(data, vtable, p_wheel, createPointer(p_pan), p_pinch, p_gameProcessedEvent and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_text_box_focus_released(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TextBoxFocusReleased:Connect(function(p_textboxReleased)
		local value0 = p_textboxReleased;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_user_input_service_text_box_focused(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TextBoxFocused:Connect(function(p_textboxFocused)
		local value0 = p_textboxFocused;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.connect_user_input_service_touch_ended(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TouchEnded:Connect(function(p_touch, p_gameProcessedEvent)
		local value0 = p_touch;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, p_gameProcessedEvent and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_touch_long_press(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TouchLongPress:Connect(function(p_touchPositions, p_state, p_gameProcessedEvent)
		local result0 = p_touchPositions;
		local vec0 = allocVec(#result0 * 4);
		for i, v in ipairs(result0) do
			storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
		end
		invokeFunction(data, vtable, vec0, #result0, (p_state).Value, p_gameProcessedEvent and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_touch_moved(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TouchMoved:Connect(function(p_touch, p_gameProcessedEvent)
		local value0 = p_touch;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, p_gameProcessedEvent and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_touch_pan(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TouchPan:Connect(function(p_touchPositions, p_totalTranslation, p_velocity, p_state, p_gameProcessedEvent)
		local result0 = p_touchPositions;
		local vec0 = allocVec(#result0 * 4);
		for i, v in ipairs(result0) do
			storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
		end
		invokeFunction(data, vtable, vec0, #result0, createPointer(p_totalTranslation), createPointer(p_velocity), (p_state).Value, p_gameProcessedEvent and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_touch_pinch(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TouchPinch:Connect(function(p_touchPositions, p_scale, p_velocity, p_state, p_gameProcessedEvent)
		local result0 = p_touchPositions;
		local vec0 = allocVec(#result0 * 4);
		for i, v in ipairs(result0) do
			storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
		end
		invokeFunction(data, vtable, vec0, #result0, p_scale, p_velocity, (p_state).Value, p_gameProcessedEvent and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_touch_rotate(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TouchRotate:Connect(function(p_touchPositions, p_rotation, p_velocity, p_state, p_gameProcessedEvent)
		local result0 = p_touchPositions;
		local vec0 = allocVec(#result0 * 4);
		for i, v in ipairs(result0) do
			storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
		end
		invokeFunction(data, vtable, vec0, #result0, p_rotation, p_velocity, (p_state).Value, p_gameProcessedEvent and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_touch_started(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TouchStarted:Connect(function(p_touch, p_gameProcessedEvent)
		local value0 = p_touch;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0, p_gameProcessedEvent and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_touch_swipe(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TouchSwipe:Connect(function(p_swipeDirection, p_numberOfTouches, p_gameProcessedEvent)
		invokeFunction(data, vtable, (p_swipeDirection).Value, p_numberOfTouches, p_gameProcessedEvent and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_touch_tap(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TouchTap:Connect(function(p_touchPositions, p_gameProcessedEvent)
		local result0 = p_touchPositions;
		local vec0 = allocVec(#result0 * 4);
		for i, v in ipairs(result0) do
			storeU32(memory, vec0 + (i - 1) * 4 + 0, createPointer(v))
		end
		invokeFunction(data, vtable, vec0, #result0, p_gameProcessedEvent and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_touch_tap_in_world(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TouchTapInWorld:Connect(function(p_position, p_processedByUI)
		invokeFunction(data, vtable, createPointer(p_position), p_processedByUI and 1 or 0);
	end))
end
function abi.ffi.connect_user_input_service_user_c_frame_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).UserCFrameChanged:Connect(function(p_type, p_value)
		invokeFunction(data, vtable, (p_type).Value, createPointer(p_value));
	end))
end
function abi.ffi.connect_user_input_service_window_focus_released(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).WindowFocusReleased:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.connect_user_input_service_window_focused(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).WindowFocused:Connect(function()
		invokeFunction(data, vtable);
	end))
end
function abi.ffi.prop_get_vr_service_gui_input_user_c_frame(instance)
	return (getPointer(instance).GuiInputUserCFrame).Value;
end
function abi.ffi.prop_set_vr_service_gui_input_user_c_frame(instance, p_GuiInputUserCFrame0)
	getPointer(instance).GuiInputUserCFrame = p_GuiInputUserCFrame0;
end
function abi.ffi.prop_get_vr_service_vr_enabled(instance)
	return getPointer(instance).VREnabled and 1 or 0;
end
function abi.ffi.dyn_fn_vr_service_get_touchpad_mode(instance, p_pad0)
	return (getPointer(instance):GetTouchpadMode(p_pad0)).Value;
end
function abi.ffi.dyn_fn_vr_service_get_user_c_frame(instance, p_type0)
	return createPointer(getPointer(instance):GetUserCFrame(p_type0));
end
function abi.ffi.dyn_fn_vr_service_get_user_c_frame_enabled(instance, p_type0)
	return getPointer(instance):GetUserCFrameEnabled(p_type0) and 1 or 0;
end
function abi.ffi.dyn_fn_vr_service_recenter_user_head_c_frame(instance)
	return getPointer(instance):RecenterUserHeadCFrame();
end
function abi.ffi.dyn_fn_vr_service_request_navigation(instance, p_cframe0, p_inputUserCFrame0)
	return getPointer(instance):RequestNavigation(getPointer(p_cframe0), p_inputUserCFrame0);
end
function abi.ffi.dyn_fn_vr_service_set_touchpad_mode(instance, p_pad0, p_mode0)
	return getPointer(instance):SetTouchpadMode(p_pad0, p_mode0);
end
function abi.ffi.connect_vr_service_navigation_requested(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).NavigationRequested:Connect(function(p_cframe, p_inputUserCFrame)
		invokeFunction(data, vtable, createPointer(p_cframe), (p_inputUserCFrame).Value);
	end))
end
function abi.ffi.connect_vr_service_touchpad_mode_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).TouchpadModeChanged:Connect(function(p_pad, p_mode)
		invokeFunction(data, vtable, (p_pad).Value, (p_mode).Value);
	end))
end
function abi.ffi.connect_vr_service_user_c_frame_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).UserCFrameChanged:Connect(function(p_type, p_value)
		invokeFunction(data, vtable, (p_type).Value, createPointer(p_value));
	end))
end
function abi.ffi.connect_vr_service_user_c_frame_enabled(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).UserCFrameEnabled:Connect(function(p_type, p_enabled)
		invokeFunction(data, vtable, (p_type).Value, p_enabled and 1 or 0);
	end))
end
function abi.ffi.prop_get_bool_value_value(instance)
	return getPointer(instance).Value and 1 or 0;
end
function abi.ffi.prop_set_bool_value_value(instance, p_Value0)
	getPointer(instance).Value = p_Value0 == 1;
end
function abi.ffi.connect_bool_value_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Changed:Connect(function(p_value)
		invokeFunction(data, vtable, p_value and 1 or 0);
	end))
end
function abi.ffi.prop_get_brick_color_value_value(instance)
	return createPointer(getPointer(instance).Value);
end
function abi.ffi.prop_set_brick_color_value_value(instance, p_Value0)
	getPointer(instance).Value = getPointer(p_Value0);
end
function abi.ffi.connect_brick_color_value_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Changed:Connect(function(p_value)
		invokeFunction(data, vtable, createPointer(p_value));
	end))
end
function abi.ffi.prop_get_c_frame_value_value(instance)
	return createPointer(getPointer(instance).Value);
end
function abi.ffi.prop_set_c_frame_value_value(instance, p_Value0)
	getPointer(instance).Value = getPointer(p_Value0);
end
function abi.ffi.connect_c_frame_value_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Changed:Connect(function(p_value)
		invokeFunction(data, vtable, createPointer(p_value));
	end))
end
function abi.ffi.prop_get_color_3_value_value(instance)
	return createPointer(getPointer(instance).Value);
end
function abi.ffi.prop_set_color_3_value_value(instance, p_Value0)
	getPointer(instance).Value = getPointer(p_Value0);
end
function abi.ffi.connect_color_3_value_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Changed:Connect(function(p_value)
		invokeFunction(data, vtable, createPointer(p_value));
	end))
end
function abi.ffi.prop_get_int_value_value(instance)
	return getPointer(instance).Value;
end
function abi.ffi.prop_set_int_value_value(instance, p_Value0)
	getPointer(instance).Value = p_Value0;
end
function abi.ffi.connect_int_value_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Changed:Connect(function(p_value)
		invokeFunction(data, vtable, p_value);
	end))
end
function abi.ffi.prop_get_number_value_value(instance)
	return getPointer(instance).Value;
end
function abi.ffi.prop_set_number_value_value(instance, p_Value0)
	getPointer(instance).Value = p_Value0;
end
function abi.ffi.connect_number_value_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Changed:Connect(function(p_value)
		invokeFunction(data, vtable, p_value);
	end))
end
function abi.ffi.prop_get_object_value_value(output, instance)
	local value0 = getPointer(instance).Value;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_object_value_value(instance, p_Value0, p_Value1)
	local value0;
	if p_Value0 == 1 then
		value0 = getPointer(p_Value1);
	end
	getPointer(instance).Value = value0;
end
function abi.ffi.connect_object_value_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Changed:Connect(function(p_value)
		local value0 = p_value;
		invokeFunction(data, vtable, value0 and 1 or 0, value0 and createPointer(value0) or 0);
	end))
end
function abi.ffi.prop_get_ray_value_value(instance)
	return createPointer(getPointer(instance).Value);
end
function abi.ffi.prop_set_ray_value_value(instance, p_Value0)
	getPointer(instance).Value = getPointer(p_Value0);
end
function abi.ffi.connect_ray_value_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Changed:Connect(function(p_value)
		invokeFunction(data, vtable, createPointer(p_value));
	end))
end
function abi.ffi.prop_get_string_value_value(output, instance)
	local value0 = getPointer(instance).Value;
	local stringContent0, stringLength0 = allocString(#value0), #value0;
	for i = 1, stringLength0 do
		storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
	end
	storeU32(memory, output + 0, stringContent0)
	storeU32(memory, output + 4, stringLength0)
end
function abi.ffi.prop_set_string_value_value(instance, p_Value0, p_Value1)
	getPointer(instance).Value = loadString(memory, p_Value0, p_Value1);
end
function abi.ffi.connect_string_value_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Changed:Connect(function(p_value)
		local value0 = p_value;
		local stringContent0, stringLength0 = allocString(#value0), #value0;
		for i = 1, stringLength0 do
			storeU8(memory, stringContent0 + (i - 1), string.byte(value0:sub(i, i)));
		end
		invokeFunction(data, vtable, stringContent0, stringLength0);
	end))
end
function abi.ffi.prop_get_vector_3_value_value(instance)
	return createPointer(getPointer(instance).Value);
end
function abi.ffi.prop_set_vector_3_value_value(instance, p_Value0)
	getPointer(instance).Value = getPointer(p_Value0);
end
function abi.ffi.connect_vector_3_value_changed(instance, data, vtable)
	return createConnection(data, vtable, getPointer(instance).Changed:Connect(function(p_value)
		invokeFunction(data, vtable, createPointer(p_value));
	end))
end
function abi.ffi.dyn_fn_vector_3_curve_x(output, instance)
	local value0 = getPointer(instance):X();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_vector_3_curve_y(output, instance)
	local value0 = getPointer(instance):Y();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_vector_3_curve_z(output, instance)
	local value0 = getPointer(instance):Z();
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.dyn_fn_voice_chat_internal_is_voice_enabled_for_user_id_async(instance, p_userId0)
	return getPointer(instance):IsVoiceEnabledForUserIdAsync(p_userId0) and 1 or 0;
end
function abi.ffi.dyn_fn_voice_chat_service_is_voice_enabled_for_user_id_async(instance, p_userId0)
	return getPointer(instance):IsVoiceEnabledForUserIdAsync(p_userId0) and 1 or 0;
end
function abi.ffi.prop_get_voice_source_user_id(instance)
	return getPointer(instance).UserId;
end
function abi.ffi.prop_get_weld_constraint_active(instance)
	return getPointer(instance).Active and 1 or 0;
end
function abi.ffi.prop_get_weld_constraint_enabled(instance)
	return getPointer(instance).Enabled and 1 or 0;
end
function abi.ffi.prop_set_weld_constraint_enabled(instance, p_Enabled0)
	getPointer(instance).Enabled = p_Enabled0 == 1;
end
function abi.ffi.prop_get_weld_constraint_part_0(output, instance)
	local value0 = getPointer(instance).Part0;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_weld_constraint_part_0(instance, p_Part00, p_Part01)
	local value0;
	if p_Part00 == 1 then
		value0 = getPointer(p_Part01);
	end
	getPointer(instance).Part0 = value0;
end
function abi.ffi.prop_get_weld_constraint_part_1(output, instance)
	local value0 = getPointer(instance).Part1;
	storeU32(memory, output + 0, value0 and 1 or 0)
	storeU32(memory, output + 4, value0 and createPointer(value0) or 0)
end
function abi.ffi.prop_set_weld_constraint_part_1(instance, p_Part10, p_Part11)
	local value0;
	if p_Part10 == 1 then
		value0 = getPointer(p_Part11);
	end
	getPointer(instance).Part1 = value0;
end
function lua_value_number(value)
	return createPointer(value);
end
function abi.ffi.lua_value_string(addr, len)
	return createPointer(loadString(memory, addr, len));
end
function abi.ffi.string_lua_value(output, value)
	local text = getPointer(value);
	if type(text) ~= "string" then
		storeU32(memory, output, 0);
		storeU32(memory, output + 4, 0);
		storeU32(memory, output + 8, 0);
		return;
	end

	local rustString = allocString(#text);
	for i = 1, #text do
		storeU8(memory, rustString + (i - 1), string.byte(text, i, i));
	end
	storeU32(memory, output, 1);
	storeU32(memory, output + 4, rustString);
	storeU32(memory, output + 8, #text);
end
abi.ffi.lua_value_f32 = lua_value_number;
abi.ffi.lua_value_f64 = lua_value_number;
abi.ffi.lua_value_i8 = lua_value_number;
abi.ffi.lua_value_i16 = lua_value_number;
abi.ffi.lua_value_i32 = lua_value_number;
abi.ffi.lua_value_i64 = lua_value_number;
abi.ffi.lua_value_u8 = lua_value_number;
abi.ffi.lua_value_u16 = lua_value_number;
abi.ffi.lua_value_u32 = lua_value_number;
abi.ffi.lua_value_u64 = lua_value_number;
abi.ffi.lua_value_usize = lua_value_number;
abi.ffi.lua_value_isize = lua_value_number;
return abi;
